 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\GrindrPlus.kt --- 
package com.grindrplus

import android.annotation.SuppressLint
import android.app.Activity
import android.app.Application
import android.app.Application.ActivityLifecycleCallbacks
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.widget.Toast
import com.grindrplus.bridge.BridgeClient
import com.grindrplus.core.Config
import com.grindrplus.core.EventManager
import com.grindrplus.core.InstanceManager
import com.grindrplus.core.Logger
import com.grindrplus.core.LogSource
import com.grindrplus.core.TaskScheduler
import com.grindrplus.utils.TaskManager
import com.grindrplus.core.Utils.handleImports
import com.grindrplus.core.http.Client
import com.grindrplus.core.http.Interceptor
import com.grindrplus.persistence.GPDatabase
import com.grindrplus.utils.HookManager
import com.grindrplus.utils.PCHIP
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hookConstructor
import dalvik.system.DexClassLoader
import de.robv.android.xposed.XposedHelpers.getObjectField
import de.robv.android.xposed.XposedHelpers.callMethod
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout
import okhttp3.Call
import okhttp3.Callback
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import org.json.JSONArray
import org.json.JSONObject
import timber.log.Timber
import java.io.File
import java.io.IOException
import java.lang.ref.WeakReference
import kotlin.system.measureTimeMillis

@SuppressLint("StaticFieldLeak")
object GrindrPlus {
    lateinit var context: Context
        private set
    lateinit var classLoader: ClassLoader
        private set
    lateinit var database: GPDatabase
        private set
    lateinit var bridgeClient: BridgeClient
        internal set
    lateinit var instanceManager: InstanceManager
        private set
    lateinit var httpClient: Client
        private set
    lateinit var packageName: String
        private set

    lateinit var hookManager: HookManager

    var shouldTriggerAntiblock = true
    var blockCaller: String = ""
    var isImportingSomething = false
    var myProfileId: String = ""
    var hasCheckedVersions = false
    var shouldShowVersionMismatchDialog = false
    var shouldShowBridgeConnectionError = false

    private var isInitialized = false
    private var isMainInitialized = false
    private var isInstanceManagerInitialized = false

    var spline = PCHIP(
        listOf(
            1238563200L to 0,          // 2009-04-01
            1285027200L to 1000000,    // 2010-09-21
            1462924800L to 35512000,   // 2016-05-11
            1501804800L to 132076000,  // 2017-08-04
            1546547829L to 201948000,  // 2019-01-03
            1618531200L to 351220000,  // 2021-04-16
            1636150385L to 390338000,  // 2021-11-05
            1637963460L to 394800000,  // 2021-11-26
            1680393600L to 505225000,  // 2023-04-02
            1717200000L to 630495000,  // 2024-06-01
            1717372800L to 634942000,  // 2024-06-03
            1729950240L to 699724000,  // 2024-10-26
            1732986600L to 710609000,  // 2024-11-30
            1733349060L to 711676000,  // 2024-12-04
            1735229820L to 718934000,  // 2024-12-26
            1738065780L to 730248000,  // 2025-01-29
            1739059200L to 733779000,  // 2025-02-09
            1741564800L to 744008000   // 2025-03-10
        )
    )

    //MySettingsViewModel(GrindrPlus.hookManager, GrindrPlus.taskManager)

    val currentActivity: Activity?
        get() = currentActivityRef?.get()

    internal val userAgent = "g7.g" // search for 'grindr3/'
    internal val userSession = "Ng.f" // search for 'com.grindrapp.android.storage.UserSessionImpl$1'
    private val deviceInfo =
        "E4.E" // search for 'AdvertisingIdClient.Info("00000000-0000-0000-0000-000000000000", true)'
    internal val grindrLocationProvider = "F9.d" // search for 'system settings insufficient for location request, attempting to resolve'
    internal val serverDrivenCascadeRepo = "com.grindrapp.android.persistence.repository.ServerDrivenCascadeRepo"
    internal val ageVerificationActivity = "com.grindrapp.android.ageverification.presentation.ui.AgeVerificationActivity"
    internal val serverNotification = "com.grindrapp.android.network.websocket.model.WebSocketNotification\$ServerNotification"

    private val ioScope = CoroutineScope(Dispatchers.IO)
    private val taskScheduer = TaskScheduler(ioScope)
    internal val taskManager = TaskManager(taskScheduer)
    private var currentActivityRef: WeakReference<Activity>? = null

    private val splineDataEndpoint =
        "https://raw.githubusercontent.com/R0rt1z2/GrindrPlus/refs/heads/master/spline.json"

    val serverNotifications = EventManager.serverNotifications

    fun init(modulePath: String, application: Application,
             versionCodes: IntArray, versionNames: Array<String>) {

        if (isInitialized) {
            Logger.d("GrindrPlus already initialized, skipping", LogSource.MODULE)
            return
        }

        this.context = application
        this.bridgeClient = BridgeClient(context)

        Logger.initialize(context, bridgeClient, true)
        if (Timber.forest().isEmpty()) {
            Timber.plant(Timber.DebugTree())
            }
        Logger.i("Initializing GrindrPlus...", LogSource.MODULE)

        checkVersionCodes(versionCodes, versionNames)
        val connected = runBlocking {
            try {
                withTimeout(10000) {
                    bridgeClient.connectWithRetry(5, 1000)
                }
            } catch (e: Exception) {
                Logger.e("Connection timeout: ${e.message}", LogSource.MODULE)
                false
            }
        }

        if (!connected) {
            Logger.e("Failed to connect to the bridge service", LogSource.MODULE)
            shouldShowBridgeConnectionError = true
        }

        Config.initialize(application.packageName)
        val newModule = File(context.filesDir, "grindrplus.dex")
        File(modulePath).copyTo(newModule, true)
        newModule.setReadOnly()

        this.classLoader =
            DexClassLoader(newModule.absolutePath, null, null, context.classLoader)
        this.database = GPDatabase.create(context)
        GPDatabase.DatabaseManager.markReady()
        this.hookManager = HookManager()
        this.instanceManager = InstanceManager(classLoader)
        this.packageName = context.packageName

        if (bridgeClient.shouldRegenAndroidId(packageName)) {
            Logger.i("Generating new Android device ID", LogSource.MODULE)
            val androidId = java.util.UUID.randomUUID()
                .toString().replace("-", "").lowercase().take(16)
            Config.put("android_device_id", androidId)
        }

        val forcedCoordinates = bridgeClient.getForcedLocation(packageName)

        if (forcedCoordinates.isNotEmpty()) {
            val parts = forcedCoordinates.split(",").map { it.trim() }
            if (parts.size != 2 || parts.any { it.toDoubleOrNull() == null }) {
                Logger.w("Invalid forced coordinates format: $forcedCoordinates", LogSource.MODULE)
            } else {
                if (parts[0] == "0.0" && parts[1] == "0.0") {
                    Logger.w("Ignoring forced coordinates: $forcedCoordinates", LogSource.MODULE)
                } else {
                    Logger.i("Using forced coordinates: $forcedCoordinates", LogSource.MODULE)
                    Config.put("forced_coordinates", forcedCoordinates)
                }
            }
        } else if (Config.get("forced_coordinates", "") != "") {
            Logger.i("Clearing previously set forced coordinates", LogSource.MODULE)
            Config.put("forced_coordinates", "")
        }

        registerActivityLifecycleCallbacks(application)

        if (shouldShowVersionMismatchDialog) {
            Logger.i("Version mismatch detected, stopping initialization", LogSource.MODULE)
            return
        }

        try {
            setupInstanceManager()
            setupServerNotificationHook()
        } catch (t: Throwable) {
            Logger.e("Failed to hook critical classes: ${t.message}", LogSource.MODULE)
            Logger.writeRaw(t.stackTraceToString())
            showToast(Toast.LENGTH_LONG, "Failed to hook critical classes: ${t.message}")
            return
        }

        fetchRemoteData(splineDataEndpoint) { points ->
            spline = PCHIP(points)
            Logger.i("Updated spline with remote data", LogSource.MODULE)
        }

        try {
            val initTime = measureTimeMillis { initializeCore() }
            Logger.i("Initialization completed in $initTime ms", LogSource.MODULE)
            isInitialized = true
        } catch (t: Throwable) {
            Logger.e("Failed to initialize: ${t.message}", LogSource.MODULE)
            Logger.writeRaw(t.stackTraceToString())
            showToast(Toast.LENGTH_LONG, "Failed to initialize: ${t.message}")
            return
        }
    }

    private fun setupServerNotificationHook() {
        try {
            classLoader.loadClass(serverNotification).hookConstructor(HookStage.AFTER) { param ->
                try {
                    val serverNotification = param.thisObject()
                    val typeValue = callMethod(serverNotification, "getTypeValue") as String
                    val notificationId = callMethod(serverNotification, "getNotificationId") as String?
                    val payload = callMethod(serverNotification, "getPayload") as JSONObject?
                    val status = callMethod(serverNotification, "getStatus") as Int?
                    val refValue = callMethod(serverNotification, "getRefValue") as String?

                    EventManager.emitServerNotification(typeValue, notificationId, payload, status, refValue)
                    Logger.d("ServerNotification hooked and event emitted: $typeValue", LogSource.MODULE)
                } catch (e: Exception) {
                    Logger.e("Failed to emit server notification event: ${e.message}", LogSource.MODULE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Failed to setup server notification hook: ${e.message}", LogSource.MODULE)
        }
    }

    private fun registerActivityLifecycleCallbacks(application: Application) {
        application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacks {
            override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
                when {
                    activity.javaClass.name == ageVerificationActivity -> {
                        showAgeVerificationComplianceDialog(activity)
                    }
                    shouldShowBridgeConnectionError -> {
                        showBridgeConnectionError(activity)
                        shouldShowBridgeConnectionError = false
                    }
                    shouldShowVersionMismatchDialog -> {
                        showVersionMismatchDialog(activity)
                        shouldShowVersionMismatchDialog = false
                    }
                }

                if (isImportingSomething) {
                    handleImports(activity)
                }
            }

            override fun onActivityStarted(activity: Activity) {}

            override fun onActivityResumed(activity: Activity) {
                Logger.d("Resuming activity: ${activity.javaClass.name}", LogSource.MODULE)
                currentActivityRef = WeakReference(activity)
            }

            override fun onActivityPaused(activity: Activity) {
                Logger.d("Pausing activity: ${activity.javaClass.name}", LogSource.MODULE)
                if (currentActivity == activity) {
                    currentActivityRef = null
                }
            }

            override fun onActivityStopped(activity: Activity) {}

            override fun onActivitySaveInstanceState(activity: Activity, outState: Bundle) {}

            override fun onActivityDestroyed(activity: Activity) {}
        })
    }

    private fun setupInstanceManager() {
        if (isInstanceManagerInitialized) {
            Logger.d("InstanceManager already initialized, skipping", LogSource.MODULE)
            return
        }

        instanceManager.hookClassConstructors(
            userAgent,
            userSession,
            deviceInfo,
            grindrLocationProvider,
            serverDrivenCascadeRepo
        )

        instanceManager.setCallback(userSession) { uSession ->
            instanceManager.setCallback(userAgent) { uAgent ->
                instanceManager.setCallback(deviceInfo) { dInfo ->
                    httpClient = Client(Interceptor(uSession, uAgent, dInfo))
                    executeAsync {
                        kotlinx.coroutines.delay(1500)
                        fetchOwnUserId()
                    }
                    taskManager.registerTasks()
                }
            }
        }

        isInstanceManagerInitialized = true
    }

    private fun initializeCore() {
        if (isMainInitialized) {
            Logger.d("Core already initialized, skipping", LogSource.MODULE)
            return
        }

        Logger.i("Initializing GrindrPlus core...", LogSource.MODULE)

        if ((Config.get("reset_database", false) as Boolean)) {
            Logger.i("Resetting database...", LogSource.MODULE)
            database.clearAllTables()
            Config.put("reset_database", false)
        }

        hookManager.init()
        isMainInitialized = true
    }

    fun runOnMainThread(appContext: Context? = null, block: (Context) -> Unit) {
        val useContext = appContext ?: context
        Handler(useContext.mainLooper).post {
            block(useContext)
        }
    }

    fun runOnMainThreadWithCurrentActivity(block: (Activity) -> Unit) {
        runOnMainThread {
            currentActivity?.let { activity ->
                block(activity)
            } ?: Logger.e("Cannot execute action - no active activity", LogSource.MODULE)
        }
    }

    fun executeAsync(block: suspend () -> Unit) {
        ioScope.launch {
            try {
                block()
            } catch (e: Exception) {
                Logger.e("Async operation failed: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }

    fun showToast(duration: Int, message: String, appContext: Context? = null) {
        val useContext = appContext ?: context
        runOnMainThread(useContext) {
            Toast.makeText(useContext, message, duration).show()
        }
    }

    fun loadClass(name: String): Class<*> {
        return classLoader.loadClass(name)
    }

    fun restartGrindr(timeout: Long = 0, toast: String? = null) {
        toast?.let { showToast(Toast.LENGTH_LONG, it) }

        if (timeout > 0) {
            Handler(Looper.getMainLooper()).postDelayed({
                val intent = context.packageManager
                    .getLaunchIntentForPackage(context.packageName)?.apply {
                        addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    }
                context.startActivity(intent)
                android.os.Process.killProcess(android.os.Process.myPid())
            }, timeout)
        } else {
            val intent = context.packageManager
                .getLaunchIntentForPackage(context.packageName)?.apply {
                    addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                }
            context.startActivity(intent)
            android.os.Process.killProcess(android.os.Process.myPid())
        }
    }

    private fun checkVersionCodes(versionCodes: IntArray, versionNames: Array<String>) {
        val pkgInfo = context.packageManager.getPackageInfo(context.packageName, 0)
        val versionCode: Long = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            pkgInfo.longVersionCode
        } else {
            @Suppress("DEPRECATION")
            pkgInfo.versionCode.toLong()
        }

        val isVersionNameSupported = pkgInfo.versionName in versionNames
        val isVersionCodeSupported = versionCodes.any { it.toLong() == versionCode }

        if (!isVersionNameSupported || !isVersionCodeSupported) {
            val installedInfo = "${pkgInfo.versionName} (code: $versionCode)"
            val expectedInfo = "${versionNames.joinToString(", ")} " +
                    "(code: ${BuildConfig.TARGET_GRINDR_VERSION_CODES.joinToString(", ")})"
            shouldShowVersionMismatchDialog = true
            Logger.w("Version mismatch detected. Installed: $installedInfo, Required: $expectedInfo", LogSource.MODULE)
        }

        hasCheckedVersions = true
    }

    private fun showVersionMismatchDialog(activity: Activity) {
        try {
            val pkgInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            val versionCode: Long = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                pkgInfo.longVersionCode
            } else {
                @Suppress("DEPRECATION")
                pkgInfo.versionCode.toLong()
            }

            val installedInfo = "${pkgInfo.versionName} (code: $versionCode)"
            val expectedInfo = "${BuildConfig.TARGET_GRINDR_VERSION_NAMES.joinToString(", ")} " +
                    "(code: ${BuildConfig.TARGET_GRINDR_VERSION_CODES.joinToString(", ")})"

            val dialog = android.app.AlertDialog.Builder(activity)
                .setTitle("GrindrPlus: Version Mismatch")
                .setMessage("Incompatible Grindr version detected.\n\n" +
                        "• Installed: $installedInfo\n" +
                        "• Required: $expectedInfo\n\n" +
                        "GrindrPlus has been disabled. Please install a compatible Grindr version.")
                .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setCancelable(false)
                .create()
            dialog.show()
            Logger.i("Version mismatch dialog shown", LogSource.MODULE)
        } catch (e: Exception) {
            Logger.e("Failed to show version mismatch dialog: ${e.message}", LogSource.MODULE)
            showToast(Toast.LENGTH_LONG, "Version mismatch detected. Please install a compatible Grindr version.")
        }
    }

    private fun showBridgeConnectionError(activity: Activity? = null) {
        try {
            val targetActivity = activity ?: currentActivity

            if (targetActivity != null) {
                val dialog = android.app.AlertDialog.Builder(targetActivity)
                    .setTitle("Bridge Connection Failed")
                    .setMessage("Failed to connect to the bridge service. The module will not work properly.\n\n" +
                            "This may be caused by:\n" +
                            "• Battery optimization settings\n" +
                            "• System killing background processes\n" +
                            "• App being force stopped\n\n" +
                            "Try restarting the app or reinstalling the module.")
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .setIcon(android.R.drawable.ic_dialog_alert)
                    .setCancelable(false)
                    .create()

                targetActivity.runOnUiThread {
                    dialog.show()
                }

                Logger.i("Bridge connection error dialog shown", LogSource.MODULE)
            } else {
                showToast(Toast.LENGTH_LONG, "Bridge service connection failed - module features unavailable")
            }
        } catch (e: Exception) {
            Logger.e("Failed to show bridge error dialog: ${e.message}", LogSource.MODULE)
            showToast(Toast.LENGTH_LONG, "Bridge service connection failed - module features unavailable")
        }
    }

    private fun showAgeVerificationComplianceDialog(activity: Activity) {
        try {
            val dialog = android.app.AlertDialog.Builder(activity)
                .setTitle("Age Verification Required")
                .setMessage("You are accessing Grindr from the UK where age verification is legally mandated.\n\n" +
                        "LEGAL COMPLIANCE NOTICE:\n" +
                        "GrindrPlus does NOT bypass, disable, or interfere with age verification systems. Any attempt to circumvent age verification requirements is illegal under UK law and is strictly prohibited.\n\n" +
                        "MANDATORY REQUIREMENTS:\n" +
                        "1. Complete age verification using the official Grindr application\n" +
                        "2. Comply with all UK legal verification processes\n" +
                        "3. Install GrindrPlus only after successful verification through official channels\n\n" +
                        "WARNING:\n" +
                        "Continued use of this module without proper age verification may result in legal consequences. The developers assume no responsibility for violations of age verification laws.\n\n" +
                        "This module operates in full compliance with legal requirements and does not provide any means to bypass verification systems.")
                .setPositiveButton("I Understand") { dialog, _ ->
                    activity.finish()
                    dialog.dismiss()
                    showToast(Toast.LENGTH_LONG,
                        "Please complete age verification in the official Grindr app first, then reinstall GrindrPlus")
                }
                .setNegativeButton("Exit App") { dialog, _ ->
                    dialog.dismiss()
                    android.os.Process.killProcess(android.os.Process.myPid())
                }
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setCancelable(false)
                .create()

            dialog.show()
            Logger.i("Age verification compliance dialog shown", LogSource.MODULE)

        } catch (e: Exception) {
            Logger.e("Failed to show age verification dialog: ${e.message}", LogSource.MODULE)
            showToast(Toast.LENGTH_LONG,
                "Age verification required. Please use official Grindr app to verify, then reinstall GrindrPlus.")
            activity.finish()
        }
    }

    private fun fetchRemoteData(url: String, callback: (List<Pair<Long, Int>>) -> Unit) {
        val client = OkHttpClient()
        val request = Request.Builder().url(url).build()

        client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                Logger.e("Failed to fetch remote data: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }

            override fun onResponse(call: Call, response: Response) {
                response.body?.string()?.let { jsonString ->
                    try {
                        val jsonArray = JSONArray(jsonString)
                        val parsedPoints = mutableListOf<Pair<Long, Int>>()

                        for (i in 0 until jsonArray.length()) {
                            val obj = jsonArray.getJSONObject(i)
                            val time = obj.getLong("time")
                            val id = obj.getInt("id")
                            parsedPoints.add(time to id)
                        }

                        callback(parsedPoints)
                    } catch (e: Exception) {
                        Logger.e("Failed to parse remote data: ${e.message}", LogSource.MODULE)
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }
            }
        })
    }

    private fun fetchOwnUserId() {
        executeAsync {
            try {
                Logger.d("Fetching own user ID...", LogSource.MODULE)
                val response = httpClient.sendRequest(
                    url = "https://grindr.mobi/v5/me/profile",
                    method = "GET"
                )

                if (response.isSuccessful) {
                    val responseBody = response.body?.string()
                    if (!responseBody.isNullOrEmpty()) {
                        val jsonResponse = JSONObject(responseBody)
                        val profilesArray = jsonResponse.optJSONArray("profiles")

                        if (profilesArray != null && profilesArray.length() > 0) {
                            val profile = profilesArray.getJSONObject(0)
                            val profileId = profile.optString("profileId")

                            if (profileId.isNotEmpty()) {
                                myProfileId = profileId
                                Logger.i("Own user ID fetched and saved: $myProfileId", LogSource.MODULE)
                            } else {
                                Logger.w("Profile ID field is empty in response", LogSource.MODULE)
                            }
                        } else {
                            Logger.w("No profiles array found in response", LogSource.MODULE)
                        }
                    } else {
                        Logger.w("Empty response body from profile endpoint", LogSource.MODULE)
                    }
                } else {
                    Logger.e("Failed to fetch own profile: HTTP ${response.code}", LogSource.MODULE)
                }
            } catch (e: Exception) {
                Logger.e("Error fetching own user ID: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\XposedLoader.kt --- 
package com.grindrplus

import android.app.Application
import com.grindrplus.core.Constants.GRINDR_PACKAGE_NAME
import com.grindrplus.hooks.spoofSignatures
import com.grindrplus.hooks.sslUnpinning
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.IXposedHookLoadPackage
import de.robv.android.xposed.IXposedHookZygoteInit
import de.robv.android.xposed.callbacks.XC_LoadPackage

class XposedLoader : IXposedHookZygoteInit, IXposedHookLoadPackage {
    private lateinit var modulePath: String

    override fun initZygote(startupParam: IXposedHookZygoteInit.StartupParam) {
        modulePath = startupParam.modulePath
    }

    override fun handleLoadPackage(lpparam: XC_LoadPackage.LoadPackageParam) {
        if (!lpparam.packageName.contains(GRINDR_PACKAGE_NAME)) return

        spoofSignatures(lpparam)
        //if (BuildConfig.DEBUG) {
            sslUnpinning(lpparam)
        //}

        Application::class.java.hook("attach", HookStage.AFTER) {
            val application = it.thisObject()
            GrindrPlus.init(modulePath, application,
                BuildConfig.TARGET_GRINDR_VERSION_CODES,
                BuildConfig.TARGET_GRINDR_VERSION_NAMES)
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\bridge\BridgeClient.kt --- 
package com.grindrplus.bridge

import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.os.Build
import android.os.Handler
import android.os.HandlerThread
import android.os.IBinder
import android.os.Looper
import com.grindrplus.BuildConfig
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import org.json.JSONArray
import org.json.JSONObject
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.coroutines.resume

class BridgeClient(private val context: Context) {
    private var bridgeService: IBridgeService? = null
    private val isConnecting = AtomicBoolean(false)
    private val isBound = AtomicBoolean(false)
    private val coroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private val mainHandler = Handler(Looper.getMainLooper())
    private val serviceWatchdog = Handler(Looper.getMainLooper())
    private var lastConnectionAttempt = 0L
    private var connectionDeferreds = mutableMapOf<String, CompletableDeferred<Boolean>>()
    private val bindingExecutor = Executors.newSingleThreadExecutor()

    companion object {
        const val CONNECTION_TIMEOUT_MS = 5000L
        private const val WATCHDOG_CHECK_INTERVAL_MS = 30000L
        private const val RECONNECT_DELAY_MS = 2000L
    }

    init {
        Logger.initialize(context, this, false)
    }

    private val connection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
            bridgeService = IBridgeService.Stub.asInterface(binder)
            isBound.set(true)
            isConnecting.set(false)

            connectionDeferreds.forEach { (_, deferred) ->
                if (!deferred.isCompleted) deferred.complete(true)
            }
            connectionDeferreds.clear()

            Logger.i("Connected to bridge service", LogSource.BRIDGE)
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            bridgeService = null
            isBound.set(false)
            Logger.i("Disconnected from bridge service", LogSource.BRIDGE)

            if (!isConnecting.get()) {
                mainHandler.postDelayed({
                    if (!isBound.get() && !isConnecting.get()) {
                        Logger.d("Auto-reconnecting after service disconnection", LogSource.BRIDGE)
                        coroutineScope.launch {
                            connect()
                        }
                    }
                }, RECONNECT_DELAY_MS)
            }
        }
    }

    private val watchdogRunnable = object : Runnable {
        override fun run() {
            if (!isBound.get() && !isConnecting.get()) {
                val now = System.currentTimeMillis()
                if (now - lastConnectionAttempt > 5000) {
                    Logger.w("Service watchdog detected disconnection, reconnecting...", LogSource.BRIDGE)
                    coroutineScope.launch {
                        connectWithRetry()
                    }
                }
            }
            serviceWatchdog.postDelayed(this, WATCHDOG_CHECK_INTERVAL_MS)
        }
    }

    fun startWatchdog() {
        serviceWatchdog.removeCallbacks(watchdogRunnable)
        serviceWatchdog.postDelayed(watchdogRunnable, WATCHDOG_CHECK_INTERVAL_MS)
        Logger.d("Started service watchdog", LogSource.BRIDGE)
    }

    fun stopWatchdog() {
        serviceWatchdog.removeCallbacks(watchdogRunnable)
        Logger.d("Stopped service watchdog", LogSource.BRIDGE)
    }

    fun isConnected(): Boolean {
        return isBound.get()
    }

    fun getService(): IBridgeService? = bridgeService

    suspend fun connectWithRetry(maxRetries: Int = 3, retryDelay: Long = 1000): Boolean {
        var attempts = 0
        var connected = false

        while (!connected && attempts < maxRetries) {
            attempts++
            Logger.d("Connection attempt $attempts/$maxRetries", LogSource.BRIDGE)

            connected = connect()

            if (connected) {
                Logger.i("Successfully connected on attempt $attempts", LogSource.BRIDGE)
                return true
            }

            if (attempts < maxRetries) {
                delay(retryDelay)
            }
        }

        if (!connected) {
            Logger.w("Failed to connect after $maxRetries attempts", LogSource.BRIDGE)
        }

        return connected
    }

    fun connectAsync(onConnected: ((Boolean) -> Unit)? = null) {
        coroutineScope.launch {
            val result = connect()
            withContext(Dispatchers.Main) {
                onConnected?.invoke(result)
            }
        }
    }

    suspend fun connect(): Boolean {
        if (isBound.get()) {
            return true
        }

        if (isConnecting.getAndSet(true)) {
            Logger.d("Connection already in progress, waiting...", LogSource.BRIDGE)
            val connectionKey = "connect-${System.currentTimeMillis()}"
            val deferred = CompletableDeferred<Boolean>()
            connectionDeferreds[connectionKey] = deferred

            try {
                return withTimeout(CONNECTION_TIMEOUT_MS) {
                    deferred.await()
                }
            } catch (e: Exception) {
                Logger.w("Timeout waiting for existing connection", LogSource.BRIDGE)
                connectionDeferreds.remove(connectionKey)
                return false
            }
        }

        lastConnectionAttempt = System.currentTimeMillis()

        try {
            startService()
        } catch (e: Exception) {
            Logger.e("Failed to start service: ${e.message}", LogSource.BRIDGE)
            isConnecting.set(false)
            return false
        }

        val intent = Intent().apply {
            setClassName(
                BuildConfig.APPLICATION_ID,
                BridgeService::class.java.name
            )
        }

        return suspendCancellableCoroutine { continuation ->
            val bindResult = try {
                bindServiceSafely(intent)
            } catch (e: Exception) {
                Logger.e("Error binding service: ${e.message}", LogSource.BRIDGE)
                isConnecting.set(false)
                continuation.resume(false)
                return@suspendCancellableCoroutine
            }

            if (!bindResult) {
                Logger.w("bindService returned false", LogSource.BRIDGE)
                isConnecting.set(false)
                continuation.resume(false)
                return@suspendCancellableCoroutine
            }

            val timeoutHandler = Handler(Looper.getMainLooper())
            val timeoutOccurred = AtomicBoolean(false)

            val timeoutRunnable = Runnable {
                if (continuation.isActive && !timeoutOccurred.getAndSet(true)) {
                    Logger.w("Connection timeout", LogSource.BRIDGE)
                    try {
                        context.unbindService(connection)
                    } catch (e: Exception) {
                        Logger.e("Error unbinding service after timeout: ${e.message}", LogSource.BRIDGE)
                    }
                    isConnecting.set(false)
                    continuation.resume(false)
                }
            }

            timeoutHandler.postDelayed(timeoutRunnable, CONNECTION_TIMEOUT_MS)

            continuation.invokeOnCancellation {
                timeoutHandler.removeCallbacks(timeoutRunnable)
                try {
                    context.unbindService(connection)
                } catch (e: Exception) {
                    Logger.e("Error unbinding service on cancellation: ${e.message}", LogSource.BRIDGE)
                }
                isConnecting.set(false)
            }

            val connectionKey = "connect-${continuation.hashCode()}"
            val deferred = CompletableDeferred<Boolean>()
            connectionDeferreds[connectionKey] = deferred

            coroutineScope.launch {
                val result = try {
                    withTimeout(CONNECTION_TIMEOUT_MS) {
                        deferred.await()
                    }
                } catch (_: Exception) {
                    false
                }

                connectionDeferreds.remove(connectionKey)
                timeoutHandler.removeCallbacks(timeoutRunnable)

                if (continuation.isActive && !timeoutOccurred.get()) {
                    continuation.resume(result)
                }
            }
        }
    }

    fun connectBlocking(timeoutMs: Long = CONNECTION_TIMEOUT_MS): Boolean {
        if (isBound.get()) {
            return true
        }

        Logger.d("Attempting to connect to bridge service (blocking)", LogSource.BRIDGE)

        val result = runBlocking {
            try {
                withTimeout(timeoutMs) {
                    connect()
                }
            } catch (e: Exception) {
                Logger.w("Connection timeout in blocking mode", LogSource.BRIDGE)
                false
            }
        }

        return result
    }

    private fun bindServiceSafely(intent: Intent): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            context.bindService(
                intent,
                Context.BIND_AUTO_CREATE,
                bindingExecutor,
                connection
            )
        } else {
            try {
                val handlerThread = HandlerThread("BridgeClientThread")
                handlerThread.start()
                val handler = Handler(handlerThread.looper)

                val bindResult = try {
                    val userHandle = Process::class.java.getMethod("myUserHandle").invoke(null)
                    context.javaClass.getMethod(
                        "bindServiceAsUser",
                        Intent::class.java,
                        ServiceConnection::class.java,
                        Int::class.javaPrimitiveType,
                        Handler::class.java,
                        userHandle.javaClass
                    ).invoke(
                        context,
                        intent,
                        connection,
                        Context.BIND_AUTO_CREATE,
                        handler,
                        userHandle
                    ) as Boolean
                } catch (e: Exception) {
                    Logger.w("bindServiceAsUser failed, falling back to bindService: ${e.message}", LogSource.BRIDGE)
                    context.bindService(intent, connection, Context.BIND_AUTO_CREATE)
                }

                bindResult
            } catch (e: Exception) {
                Logger.e("Failed to bind service with any method: ${e.message}", LogSource.BRIDGE)
                context.bindService(intent, connection, Context.BIND_AUTO_CREATE)
            }
        }
    }

    private fun startService() {
        try {
            val serviceIntent = Intent().apply {
                setClassName(
                    BuildConfig.APPLICATION_ID,
                    "${BuildConfig.APPLICATION_ID}.bridge.BridgeService"
                )
            }

            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    context.startForegroundService(serviceIntent)
                    Logger.d("Service start attempt via startForegroundService", LogSource.BRIDGE)
                } else {
                    context.startService(serviceIntent)
                    Logger.d("Service start attempt via startService", LogSource.BRIDGE)
                }
                Thread.sleep(100)
            } catch (e: Exception) {
                Logger.w("Failed to start service directly: ${e.message}", LogSource.BRIDGE)

                try {
                    val forceStartIntent = ForceStartActivity.createIntent(context)
                    context.startActivity(forceStartIntent)
                    Logger.d("Service start attempt via ForceStartActivity (fallback)", LogSource.BRIDGE)
                    Thread.sleep(50)
                } catch (e2: Exception) {
                    Logger.e("All service start methods failed: ${e2.message}", LogSource.BRIDGE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Failed to start service: ${e.message}", LogSource.BRIDGE)
        }
    }

    fun unbind() {
        if (isBound.getAndSet(false)) {
            try {
                context.unbindService(connection)
                bridgeService = null
            } catch (e: Exception) {
                Logger.e("Error unbinding service: ${e.message}", LogSource.BRIDGE)
            }
        }
    }

    fun getConfig(): JSONObject {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for getConfig", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot get config, service not bound", LogSource.BRIDGE)
                return JSONObject()
            }
        }

        return try {
            bridgeService?.config?.let { JSONObject(it) } ?: JSONObject()
        } catch (e: Exception) {
            Logger.e("Error getting config: ${e.message}", LogSource.BRIDGE)
            JSONObject()
        }
    }

    fun setConfig(config: JSONObject) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for setConfig", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot set config, service not bound", LogSource.BRIDGE)
                return
            }
        }

        try {
            bridgeService?.setConfig(config.toString(4))
        } catch (e: Exception) {
            Logger.e("Error setting config: ${e.message}", LogSource.BRIDGE)
        }
    }

    fun logBlockEvent(profileId: String, displayName: String, isBlock: Boolean, packageName: String) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for logBlockEvent", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot log block event, service not bound", LogSource.BRIDGE)
                return
            }
        }

        try {
            bridgeService?.logBlockEvent(profileId, displayName, isBlock, packageName)
        } catch (e: Exception) {
            Logger.e("Error logging block event: ${e.message}", LogSource.BRIDGE)
        }
    }

    fun getBlockEvents(): JSONArray {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for getBlockEvents", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot get block events, service not bound", LogSource.BRIDGE)
                return JSONArray()
            }
        }

        return try {
            bridgeService?.blockEvents?.let { JSONArray(it) } ?: JSONArray()
        } catch (e: Exception) {
            Logger.e("Error getting block events: ${e.message}", LogSource.BRIDGE)
            JSONArray()
        }
    }

    fun clearBlockEvents() {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for clearBlockEvents", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot clear block events, service not bound", LogSource.BRIDGE)
                return
            }
        }

        try {
            bridgeService?.clearBlockEvents()
        } catch (e: Exception) {
            Logger.e("Error clearing block events: ${e.message}", LogSource.BRIDGE)
        }
    }

    fun sendNotification(
        title: String,
        message: String,
        notificationId: Int,
        channelId: String = "default_channel_id",
        channelName: String = "Default Channel",
        channelDescription: String = "Default notifications"
    ) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for sendNotification", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot send notification, service not bound", LogSource.BRIDGE)
                return
            }
        }

        try {
            bridgeService?.sendNotification(
                title,
                message,
                notificationId,
                channelId,
                channelName,
                channelDescription
            )
        } catch (e: Exception) {
            Logger.e("Error sending notification: ${e.message}", LogSource.BRIDGE)
        }
    }

    fun sendNotificationWithMultipleActions(
        title: String,
        message: String,
        notificationId: Int,
        actionLabels: List<String>,
        actionTypes: List<String>,
        actionData: List<String>,
        channelId: String = "default_channel_id",
        channelName: String = "Default Channel",
        channelDescription: String = "Default notifications"
    ) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for sendNotificationWithActions", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot send notification, service not bound", LogSource.BRIDGE)
                return
            }
        }

        try {
            bridgeService?.sendNotificationWithActions(
                title,
                message,
                notificationId,
                channelId,
                channelName,
                channelDescription,
                actionLabels.toTypedArray(),
                actionTypes.toTypedArray(),
                actionData.toTypedArray()
            )
        } catch (e: Exception) {
            Logger.e("Error sending notification with multiple actions: ${e.message}", LogSource.BRIDGE)
        }
    }

    fun shouldRegenAndroidId(packageName: String): Boolean {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d(
                    "Connected to service on-demand for shouldRegenAndroidId",
                    LogSource.BRIDGE
                )
            } else {
                Logger.w(
                    "Cannot check Android ID regeneration, service not bound",
                    LogSource.BRIDGE
                )
                return false
            }
        }

        return try {
            bridgeService?.shouldRegenAndroidId(packageName) ?: false
        } catch (e: Exception) {
            Logger.e("Error checking Android ID regeneration: ${e.message}", LogSource.BRIDGE)
            false
        }
    }

    fun getForcedLocation(packageName: String): String {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for getForcedLocation", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot get forced location, service not bound", LogSource.BRIDGE)
                return ""
            }
        }

        return try {
            bridgeService?.getForcedLocation(packageName) ?: ""
        } catch (e: Exception) {
            Logger.e("Error getting forced location: ${e.message}", LogSource.BRIDGE)
            ""
        }
    }

    fun deleteForcedLocation(packageName: String) {
        if (!isBound.get()) {
            if (connectBlocking(3000)) {
                Logger.d("Connected to service on-demand for deleteForcedLocation", LogSource.BRIDGE)
            } else {
                Logger.w("Cannot delete forced location, service not bound", LogSource.BRIDGE)
                return
            }
        }

        try {
            bridgeService?.deleteForcedLocation(packageName)
        } catch (e: Exception) {
            Logger.e("Error deleting forced location: ${e.message}", LogSource.BRIDGE)
        }
    }
}

private fun <T> runBlocking(block: suspend () -> T): T {
    return java.util.concurrent.CompletableFuture<T>().let { future ->
        CoroutineScope(Dispatchers.IO).launch {
            try {
                future.complete(block())
            } catch (e: Exception) {
                future.completeExceptionally(e)
            }
        }
        try {
            future.get(BridgeClient.CONNECTION_TIMEOUT_MS + 1000, TimeUnit.MILLISECONDS)
        } catch (e: Exception) {
            throw e.cause ?: e
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\bridge\BridgeService.kt --- 
package com.grindrplus.bridge

import android.annotation.SuppressLint
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.content.pm.ServiceInfo
import android.os.Build
import android.os.IBinder
import android.os.Process
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.app.ServiceCompat
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import org.json.JSONArray
import org.json.JSONObject
import timber.log.Timber
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.concurrent.Executors
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

@SuppressLint("MissingPermission")
class BridgeService : Service() {
    private val configFile by lazy { File(getExternalFilesDir(null), "grindrplus.json") }
    private val logFile by lazy { File(getExternalFilesDir(null), "grindrplus.log") }
    private val blockEventsFile by lazy { File(getExternalFilesDir(null), "block_events.json") }
    private val blockEventsLock = ReentrantLock()
    private val ioExecutor = Executors.newSingleThreadExecutor()
    private val logLock = ReentrantLock()
    private val MAX_LOG_SIZE = 5 * 1024 * 1024
    private val periodicTasksExecutor = Executors.newSingleThreadScheduledExecutor()

    private var isForegroundStarted = false

    override fun onCreate() {
        super.onCreate()
        Logger.i("BridgeService created", LogSource.BRIDGE)

        Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND)
        initializeFiles()
    }

    override fun onBind(intent: Intent?): IBinder {
        Logger.i("BridgeService bound", LogSource.BRIDGE)
        startForegroundSafely()
        return binder
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Logger.i("BridgeService started", LogSource.BRIDGE)

        startForegroundSafely()

        return START_STICKY
    }

    private fun startForegroundSafely() {
        if (isForegroundStarted) {
            return
        }

        try {
            val channelId = "bridge_service_channel"
            createNotificationChannel(channelId, "GrindrPlus Background Service", "Keeps GrindrPlus running in background")

            val notification = NotificationCompat.Builder(this, channelId)
                .setContentTitle("GrindrPlus")
                .setContentText("Background service active")
                .setSmallIcon(android.R.drawable.ic_dialog_info)
                .setPriority(NotificationCompat.PRIORITY_MIN)
                .setVisibility(NotificationCompat.VISIBILITY_SECRET)
                .setOngoing(true)
                .setShowWhen(false)
                .build()

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                ServiceCompat.startForeground(
                    this,
                    1001,
                    notification,
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE
                    } else {
                        0
                    }
                )
            } else {
                startForeground(1001, notification)
            }

            isForegroundStarted = true
            Logger.i("Foreground service started successfully", LogSource.BRIDGE)

        } catch (e: Exception) {
            Logger.w("Failed to start foreground service: ${e.message}", LogSource.BRIDGE)
            Logger.writeRaw(e.stackTraceToString())

            // If we can't start as foreground, continue as normal service
            // The service will still work, just won't be protected from being killed
            isForegroundStarted = false
        }
    }

    private fun initializeFiles() {
        ioExecutor.execute {
            try {
                if (!configFile.exists()) {
                    configFile.createNewFile()
                    configFile.writeText("{}")
                }

                if (!logFile.exists()) {
                    logFile.createNewFile()
                }

                if (!blockEventsFile.exists()) {
                    blockEventsFile.createNewFile()
                    blockEventsFile.writeText("[]")
                }
            } catch (e: Exception) {
                Logger.e("Failed to initialize files: ${e.message}", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }

    private val binder = object : IBridgeService.Stub() {
        override fun getConfig(): String {
            Logger.d("getConfig() called")
            return try {
                if (!configFile.exists()) {
                    configFile.createNewFile()
                    "{}"
                } else {
                    configFile.readText().ifBlank { "{}" }
                }
            } catch (e: Exception) {
                Logger.e("Error reading config file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
                "{}"
            }
        }

        override fun setConfig(config: String?) {
            Logger.d("setConfig() called")
            try {
                if (!configFile.exists()) {
                    configFile.createNewFile()
                }

                configFile.writeText(config ?: "{}")
            } catch (e: Exception) {
                Logger.e("Error writing to config file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        override fun log(level: String, source: String, message: String, hookName: String?) {
            ioExecutor.execute {
                try {
                    checkAndManageLogSize()
                    val formattedLog = formatLogEntry(level, source, message, hookName)
                    appendToLog(formattedLog)
                } catch (e: Exception) {
                    Logger.e("Error writing log entry", LogSource.BRIDGE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }

        override fun writeRawLog(content: String) {
            ioExecutor.execute {
                try {
                    checkAndManageLogSize()
                    appendToLog(content + (if (!content.endsWith("\n")) "\n" else ""))
                } catch (e: Exception) {
                    Logger.e("Error writing raw log entry", LogSource.BRIDGE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }

        override fun clearLogs() {
            Logger.d("clearLogs() called")
            try {
                logLock.withLock {
                    if (logFile.exists()) {
                        logFile.delete()
                        logFile.createNewFile()
                    }
                }
            } catch (e: Exception) {
                Logger.e("Error clearing log file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        override fun sendNotification(
            title: String,
            message: String,
            notificationId: Int,
            channelId: String,
            channelName: String,
            channelDescription: String
        ) {
            Logger.d("sendNotification() called")
            try {
                createNotificationChannel(channelId, channelName, channelDescription)

                val notificationBuilder = NotificationCompat.Builder(applicationContext, channelId)
                    .setSmallIcon(android.R.drawable.ic_dialog_info)
                    .setContentTitle(title)
                    .setContentText(message)
                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                    .setAutoCancel(true)

                with(NotificationManagerCompat.from(applicationContext)) {
                    notify(notificationId, notificationBuilder.build())
                }
            } catch (e: Exception) {
                Logger.e("Error sending notification", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        override fun sendNotificationWithActions(
            title: String,
            message: String,
            notificationId: Int,
            channelId: String,
            channelName: String,
            channelDescription: String,
            actionLabels: Array<String>,
            actionIntents: Array<String>,
            actionData: Array<String>
        ) {
            Logger.d("sendNotificationWithActions() called")
            try {
                createNotificationChannel(channelId, channelName, channelDescription)

                val notificationBuilder = NotificationCompat.Builder(applicationContext, channelId)
                    .setSmallIcon(android.R.drawable.ic_dialog_info)
                    .setContentTitle(title)
                    .setContentText(message)
                    .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                    .setAutoCancel(true)

                for (i in actionLabels.indices) {
                    if (i >= actionIntents.size || i >= actionData.size) break

                    val intent = createActionIntent(actionIntents[i], actionData[i])
                    val pendingIntent = PendingIntent.getBroadcast(
                        applicationContext,
                        notificationId + i,
                        intent,
                        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                    )

                    notificationBuilder.addAction(
                        android.R.drawable.ic_menu_send,
                        actionLabels[i],
                        pendingIntent
                    )
                }

                with(NotificationManagerCompat.from(applicationContext)) {
                    notify(notificationId, notificationBuilder.build())
                }
            } catch (e: Exception) {
                Logger.e("Error sending notification with actions", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        override fun logBlockEvent(
            profileId: String,
            displayName: String,
            isBlock: Boolean,
            packageName: String
        ) {
            ioExecutor.execute {
                try {
                    blockEventsLock.withLock {
                        if (!blockEventsFile.exists()) {
                            blockEventsFile.createNewFile()
                            blockEventsFile.writeText("[]")
                        }

                        val eventsArray = JSONArray(blockEventsFile.readText().ifBlank { "[]" })
                        val event = JSONObject().apply {
                            put("profileId", profileId)
                            put("displayName", displayName)
                            put("eventType", if (isBlock) "block" else "unblock")
                            put("timestamp", System.currentTimeMillis())
                            put("packageName", packageName)
                        }
                        eventsArray.put(event)
                        blockEventsFile.writeText(eventsArray.toString(4))
                        Logger.d(
                            "Logged ${if (isBlock) "block" else "unblock"} event " +
                                    "for profile ${profileId.take(profileId.length - 4) + "****"}",
                            LogSource.BRIDGE
                        )
                    }
                } catch (e: Exception) {
                    Timber.tag(TAG).e(e, "Error logging block event")
                }
            }
        }

        override fun getBlockEvents(): String {
            return try {
                if (!blockEventsFile.exists()) {
                    blockEventsFile.createNewFile()
                    "[]"
                } else {
                    blockEventsFile.readText().ifBlank { "[]" }
                }
            } catch (e: Exception) {
                Logger.e("Error reading block events file", LogSource.BRIDGE)
                Logger.writeRaw(e.stackTraceToString())
                "[]"
            }
        }

        override fun clearBlockEvents() {
            blockEventsLock.withLock {
                try {
                    if (blockEventsFile.exists()) {
                        blockEventsFile.delete()
                        blockEventsFile.createNewFile()
                        blockEventsFile.writeText("[]")
                    }
                } catch (e: Exception) {
                    Logger.e("Error clearing block events file", LogSource.BRIDGE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }

        override fun shouldRegenAndroidId(packageName: String): Boolean {
            val regenFile = File(getExternalFilesDir(null), "$packageName.android_id_regen")
            return regenFile.exists().also { exists ->
                if (exists) {
                    regenFile.delete()
                }
            }
        }

        override fun getForcedLocation(packageName: String): String {
            val coordinatesFile = File(getExternalFilesDir(null), "$packageName.location")
            return if (coordinatesFile.exists()) {
                coordinatesFile.readText().trim().ifBlank { "" }
            } else {
                ""
            }
        }

        override fun deleteForcedLocation(packageName: String) {
            val coordinatesFile = File(getExternalFilesDir(null), "$packageName.location")
            if (coordinatesFile.exists()) {
                coordinatesFile.delete()
            }
        }
    }

    private fun createNotificationChannel(
        channelId: String,
        channelName: String,
        channelDescription: String
    ) {
        val notificationManager: NotificationManager =
            applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        if (notificationManager.getNotificationChannel(channelId) == null) {
            val importance = if (channelId == "bridge_service_channel") {
                NotificationManager.IMPORTANCE_MIN
            } else {
                NotificationManager.IMPORTANCE_DEFAULT
            }

            val channel = NotificationChannel(channelId, channelName, importance).apply {
                description = channelDescription
                if (channelId == "bridge_service_channel") {
                    setShowBadge(false)
                    setSound(null, null)
                    enableLights(false)
                    enableVibration(false)
                }
            }
            notificationManager.createNotificationChannel(channel)
            Logger.d("Notification channel created: $channelId", LogSource.BRIDGE)
        }
    }

    private fun createActionIntent(actionType: String, actionData: String): Intent {
        val intent = when (actionType) {
            "COPY" -> Intent("com.grindrplus.COPY_ACTION").apply {
                putExtra("data", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }

            "VIEW_PROFILE" -> Intent("com.grindrplus.VIEW_PROFILE_ACTION").apply {
                putExtra("profileId", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }

            "CUSTOM" -> Intent("com.grindrplus.CUSTOM_ACTION").apply {
                putExtra("data", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }

            else -> Intent("com.grindrplus.DEFAULT_ACTION").apply {
                putExtra("data", actionData)
                setPackage(applicationContext.packageName)
                setClassName(
                    applicationContext.packageName,
                    "${applicationContext.packageName}.bridge.NotificationActionReceiver"
                )
            }
        }

        Logger.d("Action intent created: $actionType with data: $actionData", LogSource.BRIDGE)
        return intent
    }

    private fun formatLogEntry(
        level: String,
        source: String,
        message: String,
        hookName: String?
    ): String {
        val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", Locale.getDefault())
            .format(Date())

        return if (hookName != null) {
            "[$timestamp][$source][$level][$hookName] $message\n"
        } else {
            "[$timestamp][$source][$level] $message\n"
        }
    }

    private fun checkAndManageLogSize() {
        logLock.withLock {
            if (logFile.exists() && logFile.length() > MAX_LOG_SIZE) {
                val backupFile = File("${logFile.absolutePath}.bak")
                backupFile.takeIf { it.exists() }?.delete()

                logFile.renameTo(backupFile)
                logFile.createNewFile()

                val rotationMessage = "I/${
                    SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                        .format(Date())
                }/system: Log file rotated due to size limit\n"
                logFile.appendText(rotationMessage)
            }
        }
    }

    private fun appendToLog(content: String) {
        logLock.withLock {
            if (!logFile.exists()) {
                logFile.createNewFile()
            }
            logFile.appendText(content)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        Logger.i("BridgeService destroyed", LogSource.BRIDGE)
        ioExecutor.shutdown()
        periodicTasksExecutor.shutdown()
    }

    companion object {
        private const val TAG = "BridgeService"
        const val CHANNEL_BLOCKS = "grindr_plus_blocks"
        const val CHANNEL_UNBLOCKS = "grindr_plus_unblocks"
        const val CHANNEL_GENERAL = "grindr_plus_general"
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\bridge\ForceStartActivity.kt --- 
package com.grindrplus.bridge

import android.app.Activity
import android.content.Intent
import android.os.Bundle
import com.grindrplus.BuildConfig
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import timber.log.Timber

/**
 * Activity that force starts the Bridge Service
 * This is used as a lightweight mechanism to ensure the service is running
 * without requiring foreground service notifications
 */
class ForceStartActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Timber.tag(TAG).d("ForceStartActivity created")

        try {
            val serviceIntent = Intent().apply {
                setClassName(
                    BuildConfig.APPLICATION_ID,
                    "${BuildConfig.APPLICATION_ID}.bridge.BridgeService"
                )
            }
            startService(serviceIntent)

            val pkg = intent.getStringExtra("pkg")
            if (pkg != null) {
                val launchIntent = packageManager.getLaunchIntentForPackage(pkg)
                if (launchIntent != null) {
                    launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    startActivity(launchIntent)
                    Timber.tag(TAG).d("Launched package: $pkg")
                }
            }

            Timber.tag(TAG).d("Bridge service started successfully")
        } catch (e: Exception) {
            Timber.tag(TAG).e(e, "Failed to start bridge service")
        }

        finish()
    }

    override fun onDestroy() {
        super.onDestroy()
        Timber.tag(TAG).d("ForceStartActivity destroyed")
    }

    companion object {
        private const val TAG = "ForceStartActivity"

        fun createIntent(context: android.content.Context, packageToLaunch: String? = null): Intent {
            return Intent().apply {
                setClassName(
                    BuildConfig.APPLICATION_ID,
                    "${BuildConfig.APPLICATION_ID}.bridge.ForceStartActivity"
                )
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                if (packageToLaunch != null) {
                    putExtra("pkg", packageToLaunch)
                }
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\bridge\NotificationActionReceiver.kt --- 
package com.grindrplus.bridge

import android.content.BroadcastReceiver
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.os.Handler
import android.os.Looper
import android.widget.Toast
import com.grindrplus.core.Logger
import com.grindrplus.core.LogSource

class NotificationActionReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        Logger.d("Notification action received: ${intent.action}", LogSource.BRIDGE)

        try {
            when (intent.action) {
                "com.grindrplus.COPY_ACTION" -> {
                    val data = intent.getStringExtra("data") ?: return

                    Handler(Looper.getMainLooper()).post {
                        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                        val clip = ClipData.newPlainText("Grindr+ Data", data)
                        clipboard.setPrimaryClip(clip)
                        Toast.makeText(context, "Copied to clipboard: $data", Toast.LENGTH_SHORT).show()
                    }
                }

                "com.grindrplus.VIEW_PROFILE_ACTION" -> {
                    val profileId = intent.getStringExtra("profileId") ?: return
                    val appIntent = Intent().apply {
                        setClassName(
                            context.packageName,
                            "${context.packageName}.manager.MainActivity"
                        )
                        putExtra("action", "VIEW_PROFILE")
                        putExtra("profileId", profileId)
                        flags = Intent.FLAG_ACTIVITY_NEW_TASK
                    }
                    context.startActivity(appIntent)
                }

                "com.grindrplus.CUSTOM_ACTION" -> {
                    val data = intent.getStringExtra("data") ?: return
                    Handler(Looper.getMainLooper()).post {
                        Toast.makeText(context, "Custom action: $data", Toast.LENGTH_SHORT).show()
                    }
                }

                "com.grindrplus.DEFAULT_ACTION" -> {
                    val data = intent.getStringExtra("data") ?: return
                    Handler(Looper.getMainLooper()).post {
                        Toast.makeText(context, "Action performed", Toast.LENGTH_SHORT).show()
                    }
                }
            }
        } catch (e: Exception) {
            Logger.e("Error handling notification action: ${e.message}", LogSource.BRIDGE)
            Logger.writeRaw(e.stackTraceToString())
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\Command.kt --- 
package com.grindrplus.commands

@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Command(val name: String, val aliases: Array<String> = [], val help: String = "") 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\CommandHandler.kt --- 
package com.grindrplus.commands


import android.app.AlertDialog
import com.grindrplus.GrindrPlus
import com.grindrplus.ui.Utils.copyToClipboard

class CommandHandler(
    recipient: String,
    sender: String = ""
) {
    private val commandModules: MutableList<CommandModule> = mutableListOf()

    init {
        commandModules.add(Location(recipient, sender))
        commandModules.add(Profile(recipient, sender))
        commandModules.add(Utils(recipient, sender))
        commandModules.add(Database(recipient, sender))
        commandModules.add(Filtering(recipient, sender))
    }

    fun handle(input: String) {
        val args = input.trim().split("\\s+".toRegex()).filter { it.isNotEmpty() }
        val command = args.firstOrNull() ?: return

        if (command == "help") {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val helpText = commandModules.joinToString("\n\n") { it.getHelp() }
                AlertDialog.Builder(activity)
                    .setTitle("Help")
                    .setMessage(helpText)
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Help", helpText)
                    }
                    .create()
                    .show()
            }
        }

        for (module in commandModules) {
            if (module.handle(command, args.drop(1))) break
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\CommandModule.kt --- 
package com.grindrplus.commands

import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger

abstract class CommandModule(
    protected val name: String,
    protected val recipient: String,
    protected val sender: String
) {
    fun handle(inputCommand: String, args: List<String>): Boolean {
        val commandMethod = this::class.java.methods.firstOrNull {
            val annotation = it.getAnnotation(Command::class.java)
            annotation != null
                    && (annotation.name == inputCommand || inputCommand in annotation.aliases)
        }

        return commandMethod != null && try {
            commandMethod.invoke(this, args)
            true
        } catch (e: Exception) {
            val message = "Unable to execute command. Check logs for more information."
            GrindrPlus.showToast(Toast.LENGTH_LONG, message)
            Logger.apply {
                e("An error occurred while executing the command: ${e.message ?: "Unknown error"}")
                writeRaw(e.stackTraceToString())
            }
            false
        }
    }

    fun getHelp(): String {
        val commands = this::class.java.methods.mapNotNull { method ->
            val command = method.getAnnotation(Command::class.java)
            command?.let {
                if (it.aliases.isEmpty()) {
                    "${it.name}: ${it.help}"
                } else {
                    "${it.name} (${it.aliases.joinToString(", ")}): ${it.help}"
                }
            }
        }

        return "Help for $name:\n${commands.joinToString("\n") { command -> "- $command" }}"
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\Database.kt --- 
package com.grindrplus.commands

import android.app.AlertDialog
import android.graphics.Color
import android.widget.LinearLayout
import android.widget.Toast
import androidx.appcompat.widget.AppCompatTextView
import androidx.room.withTransaction
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.DatabaseHelper
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import com.grindrplus.persistence.GPDatabase
import com.grindrplus.persistence.mappers.asAlbumToAlbumEntity
import com.grindrplus.persistence.mappers.toAlbumContentEntities
import com.grindrplus.ui.Utils.copyToClipboard
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import com.grindrplus.ui.Utils.formatEpochSeconds
import org.json.JSONObject

private const val ENABLE_LOGGING = true

private fun logOutput(tag: String, message: String) {
    if (ENABLE_LOGGING) {
        android.util.Log.d("GrindrPlusDB", "$tag: $message")
    }
}


class Database(
    recipient: String,
    sender: String
) : CommandModule("Database", recipient, sender) {

    /**
     * Available Commands:
     * /populateLocations [populate_teleports, init_teleports] - Populates the teleport location database with default locations if empty or configured locations
     * /init_archive [setup_archive, init_archival] - Initialize selective data archival (non-invasive)
     * /archive_now [archive, backup_now] - Archive current data from Grindr database
     * /detect_deletions [check_deletions, find_deleted] - Detect deleted data by comparing archives
     * /clear_archive [clear_archival, wipe_archive] - Clear archived data
     * /toggle_http_log [toggle_http, http_log] - Toggle HTTP request/response logging
     * /toggle_wss_log [toggle_wss, wss_log] - Toggle WSS/XMPP auth logging
     * /view_logs [logs, show_logs] - View logs by type (http, credentials, wss_auth)
     * /clear_logs - Clear logs (http, credentials, wss_auth, or all)
     * /list_tables [tables, show_tables] - List all tables in the database
     * /list_table [table, show_table] - List all rows from a specific table
     * /list_databases [databases, dbs, show_dbs] - List all database files in the app's files directory
     */

    private val ioScope = CoroutineScope(Dispatchers.IO)

    @Command(name = "savealbums", aliases = ["archivealbums"], help = "Fetches and saves all albums shared with you to the local database")
    fun saveAllAlbums(args: List<String>) {
        GrindrPlus.runOnMainThread {
            Toast.makeText(it, "Starting album archival... This may take a while.", Toast.LENGTH_SHORT).show()
        }

        GrindrPlus.executeAsync {
            var profileCount = 0
            var albumCount = 0
            val albumDao = GrindrPlus.database.albumDao()

            try {
                // Step 1: Get all profiles that have shared albums with you
                val sharedResponse = GrindrPlus.httpClient.sendRequest(
                    url = "https://grindr.mobi/v2/albums/shares",
                    method = "GET"
                )

                if (!sharedResponse.isSuccessful) {
                    throw Exception("Failed to get initial list of shared albums.")
                }

                val sharedJson = JSONObject(sharedResponse.body?.string())
                val albumBriefs = sharedJson.optJSONArray("albums") ?: org.json.JSONArray()
                val profileIds = (0 until albumBriefs.length())
                    .map { albumBriefs.getJSONObject(it).optString("profileId") }
                    .filter { it.isNotEmpty() }
                    .toSet()

                profileCount = profileIds.size
                Logger.i("Found $profileCount profiles with shared albums. Starting fetch...")

                // Step 2: Iterate through each profile and get their albums
                for (profileId in profileIds) {
                    try {
                        val profileAlbumsResponse = GrindrPlus.httpClient.sendRequest(
                            url = "https://grindr.mobi/v2/albums/shares/$profileId",
                            method = "GET"
                        )
                        if (!profileAlbumsResponse.isSuccessful) continue

                        val profileAlbumsJson = JSONObject(profileAlbumsResponse.body?.string())
                        val profileAlbumBriefs = profileAlbumsJson.optJSONArray("albums") ?: continue

                        // Step 3: Iterate through each album and fetch its full content
                        for (i in 0 until profileAlbumBriefs.length()) {
                            val albumId = profileAlbumBriefs.getJSONObject(i).optLong("albumId")
                            if (albumId == 0L) continue

                            try {
                                val fullAlbumResponse = GrindrPlus.httpClient.sendRequest(
                                    url = "https://grindr.mobi/v2/albums/$albumId",
                                    method = "GET"
                                )
                                if (!fullAlbumResponse.isSuccessful) continue

                                val albumJson = JSONObject(fullAlbumResponse.body?.string())
                                val albumEntity = albumJson.asAlbumToAlbumEntity()
                                val contentEntities = albumJson.toAlbumContentEntities()

                                // Step 4: Save to database
                                GrindrPlus.database.withTransaction {
                                    albumDao.upsertAlbum(albumEntity)
                                    albumDao.upsertAlbumContents(contentEntities)
                                }
                                albumCount++
                                Logger.d("Successfully saved album $albumId from profile $profileId")
                            } catch (e: Exception) {
                                Logger.e("Failed to process album $albumId for profile $profileId: ${e.message}")
                            }
                        }
                    } catch (e: Exception) {
                        Logger.e("Failed to fetch albums for profile $profileId: ${e.message}")
                    }
                }

                GrindrPlus.runOnMainThread {
                    Toast.makeText(it, "Album archival complete! Saved $albumCount albums from $profileCount profiles.", Toast.LENGTH_LONG).show()
                }

            } catch (e: Exception) {
                Logger.e("Failed to archive albums: ${e.message}")
                GrindrPlus.runOnMainThread {
                    Toast.makeText(it, "Error during album archival. Check logs.", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    @Command(name = "populateLocations", aliases = ["populate_teleports", "init_teleports"], help = "Populates the teleport location database with default locations if empty or configured locations")
    fun populateLocations(args: List<String>) {
        ioScope.launch {
            try {
                GPDatabase.prePopulate(GrindrPlus.context)
                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Teleport locations populated successfully.")
            } catch (e: Exception) {
                Logger.e("Failed to pre-populate locations: ${e.message}", LogSource.DB)
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Error populating locations: ${e.message}")
            }
        }
    }

    @Command("init_archive", aliases = ["setup_archive", "init_archival"], help = "Initialize selective data archival (non-invasive)")
    fun initArchive(args: List<String>) {
        try {
            GrindrPlus.executeAsync {
                setupSelectiveArchival()
                GrindrPlus.runOnMainThread {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Selective archival initialized!")
                }
            }
        } catch (e: Exception) {
            Logger.e("Error initializing archival: ${e.message}", LogSource.MODULE)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    private fun setupSelectiveArchival() {
        // Create archive tables in GrindrPlus database (not Grindr's!)

        // Archive critical tables only
        DatabaseHelper.executeGrindrPlus("""
        CREATE TABLE IF NOT EXISTS archived_messages (
            message_id TEXT PRIMARY KEY,
            sender TEXT NOT NULL,
            recipient TEXT,
            body TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            conversation_id TEXT NOT NULL,
            archived_at INTEGER DEFAULT (strftime('%s','now')),
            deletion_detected INTEGER DEFAULT 0
        )
    """)

        DatabaseHelper.executeGrindrPlus("""
        CREATE TABLE IF NOT EXISTS archived_profiles (
            profile_id TEXT PRIMARY KEY,
            display_name TEXT,
            age INTEGER,
            distance REAL,
            about_me TEXT,
            profile_tags TEXT,
            last_updated INTEGER NOT NULL,
            archived_at INTEGER DEFAULT (strftime('%s','now')),
            deletion_detected INTEGER DEFAULT 0
        )
    """)

        DatabaseHelper.executeGrindrPlus("""
        CREATE TABLE IF NOT EXISTS archived_profile_photos (
            media_hash TEXT PRIMARY KEY,
            profile_id TEXT NOT NULL,
            order_ INTEGER NOT NULL,
            archived_at INTEGER DEFAULT (strftime('%s','now')),
            deletion_detected INTEGER DEFAULT 0
        )
    """)

        // Indexes for efficient querying
        DatabaseHelper.executeGrindrPlus(
            "CREATE INDEX IF NOT EXISTS idx_archived_messages_conv ON archived_messages(conversation_id)"
        )
        DatabaseHelper.executeGrindrPlus(
            "CREATE INDEX IF NOT EXISTS idx_archived_messages_time ON archived_messages(archived_at)"
        )
        DatabaseHelper.executeGrindrPlus(
            "CREATE INDEX IF NOT EXISTS idx_archived_profiles_name ON archived_profiles(display_name)"
        )

        Logger.i("Selective archival tables created in GrindrPlus database", LogSource.MODULE)
    }

    @Command("archive_now", aliases = ["archive", "backup_now"], help = "Archive current data from Grindr database")
    fun archiveNow(args: List<String>) {
        try {
            GrindrPlus.executeAsync {
                val count = performArchival()
                GrindrPlus.runOnMainThread {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Archived $count records")
                }
            }
        } catch (e: Exception) {
            Logger.e("Error during archival: ${e.message}", LogSource.MODULE)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    private fun performArchival(): Int {
        var totalArchived = 0

        // Archive messages
        try {
            val messages = DatabaseHelper.query("""
            SELECT message_id, sender, recipient, body, timestamp, conversation_id
            FROM chat_messages
            WHERE timestamp > (strftime('%s','now') - 2592000)
        """)

            messages.forEach { msg ->
                try {
                    DatabaseHelper.executeGrindrPlus("""
                    INSERT OR REPLACE INTO archived_messages 
                    (message_id, sender, recipient, body, timestamp, conversation_id)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, arrayOf(
                        msg["message_id"],
                        msg["sender"],
                        msg["recipient"],
                        msg["body"],
                        msg["timestamp"],
                        msg["conversation_id"]
                    ))
                    totalArchived++
                } catch (e: Exception) {
                    Logger.w("Failed to archive message: ${e.message}", LogSource.MODULE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Error archiving messages: ${e.message}", LogSource.MODULE)
        }

        // Archive profiles
        try {
            val profiles = DatabaseHelper.query("""
            SELECT profile_id, display_name, age, distance, about_me, 
                   profile_tags, last_updated_time
            FROM profile
            WHERE last_updated_time > (strftime('%s','now') - 2592000)
        """)

            profiles.forEach { prof ->
                try {
                    DatabaseHelper.executeGrindrPlus("""
                    INSERT OR REPLACE INTO archived_profiles 
                    (profile_id, display_name, age, distance, about_me, 
                     profile_tags, last_updated)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, arrayOf(
                        prof["profile_id"],
                        prof["display_name"],
                        prof["age"],
                        prof["distance"],
                        prof["about_me"],
                        prof["profile_tags"],
                        prof["last_updated_time"]
                    ))
                    totalArchived++
                } catch (e: Exception) {
                    Logger.w("Failed to archive profile: ${e.message}", LogSource.MODULE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Error archiving profiles: ${e.message}", LogSource.MODULE)
        }

        // Archive profile photos
        try {
            val photos = DatabaseHelper.query("""
            SELECT media_hash, profile_id, order_
            FROM profile_photo
        """)

            photos.forEach { photo ->
                try {
                    DatabaseHelper.executeGrindrPlus("""
                    INSERT OR REPLACE INTO archived_profile_photos 
                    (media_hash, profile_id, order_)
                    VALUES (?, ?, ?)
                """, arrayOf(
                        photo["media_hash"],
                        photo["profile_id"],
                        photo["order_"]
                    ))
                    totalArchived++
                } catch (e: Exception) {
                    Logger.w("Failed to archive photo: ${e.message}", LogSource.MODULE)
                }
            }
        } catch (e: Exception) {
            Logger.e("Error archiving photos: ${e.message}", LogSource.MODULE)
        }

        Logger.i("Archived $totalArchived records", LogSource.MODULE)
        return totalArchived
    }

    @Command("detect_deletions", aliases = ["check_deletions", "find_deleted"], help = "Detect deleted data by comparing archives")
    fun detectDeletions(args: List<String>) {
        try {
            GrindrPlus.executeAsync {
                val deletions = findDeletions()

                GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                    val content = if (deletions.isEmpty()) {
                        "No deletions detected."
                    } else {
                        "DETECTED DELETIONS:\n\n" + deletions.joinToString("\n\n") { deletion ->
                            """
                        Type: ${deletion["type"]}
                        ID: ${deletion["id"]}
                        Deleted: ${deletion["time"]}
                        Data: ${deletion["preview"]}
                        """.trimIndent()
                        }
                    }

                    val textView = AppCompatTextView(activity).apply {
                        text = content
                        textSize = 12f
                        setTextColor(Color.WHITE)
                        setPadding(20, 20, 20, 20)
                    }

                    val scrollView = android.widget.ScrollView(activity).apply {
                        addView(textView)
                    }

                    AlertDialog.Builder(activity)
                        .setTitle("Deletion Detection")
                        .setView(scrollView)
                        .setPositiveButton("Close") { dialog, _ -> dialog.dismiss() }
                        .setNegativeButton("Copy") { _, _ ->
                            copyToClipboard("Deletions", content)
                        }
                        .create()
                        .show()
                }
            }
        } catch (e: Exception) {
            Logger.e("Error detecting deletions: ${e.message}", LogSource.MODULE)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    private fun findDeletions(): List<Map<String, String>> {
        val deletions = mutableListOf<Map<String, String>>()

        // Check for deleted messages
        try {
            val deletedMessages = DatabaseHelper.queryGrindrPlus("""
            SELECT am.message_id, am.body, am.sender, am.conversation_id, am.archived_at
            FROM archived_messages am
            LEFT JOIN chat_messages cm ON am.message_id = cm.message_id
            WHERE cm.message_id IS NULL 
              AND am.deletion_detected = 0
            LIMIT 50
        """)

            deletedMessages.forEach { msg ->
                val messageId = msg["message_id"] as String
                val body = msg["body"] as String
                val sender = msg["sender"] as String
                val convId = msg["conversation_id"] as String
                val archivedAt = msg["archived_at"] as Int

                deletions.add(mapOf(
                    "type" to "Message",
                    "id" to messageId,
                    "time" to formatEpochSeconds(archivedAt.toLong()),
                    "preview" to "From: $sender\nConv: $convId\nBody: ${body.take(100)}"
                ))

                // Mark as detected
                DatabaseHelper.executeGrindrPlus(
                    "UPDATE archived_messages SET deletion_detected = 1 WHERE message_id = ?",
                    arrayOf(messageId)
                )
            }
        } catch (e: Exception) {
            Logger.e("Error checking deleted messages: ${e.message}", LogSource.MODULE)
        }

        // Check for deleted profiles
        try {
            val deletedProfiles = DatabaseHelper.queryGrindrPlus("""
            SELECT ap.profile_id, ap.display_name, ap.about_me, ap.archived_at
            FROM archived_profiles ap
            LEFT JOIN profile p ON ap.profile_id = p.profile_id
            WHERE p.profile_id IS NULL 
              AND ap.deletion_detected = 0
            LIMIT 50
        """)

            deletedProfiles.forEach { prof ->
                val profileId = prof["profile_id"] as String
                val displayName = prof["display_name"] as? String
                val aboutMe = prof["about_me"] as? String
                val archivedAt = prof["archived_at"] as Int

                deletions.add(mapOf(
                    "type" to "Profile",
                    "id" to profileId,
                    "time" to formatEpochSeconds(archivedAt.toLong()),
                    "preview" to "Name: $displayName\nAbout: ${aboutMe?.take(100) ?: "N/A"}"
                ))

                DatabaseHelper.executeGrindrPlus(
                    "UPDATE archived_profiles SET deletion_detected = 1 WHERE profile_id = ?",
                    arrayOf(profileId)
                )
            }
        } catch (e: Exception) {
            Logger.e("Error checking deleted profiles: ${e.message}", LogSource.MODULE)
        }

        return deletions
    }

    @Command("clear_archive", aliases = ["clear_archival", "wipe_archive"], help = "Clear archived data")
    fun clearArchive(args: List<String>) {
        try {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                AlertDialog.Builder(activity)
                    .setTitle("Clear Archive?")
                    .setMessage("This will permanently delete all archived data. Continue?")
                    .setPositiveButton("Yes") { _, _ ->
                        GrindrPlus.executeAsync {
                            DatabaseHelper.executeGrindrPlus("DELETE FROM archived_messages")
                            DatabaseHelper.executeGrindrPlus("DELETE FROM archived_profiles")
                            DatabaseHelper.executeGrindrPlus("DELETE FROM archived_profile_photos")

                            GrindrPlus.showToast(Toast.LENGTH_SHORT, "Archive cleared")
                        }
                    }
                    .setNegativeButton("Cancel", null)
                    .show()
            }
        } catch (e: Exception) {
            Logger.e("Error clearing archive: ${e.message}", LogSource.MODULE)
        }
    }

    @Command("init_db", aliases = ["init_databases", "setup_db"], help = "Initialize all databases (teleports and archival)")
    fun initDatabases(args: List<String>) {
        try {
            GrindrPlus.executeAsync {
                populateLocations(emptyList()) // Run teleport population
                initArchive(emptyList()) // Run archival setup
                GrindrPlus.runOnMainThread {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "All databases initialized!")
                }
            }
        } catch (e: Exception) {
            Logger.e("Error initializing databases: ${e.message}", LogSource.MODULE)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    @Command("toggle_logging", aliases = ["logging", "log_toggle"], help = "Toggle all logging (HTTP and WSS)")
    fun toggleAllLogging(args: List<String>) {
        try {
            toggleHttpLog(emptyList()) // Toggle HTTP logging
            toggleWssLog(emptyList()) // Toggle WSS logging
            val httpStatus = if (Config.get("enable_http_logging", false) as Boolean) "ON" else "OFF"
            val wssStatus = if (Config.get("enable_wss_logging", false) as Boolean) "ON" else "OFF"
            GrindrPlus.showToast(Toast.LENGTH_SHORT, "HTTP: $httpStatus, WSS: $wssStatus")
        } catch (e: Exception) {
            Logger.e("Error toggling logging: ${e.message}", LogSource.MODULE)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    @Command("toggle_http_log", aliases = ["toggle_http", "http_log"], help = "Toggle HTTP request/response logging")
    fun toggleHttpLog(args: List<String>) {
        val current = Config.get("enable_http_logging", false) as Boolean
        Config.put("enable_http_logging", !current)
        GrindrPlus.showToast(Toast.LENGTH_SHORT, "HTTP logging: ${if (!current) "ON" else "OFF"}")
    }

    @Command("toggle_wss_log", aliases = ["toggle_wss", "wss_log"], help = "Toggle WSS/XMPP auth logging")
    fun toggleWssLog(args: List<String>) {
        val current = Config.get("enable_wss_logging", false) as Boolean
        Config.put("enable_wss_logging", !current)
        GrindrPlus.showToast(Toast.LENGTH_SHORT, "WSS logging: ${if (!current) "ON" else "OFF"}")
    }

    @Command("view_logs", aliases = ["logs", "show_logs"], help = "View logs by type (http, credentials, wss_auth)")
    fun viewLogs(args: List<String>) {
        val type = args.getOrNull(0) ?: "all"
        val limit = args.getOrNull(1)?.toIntOrNull() ?: 50

        GrindrPlus.executeAsync {
            val logs = when (type.lowercase()) {
                "http" -> GrindrPlus.database.logDao().getLogsByType("http", limit)
                "credentials", "creds" -> GrindrPlus.database.logDao().getLogsByType("credentials", limit)
                "wss", "wss_auth" -> GrindrPlus.database.logDao().getLogsByType("wss_auth", limit)
                "all" -> {
                    val httpCount = GrindrPlus.database.logDao().getCountByType("http")
                    val credCount = GrindrPlus.database.logDao().getCountByType("credentials")
                    val wssCount = GrindrPlus.database.logDao().getCountByType("wss_auth")

                    GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                        val summary = """
                    LOG SUMMARY:
                    
                    HTTP Logs: $httpCount
                    Credentials: $credCount
                    WSS Auth: $wssCount
                    
                    Use: /view_logs http
                         /view_logs credentials
                         /view_logs wss
                    """.trimIndent()

                        android.app.AlertDialog.Builder(activity)
                            .setTitle("Logs")
                            .setMessage(summary)
                            .setPositiveButton("OK", null)
                            .show()
                    }
                    return@executeAsync
                }
                else -> emptyList()
            }

            val content = logs.joinToString("\n\n") { log ->
                when (log.log_type) {
                    "http" -> "URL: ${log.url}\nMethod: ${log.method}\nCode: ${log.response_code}\nTime: ${formatEpochSeconds(log.timestamp / 1000)}"
                    "credentials" -> "Profile: ${log.profile_id}\nToken: ${log.auth_token?.take(20)}...\nTime: ${formatEpochSeconds(log.timestamp / 1000)}"
                    "wss_auth" -> "Profile: ${log.profile_id}\nXMPP Token: ${log.xmpp_token?.take(20)}...\nTime: ${formatEpochSeconds(log.timestamp / 1000)}"
                    else -> "Unknown log type"
                }
            }

            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val textView = AppCompatTextView(activity).apply {
                    text = content.ifEmpty { "No logs found" }
                    textSize = 12f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                }

                val scrollView = android.widget.ScrollView(activity).apply {
                    addView(textView)
                }

                android.app.AlertDialog.Builder(activity)
                    .setTitle("${type.uppercase()} Logs")
                    .setView(scrollView)
                    .setPositiveButton("Close", null)
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Logs", content)
                    }
                    .show()
            }
        }
    }

    @Command("clear_logs", aliases = ["cl"], help = "Clear logs (http, credentials, wss_auth, or all)")
    fun clearLogs(args: List<String>) {
        val type = args.getOrNull(0) ?: "all"

        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            android.app.AlertDialog.Builder(activity)
                .setTitle("Clear Logs?")
                .setMessage("Clear $type logs?")
                .setPositiveButton("Yes") { _, _ ->
                    GrindrPlus.executeAsync {
                        when (type.lowercase()) {
                            "http" -> GrindrPlus.database.logDao().clearLogsByType("http")
                            "credentials", "creds" -> GrindrPlus.database.logDao().clearLogsByType("credentials")
                            "wss", "wss_auth" -> GrindrPlus.database.logDao().clearLogsByType("wss_auth")
                            "all" -> GrindrPlus.database.logDao().clearAllLogs()
                        }
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Logs cleared")
                    }
                }
                .setNegativeButton("Cancel", null)
                .show()
        }
    }

    @Command("list_tables", aliases = ["tables", "show_tables"], help = "List all tables in the database")
    fun listTables(args: List<String>) {
        try {
            val query = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;"
            val tables = DatabaseHelper.query(query).map { it["name"].toString() }



            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                val tableList = if (tables.isEmpty()) "No tables found."
                else tables.joinToString("\n")

                val textView = AppCompatTextView(activity).apply {
                    text = tableList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }

                logOutput("LIST_TABLES", tableList)

                dialogView.addView(textView)

                AlertDialog.Builder(activity)
                    .setTitle("Database Tables")
                    .setView(dialogView)
                    .setPositiveButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Database Tables", tableList)
                    }
                    .create()
                    .show()
            }
        } catch (e: Exception) {
            val errorMsg = "Error: ${e.message}"
            logOutput("LIST_TABLES_ERROR", errorMsg)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    @Command("list_table", aliases = ["table", "show_table"], help = "List all rows from a specific table")
    fun listTable(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Please provide a table name.")
            return
        }

        val tableName = args[0]
        try {
            val query = "SELECT * FROM $tableName;"
            val rows = DatabaseHelper.query(query)

            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                val tableContent = if (rows.isEmpty()) {
                    "No rows found in table $tableName."
                } else {
                    rows.joinToString("\n\n") { row ->
                        row.entries.joinToString(", ") { "${it.key}: ${it.value}" }
                    }
                }

                val textView = AppCompatTextView(activity).apply {
                    text = tableContent
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                logOutput("LIST_TABLE_$tableName", tableContent)

                dialogView.addView(textView)

                AlertDialog.Builder(activity)
                    .setTitle("Table Content: $tableName")
                    .setView(dialogView)
                    .setPositiveButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Table Content: $tableName", tableContent)
                    }
                    .create()
                    .show()
            }
        } catch (e: Exception) {
            val errorMsg = "Error: ${e.message}"
            logOutput("LIST_TABLE_ERROR", errorMsg)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }

    @Command("list_databases", aliases = ["databases", "dbs", "show_dbs"], help = "List all database files in the app's files directory")
    fun listDatabases(args: List<String>) {
        try {
            val context = GrindrPlus.context
            val databases = context.databaseList()

            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                val dbList = if (databases.isEmpty()) "No databases found." else databases.joinToString("\n")

                val textView = AppCompatTextView(activity).apply {
                    text = dbList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }
                logOutput("LIST_DATABASES", dbList)
                dialogView.addView(textView)

                AlertDialog.Builder(activity)
                    .setTitle("Database Files")
                    .setView(dialogView)
                    .setPositiveButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNegativeButton("Copy") { _, _ ->
                        copyToClipboard("Database Files", dbList)
                    }
                    .create()
                    .show()
            }
        } catch (e: Exception) {
            val errorMsg = "Error: ${e.message}"
            logOutput("LIST_DATABASES_ERROR", errorMsg)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: ${e.message}")
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\Filtering.kt --- 
package com.grindrplus.commands



import android.app.AlertDialog
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.ui.Utils.copyToClipboard

private const val ENABLE_LOGGING = false

private fun logOutput(tag: String, message: String) {
    if (ENABLE_LOGGING) {
        android.util.Log.d("GrindrPlusFilter", "$tag: $message")
    }
}



class Filtering(recipient: String, sender: String) : CommandModule(
    "Filtering",
    recipient,
    sender
) {
    @Command(
        name = "filter",
        aliases = ["f"],
        help = "Toggle custom filtering on/off"
    )
    fun toggleFiltering(args: List<String>) {
        val currentState = Config.get("custom_filtering_enabled", false) as Boolean
        Config.put("custom_filtering_enabled", !currentState)
        val newState = !currentState
        val message = "Custom filtering ${if (newState) "enabled" else "disabled"}"

        logOutput("FILTER_TOGGLE", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_distance",
        aliases = ["fd"],
        help = "Set maximum distance filter in meters (0 to disable). Usage: filter_distance <meters>"
    )
    fun filterDistance(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_max_distance", 0) as Int
            val message = "Current max distance: $current meters"

            logOutput("FILTER_DISTANCE_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val distance = args[0].toIntOrNull()
        if (distance == null || distance < 0) {
            val message = "Invalid distance. Use a positive number or 0 to disable."

            logOutput("FILTER_DISTANCE_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_max_distance", distance)
        val message =
            "Max distance set to: ${if (distance == 0) "disabled" else "$distance meters"}"

        logOutput("FILTER_DISTANCE_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_favorites",
        aliases = ["ff"],
        help = "Toggle favorites-only filter"
    )
    fun filterFavorites(args: List<String>) {
        val currentState = Config.get("filter_favorites_only", false) as Boolean
        Config.put("filter_favorites_only", !currentState)
        val newState = !currentState
        val message = "Favorites filter ${if (newState) "enabled" else "disabled"}"

        logOutput("FILTER_FAVORITES", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_gender",
        aliases = ["fg"],
        help = "Set gender filter (0=all, 1=male, 2=trans, 3=nonbinary, 4=cis woman, 5=transwoman, 6=cis man, 7=transman). Usage: filter_gender <number>"
    )
    fun filterGender(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_gender", 0) as Int
            val genderName = when (current) {
                1 -> "Man"
                2 -> "Trans"
                3 -> "Non-binary"
                4 -> "Cis Woman"
                5 -> "Trans Woman"
                6 -> "Cis Man"
                7 -> "Trans Man"
                else -> "All"
            }
            val message = "Current gender filter: $genderName ($current)"

            logOutput("FILTER_GENDER_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val gender = args[0].toIntOrNull()
        if (gender == null || gender !in 0..7) {
            val message = "Invalid gender. Use 0 (all) or 1-7 for specific genders."

            logOutput("FILTER_GENDER_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_gender", gender)
        val genderName = when (gender) {
            1 -> "Man"
            2 -> "Trans"
            3 -> "Non-binary"
            4 -> "Cis Woman"
            5 -> "Trans Woman"
            6 -> "Cis Man"
            7 -> "Trans Man"
            else -> "All"
        }
        val message = "Gender filter set to: $genderName"

        logOutput("FILTER_GENDER_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_tribe",
        aliases = ["ft"],
        help = "Set tribe filter (0=all, 1-14=specific tribe). Usage: filter_tribe <number>"
    )
    fun filterTribe(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_tribe", 0) as Int
            val message = "Current tribe filter: ${if (current == 0) "All" else "Tribe #$current"}"

            logOutput("FILTER_TRIBE_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val tribe = args[0].toIntOrNull()
        if (tribe == null || tribe !in 0..14) {
            val message = "Invalid tribe. Use 0 (all) or 1-14 for specific tribes."

            logOutput("FILTER_TRIBE_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_tribe", tribe)
        val message = "Tribe filter set to: ${if (tribe == 0) "All" else "Tribe #$tribe"}"

        logOutput("FILTER_TRIBE_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_ethnicity",
        aliases = ["fe"],
        help = "Set ethnicity filter (comma-separated, 0=all). Usage: filter_ethnicity <numbers> or filter_ethnicity 0"
    )
    fun filterEthnicity(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_ethnicity", "0") as String
            val mode = Config.get("filter_ethnicity_mode", "include") as String
            val message =
                "Current ethnicity filter: ${if (current == "0") "All" else "$current ($mode)"}"

            logOutput("FILTER_ETHNICITY_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val input = args.joinToString(" ").replace(" ", "")

        if (input == "0") {
            Config.put("filter_ethnicity", "0")
            val message = "Ethnicity filter disabled (showing all)"

            logOutput("FILTER_ETHNICITY_SET", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
            return
        }

        val ethnicities = input.split(",").mapNotNull { it.toIntOrNull() }
        if (ethnicities.isEmpty() || ethnicities.any { it < 1 || it > 9 }) {
            val message =
                "Invalid input. Use comma-separated numbers 1-9 (e.g., 1,3,5) or 0 for all."

            logOutput("FILTER_ETHNICITY_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_ethnicity", ethnicities.joinToString(","))
        val message = "Ethnicity filter set to: ${ethnicities.joinToString(", ")}"

        logOutput("FILTER_ETHNICITY_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_ethnicity_mode",
        aliases = ["fem"],
        help = "Set ethnicity filter mode: include (show matching) or exclude (hide matching)"
    )
    fun filterEthnicityMode(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_ethnicity_mode", "include") as String
            val message = "Current mode: $current (use 'include' or 'exclude')"

            logOutput("FILTER_ETHNICITY_MODE_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val mode = args[0].lowercase()
        if (mode != "include" && mode != "exclude") {
            val message = "Invalid mode. Use 'include' or 'exclude'."

            logOutput("FILTER_ETHNICITY_MODE_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_ethnicity_mode", mode)
        val message = "Ethnicity filter mode set to: $mode"

        logOutput("FILTER_ETHNICITY_MODE_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_social",
        aliases = ["fs"],
        help = "Toggle filter for profiles with social networks only"
    )
    fun filterSocial(args: List<String>) {
        val currentState = Config.get("filter_has_social_networks", false) as Boolean
        Config.put("filter_has_social_networks", !currentState)
        val newState = !currentState
        val message = "Social networks filter ${if (newState) "enabled" else "disabled"}"

        logOutput("FILTER_SOCIAL", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_status",
        aliases = ["fst"],
        help = "Show current filter settings in dialog"
    )
    fun filterStatus(args: List<String>) {
        val enabled = Config.get("custom_filtering_enabled", false) as Boolean
        val maxDistance = Config.get("filter_max_distance", 0) as Int
        val favoritesOnly = Config.get("filter_favorites_only", false) as Boolean
        val gender = Config.get("filter_gender", 0) as Int
        val tribe = Config.get("filter_tribe", 0) as Int
        val ethnicity = Config.get("filter_ethnicity", "0") as String
        val ethnicityMode = Config.get("filter_ethnicity_mode", "include") as String
        val hasSocial = Config.get("filter_has_social_networks", false) as Boolean
        val aboutText = Config.get("filter_about_text", "") as String
        val aboutMode = Config.get("filter_about_mode", "include") as String
        val tags = Config.get("filter_tags", "") as String
        val tagsMode = Config.get("filter_tags_mode", "include") as String
        val ageMin = Config.get("filter_age_min", 0) as Int
        val ageMax = Config.get("filter_age_max", 0) as Int
        val includeNoAge = Config.get("filter_age_include_no_age", true) as Boolean

        val genderName = when (gender) {
            1 -> "Man"
            2 -> "Trans"
            3 -> "Non-binary"
            4 -> "Cis Woman"
            5 -> "Trans Woman"
            6 -> "Cis Man"
            7 -> "Trans Man"
            else -> "All"
        }

        val ageFilterText = when {
            ageMin == 0 && ageMax == 0 -> "None"
            ageMin == ageMax -> "$ageMin years"
            else -> "$ageMin-$ageMax years (no age: ${if (includeNoAge) "include" else "exclude"})"
        }

        val status = """
Filter Status:
• Filtering: ${if (enabled) "ON" else "OFF"}
• Max Distance: ${if (maxDistance == 0) "Off" else "${maxDistance}m"}
• Favorites Only: ${if (favoritesOnly) "ON" else "OFF"}
• Gender: $genderName
• Tribe: ${if (tribe == 0) "All" else "#$tribe"}
• Ethnicity: ${if (ethnicity == "0") "All" else "$ethnicity ($ethnicityMode)"}
• Social: ${if (hasSocial) "ON" else "OFF"}
• About Text: ${if (aboutText.isEmpty()) "None" else "\"$aboutText\" ($aboutMode)"}
• Tags: ${if (tags.isEmpty()) "None" else "$tags ($tagsMode)"}
• Age: $ageFilterText
    """.trimIndent()

        logOutput("FILTER_STATUS", status)

        // Use the same pattern as CommandHandler.help
        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            AlertDialog.Builder(activity)
                .setTitle("Filter Status")
                .setMessage(status)
                .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                .setNegativeButton("Copy") { _, _ ->
                    copyToClipboard("Filter Status", status)
                }
                .create()
                .show()
        }
    }

    @Command(
        name = "filter_help",
        aliases = ["fh"],
        help = "Show filter commands help with copy option"
    )
    fun filterHelp(args: List<String>) {
        val helpText = """
Filtering Commands:

/filter (f) - Toggle custom filtering on/off
/filter_distance (fd) <meters> - Set max distance filter (0 to disable)
/filter_favorites (ff) - Toggle favorites-only filter
/filter_gender (fg) <0-7> - Set gender filter (0=all, 1-7=specific)
/filter_tribe (ft) <0-14> - Set tribe filter (0=all, 1-14=specific)
/filter_ethnicity (fe) <numbers> - Set ethnicity filter (comma-separated, 0=all)
/filter_ethnicity_mode (fem) <include/exclude> - Set ethnicity filter mode
/filter_social (fs) - Toggle social networks filter
/filter_about (fa) <text> - Set about me text filter (0 to clear)
/filter_about_mode (fam) <include/exclude> - Set about text filter mode
/filter_tags (fta) <tags> - Set tag filter (comma-separated, 0 to clear)
/filter_tags_mode (ftm) <include/exclude> - Set tag filter mode
/filter_age (fage) <age> - Set age filter (25 or 20-30, 0 to clear)
/filter_age_noage (fana) - Toggle including profiles with no age
/filter_status (fst) - Show current filter settings in dialog
/filter_reset (fr) - Reset all filters to default
/filter_help (fh) - Show this help message

Ethnicity values: 1=Asian, 2=Black, 3=Latino, 4=Middle Eastern, 5=Mixed, 6=Native American, 7=South Asian, 8=White, 9=Other
Gender values: 1=Man, 2=Trans, 3=Non-binary, 4=Cis Woman, 5=Trans Woman, 6=Cis Man, 7=Trans Man
    """.trimIndent()

        logOutput("FILTER_HELP", "Displayed filter help")

        // Use the same pattern as CommandHandler.help
        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            AlertDialog.Builder(activity)
                .setTitle("Filter Commands Help")
                .setMessage(helpText)
                .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                .setNegativeButton("Copy") { _, _ ->
                    copyToClipboard("Filter Commands Help", helpText)
                }
                .create()
                .show()
        }
    }

    @Command(
        name = "grid_columns",
        aliases = ["gc"],
        help = "Set main grid columns. Usage: grid_columns <3-6>"
    )
    fun setGridColumns(args: List<String>) {
        val cols = args.getOrNull(0)?.toIntOrNull() ?: 3
        if (cols in 2..6) {
            Config.put("cascade_grid_columns", cols)
            GrindrPlus.showToast(Toast.LENGTH_SHORT, "Grid set to $cols columns. Restart app.")
        }
    }

    @Command(
        name = "filter_reset",
        aliases = ["fr"],
        help = "Reset all filters to default (disabled)"
    )
    fun filterReset(args: List<String>) {
        Config.put("custom_filtering_enabled", false)
        Config.put("filter_max_distance", 0)
        Config.put("filter_favorites_only", false)
        Config.put("filter_gender", 0)
        Config.put("filter_tribe", 0)
        Config.put("filter_ethnicity", "0")
        Config.put("filter_ethnicity_mode", "include")
        Config.put("filter_has_social_networks", false)
        Config.put("filter_about_text", "")
        Config.put("filter_about_mode", "include")
        Config.put("filter_tags", "")
        Config.put("filter_tags_mode", "include")
        Config.put("filter_age_min", 0)
        Config.put("filter_age_max", 0)
        Config.put("filter_age_include_no_age", true)

        val message = "All filters reset to default"
        logOutput("FILTER_RESET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    private fun convertUnicodeEscapes(input: String): String {
        val pattern = "\\\\u([0-9a-fA-F]{4})".toRegex()
        return pattern.replace(input) { matchResult ->
            val hex = matchResult.groupValues[1]
            val codePoint = hex.toInt(16)
            String(Character.toChars(codePoint))
        }
    }

    @Command(
        name = "filter_about",
        aliases = ["fa"],
        help = "Set about me text filter (supports Unicode escapes like \\uD83E\\uDD76). Usage: filter_about <text> or filter_about 0 to clear"
    )
    fun filterAbout(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_about_text", "") as String
            val mode = Config.get("filter_about_mode", "include") as String
            val message =
                "Current about filter: ${if (current.isEmpty()) "None" else "\"$current\" ($mode)"}"

            logOutput("FILTER_ABOUT_QUERY", message)
            GrindrPlus.showToast(Toast.LENGTH_LONG, message)
            return
        }

        val input = args.joinToString(" ").trim()

        if (input == "0") {
            Config.put("filter_about_text", "")
            val message = "About text filter cleared"

            logOutput("FILTER_ABOUT_SET", message)
            GrindrPlus.showToast(Toast.LENGTH_SHORT, message)
            return
        }

        // Convert Unicode escape sequences
        val convertedInput = convertUnicodeEscapes(input)
        Config.put("filter_about_text", convertedInput)
        val message = "About text filter set to: \"$convertedInput\""

        logOutput("FILTER_ABOUT_SET", message)
        GrindrPlus.showToast(Toast.LENGTH_SHORT, message)
    }


    @Command(
        name = "filter_about_mode",
        aliases = ["fam"],
        help = "Set about text filter mode: include (show matching) or exclude (hide matching)"
    )
    fun filterAboutMode(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_about_mode", "include") as String
            val message = "Current about mode: $current (use 'include' or 'exclude')"

            logOutput("FILTER_ABOUT_MODE_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val mode = args[0].lowercase()
        if (mode != "include" && mode != "exclude") {
            val message = "Invalid mode. Use 'include' or 'exclude'."

            logOutput("FILTER_ABOUT_MODE_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_about_mode", mode)
        val message = "About text filter mode set to: $mode"

        logOutput("FILTER_ABOUT_MODE_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }


    @Command(
        name = "filter_age",
        aliases = ["fage"],
        help = "Set age filter. Usage: filter_age <min>-<max> or filter_age <exact> or filter_age 0 to clear"
    )
    fun filterAge(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_age_min", 0) as Int
            val currentMax = Config.get("filter_age_max", 0) as Int
            val includeNoAge = Config.get("filter_age_include_no_age", true) as Boolean

            val message = when {
                current == 0 && currentMax == 0 -> "Current age filter: None"
                current == currentMax -> "Current age filter: $current years old"
                else -> "Current age filter: $current-$currentMax years (include no age: ${if (includeNoAge) "yes" else "no"})"
            }

            logOutput("FILTER_AGE_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val input = args[0].trim()

        if (input == "0") {
            Config.put("filter_age_min", 0)
            Config.put("filter_age_max", 0)
            val message = "Age filter cleared"

            logOutput("FILTER_AGE_SET", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
            return
        }

        // Parse age input - can be single number or range
        val ageRange = input.split("-")
        val minAge: Int
        val maxAge: Int

        when {
            ageRange.size == 1 -> {
                // Single age
                minAge = ageRange[0].toIntOrNull() ?: 0
                maxAge = minAge
                if (minAge == 0) {
                    val message =
                        "Invalid age format. Use: filter_age 25 or filter_age 20-30 or filter_age 0 to clear"
                    logOutput("FILTER_AGE_ERROR", message)
                    GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
                    return
                }
            }

            ageRange.size == 2 -> {
                // Age range
                minAge = ageRange[0].toIntOrNull() ?: 0
                maxAge = ageRange[1].toIntOrNull() ?: 0
                if (minAge == 0 || maxAge == 0 || minAge > maxAge) {
                    val message = "Invalid age range. Use format: filter_age 20-30"
                    logOutput("FILTER_AGE_ERROR", message)
                    GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
                    return
                }
            }

            else -> {
                val message =
                    "Invalid age format. Use: filter_age 25 or filter_age 20-30 or filter_age 0 to clear"
                logOutput("FILTER_AGE_ERROR", message)
                GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
                return
            }
        }

        Config.put("filter_age_min", minAge)
        Config.put("filter_age_max", maxAge)

        val message = if (minAge == maxAge) {
            "Age filter set to: $minAge years old"
        } else {
            "Age filter set to: $minAge-$maxAge years"
        }

        logOutput("FILTER_AGE_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_age_noage",
        aliases = ["fana"],
        help = "Toggle whether to include profiles with no age set in age filter results"
    )
    fun filterAgeNoAge(args: List<String>) {
        val currentState = Config.get("filter_age_include_no_age", true) as Boolean
        Config.put("filter_age_include_no_age", !currentState)
        val newState = !currentState
        val message = "Include profiles with no age: ${if (newState) "YES" else "NO"}"

        logOutput("FILTER_AGE_NOAGE", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_tags",
        aliases = ["fta"],
        help = "Set tag filter (comma-separated tags). Usage: filter_tags <tags> or filter_tags 0 to clear"
    )
    fun filterTags(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_tags", "") as String
            val mode = Config.get("filter_tags_mode", "any") as String // Changed default to "any"
            val message =
                "Current tag filter: ${if (current.isEmpty()) "None" else "$current ($mode)"}"

            logOutput("FILTER_TAGS_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val input = args.joinToString(" ").trim()

        if (input == "0") {
            Config.put("filter_tags", "")
            val message = "Tag filter cleared"

            logOutput("FILTER_TAGS_SET", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
            return
        }

        Config.put("filter_tags", input)
        val message = "Tag filter set to: $input"

        logOutput("FILTER_TAGS_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }

    @Command(
        name = "filter_tags_mode",
        aliases = ["ftm"],
        help = "Set tag filter mode: any (show if ANY tag matches) or all (show if ALL tags match) or exclude (hide matching)"
    )
    fun filterTagsMode(args: List<String>) {
        if (args.isEmpty()) {
            val current = Config.get("filter_tags_mode", "any") as String
            val message = "Current tag mode: $current (use 'any', 'all', or 'exclude')"

            logOutput("FILTER_TAGS_MODE_QUERY", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        val mode = args[0].lowercase()
        if (mode != "any" && mode != "all" && mode != "exclude") {
            val message = "Invalid mode. Use 'any', 'all', or 'exclude'."

            logOutput("FILTER_TAGS_MODE_ERROR", message)
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, message)
            return
        }

        Config.put("filter_tags_mode", mode)
        val message = "Tag filter mode set to: $mode"

        logOutput("FILTER_TAGS_MODE_SET", message)
        GrindrPlus.showToast(android.widget.Toast.LENGTH_SHORT, message)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\Location.kt --- 
package com.grindrplus.commands

import android.app.AlertDialog
import android.net.Uri
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.GrindrPlus.packageName
import com.grindrplus.core.Config
import com.grindrplus.core.Logger
import com.grindrplus.core.TaskScheduler
import com.grindrplus.core.Utils.coordsToGeoHash
import kotlinx.coroutines.*
import okhttp3.OkHttpClient
import org.json.JSONArray
import org.json.JSONObject

class Location(recipient: String, sender: String) :
    CommandModule("Location", recipient, sender) {

    private val coroutineScope = CoroutineScope(Dispatchers.Main)
    private val scheduler = TaskScheduler(coroutineScope)

    companion object {
        private const val STATIC_TELEPORT_TASK = "static_teleport"
        private const val DEFAULT_INTERVAL_MS = 90L * 1000
        private const val STATIC_LOCATION_KEY = "static_location_coords"
        private const val STATIC_INTERVAL_KEY = "static_location_interval"
    }

    init {
        coroutineScope.launch {
            try {
                val saved = Config.get(STATIC_LOCATION_KEY, "") as String
                if (saved.isNotEmpty()) {
                    val interval = Config.get(STATIC_INTERVAL_KEY, DEFAULT_INTERVAL_MS) as Long
                    startStaticTeleportTask(saved, interval)
                    Logger.i("Static teleport restored: $saved every ${interval / 1000}s")
                }
            } catch (e: Exception) {
                Logger.e("Failed to restore static teleport: ${e.message}")
                Config.put(STATIC_LOCATION_KEY, "")
            }
        }
    }

    @Command(name = "tp", aliases = ["tp"], help = "Teleport to a location")
    fun teleport(args: List<String>) = teleportCommand(Mode.NORMAL, args)

    @Command(
        name = "tpS",
        aliases = ["tps"],
        help = "Static teleport (re-send every N seconds)"
    )
    fun teleportStatic(args: List<String>) = teleportCommand(Mode.STATIC, args)

    private enum class Mode { NORMAL, STATIC }

    private fun teleportCommand(mode: Mode, rawArgs: List<String>) {
        // ---------- 1. forced-coordinates guard ----------
        if (Config.get("forced_coordinates", "") as String != "") {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                AlertDialog.Builder(activity)
                    .setTitle("${if (mode == Mode.STATIC) "Static " else ""}Teleport disabled")
                    .setMessage("Forced coordinates are active – disable them first.")
                    .setPositiveButton("OK", null)
                    .setNegativeButton("Disable") { _, _ ->
                        Config.put("forced_coordinates", "")
                        GrindrPlus.bridgeClient.deleteForcedLocation(packageName)
                        GrindrPlus.showToast(Toast.LENGTH_LONG, "Forced coordinates disabled")
                    }
                    .show()
            }
            return
        }

        // ---------- 2. parse interval (only for STATIC) ----------
        var intervalMs = if (mode == Mode.STATIC) DEFAULT_INTERVAL_MS else 0L
        val args = rawArgs.toMutableList()

        if (mode == Mode.STATIC && args.size > 1) {
            args.last().toLongOrNull()?.let {
                intervalMs = it * 1000
                args.removeAt(args.size - 1)
            }
        }

        val argsJoined = args.joinToString(" ")

        // ---------- 3. "off" / empty-arg handling ----------
        when {
            argsJoined.equals("off", ignoreCase = true) -> {
                if (mode == Mode.STATIC) {
                    scheduler.cancelTask(STATIC_TELEPORT_TASK)
                    Config.put(STATIC_LOCATION_KEY, "")
                    LocationCache.clear()
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Static teleport disabled")
                } else {
                    Config.put("current_location", "")
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Teleport disabled")
                }
                return
            }

            args.isEmpty() -> {
                if (mode == Mode.STATIC) {
                    val running = scheduler.isTaskRunning(STATIC_TELEPORT_TASK)
                    if (running) {
                        scheduler.cancelTask(STATIC_TELEPORT_TASK)
                        Config.put(STATIC_LOCATION_KEY, "")
                        LocationCache.clear()
                        GrindrPlus.showToast(Toast.LENGTH_LONG, "Static teleport disabled")
                    } else {
                        val saved = Config.get(STATIC_LOCATION_KEY, "") as String
                        if (saved.isNotEmpty()) {
                            val savedInt = Config.get(STATIC_INTERVAL_KEY, DEFAULT_INTERVAL_MS) as Long
                            startStaticTeleportTask(saved, savedInt)
                            GrindrPlus.showToast(
                                Toast.LENGTH_LONG,
                                "Static teleport re-enabled (${savedInt / 1000}s)"
                            )
                        } else {
                            GrindrPlus.showToast(Toast.LENGTH_LONG, "Use /tpS <location> [seconds]")
                        }
                    }
                } else {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Use /tp <location> or /tp off")
                }
                return
            }
        }

        // ---------- 4. direct coordinates ----------
        val directCoords: Pair<Double, Double>? = when {
            args.size == 1 && args[0].contains(",") -> {
                val p = args[0].split(",")
                val lat = p[0].trim().toDoubleOrNull()
                val lon = p.getOrNull(1)?.trim()?.toDoubleOrNull()
                if (lat != null && lon != null) lat to lon else null
            }

            args.size == 2 && args.all { it.toDoubleOrNull() != null } -> {
                args[0].toDouble() to args[1].toDouble()
            }

            else -> null
        }

        if (directCoords != null) {
            val (lat, lon) = directCoords
            if (mode == Mode.STATIC) {
                val coordStr = "$lat,$lon"
                Config.put(STATIC_LOCATION_KEY, coordStr)
                Config.put(STATIC_INTERVAL_KEY, intervalMs)
                startStaticTeleportTask(coordStr, intervalMs)
                GrindrPlus.showToast(
                    Toast.LENGTH_LONG,
                    "Static teleport to $lat,$lon (${intervalMs / 1000}s)"
                )
            } else {
                teleportToCoordinates(lat, lon)
            }
            return
        }

        // ---------- 5. resolve name → coordinates ----------
        coroutineScope.launch {
            val resolved = getLocation(argsJoined) ?: getLocationFromNominatimAsync(argsJoined)
            if (resolved == null) {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Location not found")
                return@launch
            }

            val (lat, lon) = resolved
            val coordStr = "$lat,$lon"

            if (mode == Mode.STATIC) {
                Config.put(STATIC_LOCATION_KEY, coordStr)
                Config.put(STATIC_INTERVAL_KEY, intervalMs)
                startStaticTeleportTask(coordStr, intervalMs)
                GrindrPlus.showToast(
                    Toast.LENGTH_LONG,
                    "Static teleport to $coordStr (${intervalMs / 1000}s)"
                )
            } else {
                teleportToCoordinates(lat, lon)
            }
        }
    }

    private fun startStaticTeleportTask(coordStr: String, interval: Long) {
        scheduler.cancelTask(STATIC_TELEPORT_TASK)

        val parts = coordStr.split(",")
        if (parts.size != 2) {
            Logger.e("Bad static coord format: $coordStr")
            Config.put(STATIC_LOCATION_KEY, "")
            return
        }

        val lat = parts[0].trim().toDoubleOrNull()
        val lon = parts[1].trim().toDoubleOrNull()
        if (lat == null || lon == null || lat !in -90.0..90.0 || lon !in -180.0..180.0) {
            Logger.e("Invalid static coordinates: $coordStr")
            Config.put(STATIC_LOCATION_KEY, "")
            return
        }

        scheduler.periodic(STATIC_TELEPORT_TASK, interval) {
            try {
                teleportToCoordinates(lat, lon, silent = true)
                Logger.i("Static teleport tick → $lat,$lon")
            } catch (e: Exception) {
                Logger.e("Static teleport tick failed: ${e.message}")
            }
        }
    }

    @Command(name = "save", aliases = ["sv"], help = "Save the current location")
    fun save(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Provide a name")
            return
        }
        val name = args[0]

        coroutineScope.launch {
            val coordStr = when {
                args.size == 1 -> Config.get("current_location", "") as String
                args.size == 2 && args[1].contains(",") -> args[1]
                args.size == 3 && args[1].toDoubleOrNull() != null && args[2].toDoubleOrNull() != null ->
                    "${args[1]},${args[2]}"

                args.size > 1 -> getLocationFromNominatimAsync(args.drop(1).joinToString(" "))
                    ?.let { "${it.first},${it.second}" }

                else -> ""
            }

            if (coordStr.isNullOrBlank() || !coordStr.contains(",")) {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Invalid coordinates")
                return@launch
            }

            val (lat, lon) = coordStr.split(",").let {
                it[0].trim().toDouble() to it[1].trim().toDouble()
            }

            if (getLocation(name) != null) {
                updateLocation(name, lat, lon)
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Updated $name")
            } else {
                addLocation(name, lat, lon)
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Saved $name")
            }
        }
    }

    @Command(name = "delete", aliases = ["del"], help = "Delete a saved location")
    fun delete(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Provide a name")
            return
        }
        val name = args.joinToString(" ")
        coroutineScope.launch {
            if (getLocation(name) == null) {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Location not found")
                return@launch
            }
            deleteLocation(name)
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Deleted $name")
        }
    }

    private suspend fun getLocation(name: String): Pair<Double, Double>? =
        withContext(Dispatchers.IO) {
            val dao = GrindrPlus.database.teleportLocationDao()
            dao.getLocation(name)?.let { Pair(it.latitude, it.longitude) }
        }

    private suspend fun addLocation(name: String, lat: Double, lon: Double) =
        withContext(Dispatchers.IO) {
            val dao = GrindrPlus.database.teleportLocationDao()
            dao.upsertLocation(
                com.grindrplus.persistence.model.TeleportLocationEntity(
                    name = name, latitude = lat, longitude = lon
                )
            )
        }

    private suspend fun updateLocation(name: String, lat: Double, lon: Double) =
        withContext(Dispatchers.IO) {
            addLocation(name, lat, lon)
        }

    private suspend fun deleteLocation(name: String) = withContext(Dispatchers.IO) {
        GrindrPlus.database.teleportLocationDao().deleteLocation(name)
    }

    private suspend fun getLocationFromNominatimAsync(location: String): Pair<Double, Double>? =
        withContext(Dispatchers.IO) {
            val url = "https://nominatim.openstreetmap.org/search?q=${Uri.encode(location)}&format=json"
            val request = okhttp3.Request.Builder()
                .url(url)
                .header("User-Agent", getUserAgent())
                .build()

            try {
                OkHttpClient().newCall(request).execute().use { resp ->
                    val body = resp.body?.string() ?: return@withContext null
                    val json = JSONArray(body)
                    if (json.length() == 0) return@withContext null
                    val obj = json.getJSONObject(0)
                    Pair(obj.getDouble("lat"), obj.getDouble("lon"))
                }
            } catch (e: Exception) {
                val msg = "Nominatim error: ${e.message}"
                withContext(Dispatchers.Main) {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, msg)
                }
                Logger.e(msg)
                null
            }
        }

    private suspend fun getNearestLocationNameFromCoords(lat: Double, lon: Double): String? =
        withContext(Dispatchers.IO) {
            val url = "https://nominatim.openstreetmap.org/reverse?lat=$lat&lon=$lon&format=json&addressdetails=1"
            val request = okhttp3.Request.Builder()
                .url(url)
                .header("User-Agent", getUserAgent())
                .build()

            try {
                OkHttpClient().newCall(request).execute().use { resp ->
                    if (!resp.isSuccessful) return@use null
                    val body = resp.body?.string() ?: return@use null
                    val json = JSONObject(body)
                    if (json.has("error")) return@use null

                    val address = json.optJSONObject("address")
                    val display = json.optString("display_name").takeIf { it.isNotBlank() }

                    fun String?.nonEmpty() = this?.takeIf { it.isNotBlank() }

                    val name = when {
                        address?.optString("village").nonEmpty() != null -> address.optString("village")
                        address?.optString("town").nonEmpty() != null -> address.optString("town")
                        address?.optString("city").nonEmpty() != null -> address.optString("city")
                        address?.optString("municipality").nonEmpty() != null -> address.optString("municipality")
                        address?.optString("county").nonEmpty() != null -> address.optString("county")
                        address?.optString("state").nonEmpty() != null -> address.optString("state")
                        address?.optString("country").nonEmpty() != null -> address.optString("country")
                        display != null -> display
                        else -> null
                    }

                    name?.also { Logger.i("Resolved name: $it") } ?: Logger.w("No name")
                    name
                }
            } catch (e: Exception) {
                val msg = "Reverse-geocode error: ${e.message}"
                withContext(Dispatchers.Main) {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, msg)
                }
                Logger.e(msg)
                null
            }
        }

    private fun teleportToCoordinates(lat: Double, lon: Double, silent: Boolean = false) {
        Config.put("current_location", "$lat,$lon")
        val geohash = coordsToGeoHash(lat, lon)

        GrindrPlus.executeAsync {
            try {
                GrindrPlus.httpClient.updateLocation(geohash)
            } catch (e: Exception) {
                Logger.e("Geohash send failed: ${e.message}")
            }
        }

        coroutineScope.launch {
            val cached = LocationCache.get(lat, lon)
            if (cached != null) {
                Logger.i("Teleport to $lat,$lon – $cached")
                return@launch
            }

            val name = getNearestLocationNameFromCoords(lat, lon)
            if (name != null) {
                LocationCache.put(lat, lon, name)
                Logger.i("Teleport to $lat,$lon – $name (fresh)")
            } else {
                Logger.i("Teleport to $lat,$lon – name unavailable")
            }
        }

        if (!silent) {
            GrindrPlus.showToast(Toast.LENGTH_LONG, "Teleported to $lat, $lon")
            Logger.i("Teleported to $lat, $lon")
        }
    }

    private fun getUserAgent(): String {
        val chrome = listOf("120.0.0.0", "119.0.0.0", "118.0.0.0", "117.0.0.0", "116.0.0.0")
        val firefox = listOf("121.0", "120.0", "119.0", "118.0", "117.0")
        val safari = listOf("17.2", "17.1", "17.0", "16.6", "16.5")
        val edge = listOf("120.0.0.0", "119.0.0.0", "118.0.0.0", "117.0.0.0")
        val win = listOf("10.0", "11.0")
        val mac = listOf("10_15_7", "11_7_10", "12_7_2", "13_6_3", "14_2_1")

        return when ((1..5).random()) {
            1 -> "Mozilla/5.0 (Windows NT ${win.random()}; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${chrome.random()} Safari/537.36"
            2 -> "Mozilla/5.0 (Macintosh; Intel Mac OS X ${mac.random()}) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${chrome.random()} Safari/537.36"
            3 -> {
                val v = firefox.random()
                val platform = if ((1..2).random() == 1) "Windows NT ${win.random()}; Win64; x64"
                else "Macintosh; Intel Mac OS X ${mac.random().replace("_", ".")}"
                "Mozilla/5.0 ($platform; rv:$v) Gecko/20100101 Firefox/$v"
            }
            4 -> {
                val s = safari.random()
                val m = mac.random()
                val w = "605.1.${(10..20).random()}"
                "Mozilla/5.0 (Macintosh; Intel Mac OS X $m) AppleWebKit/$w (KHTML, like Gecko) Version/$s Safari/$w"
            }
            5 -> "Mozilla/5.0 (Windows NT ${win.random()}; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${edge.random()} Safari/537.36 Edg/${edge.random()}"
            else -> chrome.random()
        }
    }

    object LocationCache {
        private const val KEY_COORDS = "cached_coords"
        private const val KEY_NAME = "cached_name"
        private const val KEY_TS = "cached_ts"

        private val prefs get() = GrindrPlus.context.getSharedPreferences("grindrplus_location_cache", 0)

        fun get(lat: Double, lon: Double, maxAgeMs: Long = 24 * 60 * 60 * 1000): String? {
            val saved = prefs.getString(KEY_COORDS, null) ?: return null
            if (saved != "$lat,$lon") return null
            val ts = prefs.getLong(KEY_TS, 0)
            if ((System.currentTimeMillis() - ts) > maxAgeMs) return null
            return prefs.getString(KEY_NAME, null)
        }

        fun put(lat: Double, lon: Double, name: String) {
            prefs.edit()
                .putString(KEY_COORDS, "$lat,$lon")
                .putString(KEY_NAME, name)
                .putLong(KEY_TS, System.currentTimeMillis())
                .apply()
        }

        fun clear() {
            prefs.edit()
                .remove(KEY_COORDS)
                .remove(KEY_NAME)
                .remove(KEY_TS)
                .apply()
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\Profile.kt --- 
package com.grindrplus.commands

import android.annotation.SuppressLint
import android.app.AlertDialog
import android.graphics.Color
import android.widget.LinearLayout
import android.widget.Toast
import androidx.appcompat.widget.AppCompatTextView
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Constants.NEWLINE
import com.grindrplus.core.Utils.openChat
import com.grindrplus.core.Utils.openProfile
import com.grindrplus.ui.Utils.copyToClipboard
import com.grindrplus.ui.Utils.formatEpochSeconds

class Profile(
    recipient: String,
    sender: String
) : CommandModule("Profile", recipient, sender) {

    @Command("open", help = "Open a user's profile")
    fun open(args: List<String>) {
        if (args.isNotEmpty()) {
            return openProfile(args[0])
        } else {
            GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Please provide valid ID"
            )
        }
    }

    @Command("block", help = "Block a user")
    fun block(args: List<String>) {
        GrindrPlus.httpClient.blockUser(
            if (args.isNotEmpty()) args[0] else sender,
            silent = args.contains("silent"),
            reflectInDb = !args.contains("no-reflect")
        )
    }

    @Command("clear", aliases = ["reset"], help = "Reset chat with a user")
    fun reset(args: List<String>) {
        val profileId = if (args.isNotEmpty()) args[0] else sender
        GrindrPlus.shouldTriggerAntiblock = false
        block(listOf(profileId, "silent", "no-reflect"))
        Thread.sleep(200)
        unblock(listOf(profileId, "silent", "no-reflect"))
        Thread.sleep(200)
        openChat("$recipient:$profileId")
        Thread.sleep(200)
        GrindrPlus.shouldTriggerAntiblock = true
    }

    @Command("unblock", help = "Unblock a user")
    fun unblock(args: List<String>) {
        GrindrPlus.httpClient.unblockUser(
            if (args.isNotEmpty()) args[0] else sender,
            silent = args.contains("silent"),
            reflectInDb = !args.contains("no-reflect")
        )
    }

    @Command("chat", help = "Open chat with a user")
    fun chat(args: List<String>) {
        if (args.isNotEmpty()) {
            return openChat("$recipient:${args[0]}")
        } else {
            GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Please provide valid ID"
            )
        }
    }

    @Command("favorite", aliases = ["fav", "favourite"], help = "Favorite a user")
    fun favorite(args: List<String>) {
        val profileId = if (args.isNotEmpty()) args[0] else sender
        GrindrPlus.httpClient.favorite(profileId, silent = false)
    }

    @Command("unfavorite", aliases = ["unfav", "unfavourite"], help = "Unfavorite a user")
    fun unfavorite(args: List<String>) {
        if (args.isNotEmpty() && args[0] == "all") {
            GrindrPlus.executeAsync {
                val favorites = GrindrPlus.httpClient.getFavorites()
                Thread.sleep(1000)
                favorites.forEach { GrindrPlus.httpClient.unfavorite(it.first, silent = true) }
            }
        }
        val profileId = if (args.isNotEmpty()) args[0] else sender
        GrindrPlus.httpClient.unfavorite(profileId, silent = false)
    }

    @Command("blocks", help = "Get a list of blocked users")
    fun blocks(args: List<String>) {
        GrindrPlus.executeAsync {
            val blocks = GrindrPlus.httpClient.getBlocks()
            val blockList = blocks.joinToString("\n") { "• $it" }
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                val textView = AppCompatTextView(activity).apply {
                    text = blockList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }

                dialogView.addView(textView)

                AlertDialog.Builder(activity)
                    .setTitle("GrindrPlus")
                    .setView(dialogView)
                    .setPositiveButton("Copy") { _, _ ->
                        copyToClipboard("Coords", blocks.joinToString("\n") { it })
                    }
                    .setNegativeButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNeutralButton("SomeFUnction") { _, _ ->
                        val file = GrindrPlus.context.getFileStreamPath("blocks.txt")
                        file.writeText(blocks.joinToString("\n") { it })
                        GrindrPlus.showToast(
                            Toast.LENGTH_LONG,
                            "Exported blocked users. Use Mod Settings to access the file!"
                        )
                    }
                    .create()
                    .show()
            }
        }
    }

    @Command("favorites", aliases = ["favourites", "favs"], help = "Get a list of favorited users")
    fun favorites(args: List<String>) {
        GrindrPlus.executeAsync {
            val favorites = GrindrPlus.httpClient.getFavorites()
            val favoriteList = favorites.joinToString("\n") { "• ${it.first}" }

            val favoriteListExport = favorites.joinToString("\n") {
                val sanitizedNote = it.second.replace("\r\n", NEWLINE).replace("\r", NEWLINE).replace("\n", NEWLINE)
                val sanitizedPhone = it.third.replace("\r\n", NEWLINE).replace("\r", NEWLINE).replace("\n", NEWLINE)
                "${it.first}|||$sanitizedNote|||$sanitizedPhone"
            }

            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                val textView = AppCompatTextView(activity).apply {
                    text = favoriteList
                    textSize = 14f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply {
                        setMargins(0, 20, 0, 0)
                    }
                }

                dialogView.addView(textView)

                AlertDialog.Builder(activity)
                    .setTitle("Favorited users")
                    .setView(dialogView)
                    .setPositiveButton("Copy") { _, _ ->
                        copyToClipboard("Favorited users", favoriteList)
                    }
                    .setNegativeButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .setNeutralButton("Export") { _, _ ->
                        val file = GrindrPlus.context.getFileStreamPath("favorites.txt")
                        file.writeText(favoriteListExport)
                        GrindrPlus.showToast(
                            Toast.LENGTH_LONG,
                            "Exported favorited users. Use Mod Settings to access the file!"
                        )
                    }
                    .create()
                    .show()
            }
        }
    }

    @Command("report", help = "Report a user")
    fun report(args: List<String>) {
        val profileId = if (args.isNotEmpty()) args[0] else sender
        val reason = if (args.size > 1) args[1] else "SPAM"
        GrindrPlus.httpClient.reportUser(profileId, reason)
    }

    @SuppressLint("SetTextI18n")
    @Command("id", help = "Get and copy profile IDs")
    fun id(args: List<String>) {
        val accountCreationTime = try {
            formatEpochSeconds(GrindrPlus.spline.invert(sender.toDouble()).toLong())
        } catch (e: Exception) {
            "Unknown"
        }

        // Ensure we're on the main thread for UI operations
        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            try {
                val dialogView = LinearLayout(activity).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(60, 40, 60, 40)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                val textView = AppCompatTextView(activity).apply {
                    text = "• Your ID: $recipient\n• Profile ID: $sender\n• Estimated creation: $accountCreationTime"
                    textSize = 18f
                    setTextColor(Color.WHITE)
                    setPadding(20, 20, 20, 20)
                    layoutParams = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                }

                dialogView.addView(textView)

                val dialog = AlertDialog.Builder(activity)
                    .setTitle("Profile IDs")
                    .setView(dialogView)
                    .setPositiveButton("Copy my ID") { _, _ ->
                        copyToClipboard("Your ID", recipient)
                    }
                    .setNegativeButton("Copy profile ID") { _, _ ->
                        copyToClipboard("Profile ID", sender)
                    }
                    .setNeutralButton("Close") { dialog, _ ->
                        dialog.dismiss()
                    }
                    .create()

                dialog.show()

                // Set long click listeners after dialog is shown
                dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.setOnLongClickListener {
                    copyToClipboard("Your ID", " $recipient")
                    dialog.dismiss()
                    true
                }

                dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.setOnLongClickListener {
                    copyToClipboard("Profile ID", " $sender")
                    dialog.dismiss()
                    true
                }

            } catch (e: Exception) {
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Error displaying profile IDs: ${e.message}")
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\Utils.kt --- 
package com.grindrplus.commands

import android.app.AlertDialog
import android.graphics.Color
import android.widget.LinearLayout
import android.widget.Toast
import androidx.appcompat.widget.AppCompatTextView
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import java.io.BufferedReader
import java.io.InputStreamReader

class Utils(
    recipient: String,
    sender: String
) : CommandModule("Utils", recipient, sender) {

    @Command("shell", help = "Run a shell command and display output")
    fun shell(args: List<String>) {
        if (args.isEmpty()) {
            GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Please provide a shell command to execute"
            )
            return
        }

        val command = args.joinToString(" ")
        val output = StringBuilder()

        try {
            val process = Runtime.getRuntime().exec(command)
            val reader = BufferedReader(InputStreamReader(process.inputStream))
            var line: String? = reader.readLine()

            while (line != null) {
                output.append(line).append("\n")
                line = reader.readLine()
            }
            reader.close()

            process.waitFor()

        } catch (e: Exception) {
            output.append("Error executing command: ${e.message}")
        }

        GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
            val dialogView = LinearLayout(activity).apply {
                orientation = LinearLayout.VERTICAL
                setPadding(60, 40, 60, 40)
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
            }

            val textView = AppCompatTextView(activity).apply {
                text = output.toString()
                textSize = 14f
                setTextColor(Color.WHITE)
                setPadding(20, 20, 20, 20)
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                ).apply {
                    setMargins(0, 20, 0, 0)
                }
            }

            dialogView.addView(textView)

            AlertDialog.Builder(activity)
                .setTitle("Output")
                .setView(dialogView)
                .setPositiveButton("Close") { dialog, _ ->
                    dialog.dismiss()
                }
                .create()
                .show()
        }
    }

    @Command("prefix", help = "Change the command prefix (default: /)")
    fun prefix(args: List<String>) {
        val prefix = Config.get("command_prefix", "/")
        when {
            args.isEmpty() -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "The current command prefix is $prefix"
            )
            args[0].isBlank() -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Invalid command prefix"
            )
            args[0] == "reset" || args[0] == "clear" -> {
                Config.put("command_prefix", "/")
                GrindrPlus.showToast(
                    Toast.LENGTH_LONG,
                    "Command prefix reset to /",
                )
            }
            args[0].length > 1 -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Command prefix must be a single character"
            )
            !args[0].matches(Regex("[^a-zA-Z0-9]")) -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Command prefix must be a special character (no letters or numbers)"
            )
            args[0] == prefix -> GrindrPlus.showToast(
                Toast.LENGTH_LONG,
                "Command prefix is already set to ${args[0]}"
            )
            else -> {
                Config.put("command_prefix", args[0])
                GrindrPlus.showToast(
                    Toast.LENGTH_LONG,
                    "Command prefix set to ${args[0]}"
                )
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\xCommandHandler.kt --- 
/*
package com.grindrplus.commands

import android.app.AlertDialog
import com.grindrplus.GrindrPlus

class CommandHandler(
    recipient: String,
    sender: String = ""
) {
    private val commandModules: MutableList<CommandModule> = mutableListOf()

    init {
        commandModules.add(Location(recipient, sender))
        commandModules.add(Profile(recipient, sender))
        commandModules.add(Utils(recipient, sender))
        commandModules.add(Database(recipient, sender))
    }

    fun handle(input: String) {
        val args = input.trim().split("\\s+".toRegex()).filter { it.isNotEmpty() }
        val command = args.firstOrNull() ?: return

        if (command == "help") {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                AlertDialog.Builder(activity)
                    .setTitle("Help")
                    .setMessage(commandModules.joinToString("\n\n") { it.getHelp() })
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .create()
                    .show()
            }
        }

        for (module in commandModules) {
            if (module.handle(command, args.drop(1))) break
        }
    }
}*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\commands\xCommandModule.kt --- 
/*
package com.grindrplus.commands

import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger

abstract class CommandModule(
    protected val name: String,
    protected val recipient: String,
    protected val sender: String
) {
    fun handle(inputCommand: String, args: List<String>): Boolean {
        val commandMethod = this::class.java.methods.firstOrNull {
            val annotation = it.getAnnotation(Command::class.java)
            annotation != null
                    && (annotation.name == inputCommand || inputCommand in annotation.aliases)
        }

        return commandMethod != null && try {
            commandMethod.invoke(this, args)
            true
        } catch (e: Exception) {
            val message = "Unable to execute command. Check logs for more information."
            GrindrPlus.showToast(Toast.LENGTH_LONG, message)
            Logger.apply {
                e("An error occurred while executing the command: ${e.message ?: "Unknown error"}")
                writeRaw(e.stackTraceToString())
            }
            false
        }
    }

    fun getHelp(): String {
        val commands = this::class.java.methods.mapNotNull { method ->
            val command = method.getAnnotation(Command::class.java)
            command?.let {
                if (it.aliases.isEmpty()) {
                    "${it.name}: ${it.help}"
                } else {
                    "${it.name} (${it.aliases.joinToString(", ")}): ${it.help}"
                }
            }
        }

        return "Help for $name:\n${commands.joinToString("\n") { command -> "- $command" }}"
    }
}*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\Config.kt --- 
package com.grindrplus.core

import android.content.Context
import com.grindrplus.GrindrPlus
import com.grindrplus.manager.utils.AppCloneUtils
import org.json.JSONObject
import java.io.IOException

object Config {
    private var localConfig = JSONObject()
    private var currentPackageName = Constants.GRINDR_PACKAGE_NAME
    private val GLOBAL_SETTINGS = listOf("first_launch", "analytics", "discreet_icon", "material_you", "debug_mode", "disable_permission_checks", "custom_manifest", "maps_api_key")

    fun initialize(packageName: String? = null) {
        if (packageName != null) {
            Logger.d("Initializing config for package: $packageName", LogSource.MANAGER)
        }

        localConfig = readRemoteConfig()

        if (packageName != null) {
            currentPackageName = packageName
        }

        migrateToMultiCloneFormat()
    }

    private fun isGlobalSetting(name: String): Boolean {
        return name in GLOBAL_SETTINGS
    }

    private fun migrateToMultiCloneFormat() {
        if (!localConfig.has("clones")) {
            Logger.d("Migrating to multi-clone format", LogSource.MANAGER)
            val cloneSettings = JSONObject()

            if (localConfig.has("hooks")) {
                val defaultPackageConfig = JSONObject()
                defaultPackageConfig.put("hooks", localConfig.get("hooks"))
                cloneSettings.put(Constants.GRINDR_PACKAGE_NAME, defaultPackageConfig)

                val keysToMove = mutableListOf<String>()
                val keys = localConfig.keys()
                while (keys.hasNext()) {
                    val key = keys.next()
                    if (key != "hooks" && !isGlobalSetting(key)) {
                        defaultPackageConfig.put(key, localConfig.get(key))
                        keysToMove.add(key)
                    }
                }
                keysToMove.forEach { localConfig.remove(it) }
            } else {
                cloneSettings.put(Constants.GRINDR_PACKAGE_NAME, JSONObject().put("hooks", JSONObject()))
            }

            localConfig.put("clones", cloneSettings)
            writeRemoteConfig(localConfig)
        }

        ensurePackageExists(currentPackageName)
    }

    fun setCurrentPackage(packageName: String) {
        Logger.d("Setting current package to $packageName", LogSource.MANAGER)
        currentPackageName = packageName
        ensurePackageExists(packageName)
    }

    fun getCurrentPackage(): String {
        return currentPackageName
    }

    private fun ensurePackageExists(packageName: String) {
        Logger.d("Ensuring package $packageName exists in config", LogSource.MANAGER)
        val clones = localConfig.optJSONObject("clones") ?: JSONObject().also {
            localConfig.put("clones", it)
        }

        if (!clones.has(packageName)) {
            clones.put(packageName, JSONObject().put("hooks", JSONObject()))
            writeRemoteConfig(localConfig)
        }
    }

    fun getAvailablePackages(context: Context): List<String> {
        Logger.d("Getting available packages", LogSource.MANAGER)
        val installedClones = listOf(Constants.GRINDR_PACKAGE_NAME) + AppCloneUtils.getExistingClones(context)
        val clones = localConfig.optJSONObject("clones") ?: return listOf(Constants.GRINDR_PACKAGE_NAME)

        return installedClones.filter { pkg ->
            clones.has(pkg)
        }
    }

    fun readRemoteConfig(): JSONObject {
        return try {
            GrindrPlus.bridgeClient.getConfig()
        } catch (e: Exception) {
            Logger.e("Failed to read config file: ${e.message}", LogSource.MANAGER)
            Logger.writeRaw(e.stackTraceToString())
            JSONObject().put("clones", JSONObject().put(
                Constants.GRINDR_PACKAGE_NAME,
                JSONObject().put("hooks", JSONObject()))
            )
        }
    }

    fun writeRemoteConfig(json: JSONObject) {
        try {
            GrindrPlus.bridgeClient.setConfig(json)
        } catch (e: IOException) {
            Logger.e("Failed to write config file: ${e.message}", LogSource.MANAGER)
            Logger.writeRaw(e.stackTraceToString())
        }
    }

    private fun getCurrentPackageConfig(): JSONObject {
        val clones = localConfig.optJSONObject("clones")
            ?: JSONObject().also { localConfig.put("clones", it) }

        return clones.optJSONObject(currentPackageName)
            ?: JSONObject().also { clones.put(currentPackageName, it) }
    }

    fun put(name: String, value: Any) {
        Logger.d("Setting $name to $value", LogSource.MANAGER)
        if (isGlobalSetting(name)) {
            localConfig.put(name, value)
        } else {
            val packageConfig = getCurrentPackageConfig()
            packageConfig.put(name, value)
        }

        writeRemoteConfig(localConfig)
    }

    fun get(name: String, default: Any, autoPut: Boolean = false): Any {
        val rawValue = if (isGlobalSetting(name)) {
            localConfig.opt(name)
        } else {
            val packageConfig = getCurrentPackageConfig()
            packageConfig.opt(name)
        }

        if (rawValue == null) {
            if (autoPut) put(name, default)
            return default
        }

        return when (default) {
            is Number -> {
                if (rawValue is String) {
                    try {
                        rawValue.toInt()
                    } catch (_: NumberFormatException) {
                        try {
                            rawValue.toDouble()
                        } catch (_: NumberFormatException) {
                            default
                        }
                    }
                } else {
                    rawValue as? Number ?: default
                }
            }
            else -> rawValue
        }
    }

    fun setHookEnabled(hookName: String, enabled: Boolean) {
        Logger.d("Setting hook $hookName to $enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks")
            ?: JSONObject().also { packageConfig.put("hooks", it) }

        hooks.optJSONObject(hookName)?.put("enabled", enabled)
        writeRemoteConfig(localConfig)
    }

    fun isHookEnabled(hookName: String): Boolean {
        Logger.d("Checking if hook $hookName is enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks") ?: return false
        return hooks.optJSONObject(hookName)?.getBoolean("enabled") == true
    }

    fun setTaskEnabled(taskId: String, enabled: Boolean) {
        Logger.d("Setting task $taskId to $enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks")
            ?: JSONObject().also { packageConfig.put("tasks", it) }

        tasks.optJSONObject(taskId)?.put("enabled", enabled)
        writeRemoteConfig(localConfig)
    }

    fun isTaskEnabled(taskId: String): Boolean {
        Logger.d("Checking if task $taskId is enabled", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks") ?: return false
        return tasks.optJSONObject(taskId)?.getBoolean("enabled") == true
    }

    fun getTasksSettings(): Map<String, Pair<String, Boolean>> {
        Logger.d("Getting tasks settings", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks") ?: return emptyMap()
        val map = mutableMapOf<String, Pair<String, Boolean>>()

        val keys = tasks.keys()
        while (keys.hasNext()) {
            val key = keys.next()
            val obj = tasks.getJSONObject(key)
            map[key] = Pair(obj.getString("description"), obj.getBoolean("enabled"))
        }

        return map
    }

    fun initTaskSettings(taskId: String, description: String, state: Boolean) {
        Logger.d("Initializing task settings for $taskId", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val tasks = packageConfig.optJSONObject("tasks")
            ?: JSONObject().also { packageConfig.put("tasks", it) }

        if (tasks.optJSONObject(taskId) == null) {
            tasks.put(taskId, JSONObject().apply {
                put("description", description)
                put("enabled", state)
            })

            writeRemoteConfig(localConfig)
        }
    }

    fun initHookSettings(name: String, description: String, state: Boolean) {
        Logger.d("Initializing hook settings for $name", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks")
            ?: JSONObject().also { packageConfig.put("hooks", it) }

        if (hooks.optJSONObject(name) == null) {
            hooks.put(name, JSONObject().apply {
                put("description", description)
                put("enabled", state)
            })

            writeRemoteConfig(localConfig)
        }
    }

    fun getHooksSettings(): Map<String, Pair<String, Boolean>> {
        Logger.d("Getting hooks settings", LogSource.MANAGER)
        val packageConfig = getCurrentPackageConfig()
        val hooks = packageConfig.optJSONObject("hooks") ?: return emptyMap()
        val map = mutableMapOf<String, Pair<String, Boolean>>()

        val keys = hooks.keys()
        while (keys.hasNext()) {
            val key = keys.next()
            val obj = hooks.getJSONObject(key)
            map[key] = Pair(obj.getString("description"), obj.getBoolean("enabled"))
        }

        return map
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\Constants.kt --- 
package com.grindrplus.core

object Constants {
    const val NEWLINE = "GRINDRPLUS_NEWLINE"
    const val GRINDR_PACKAGE_NAME = "com.grindrapp.android"
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\CoroutineHelper.kt --- 
package com.grindrplus.core

import com.grindrplus.GrindrPlus
import de.robv.android.xposed.XposedHelpers
import java.lang.reflect.Proxy

object CoroutineHelper {

    private val BuildersKt = XposedHelpers.findClass(
        "kotlinx.coroutines.BuildersKt",
        GrindrPlus.classLoader
    )
    private val Function2 = XposedHelpers.findClass(
        "kotlin.jvm.functions.Function2",
        GrindrPlus.classLoader
    )
    private val EmptyCoroutineContextInstance = let {
        val emptyCoroutineContext = XposedHelpers.findClass(
            "kotlin.coroutines.EmptyCoroutineContext",
            GrindrPlus.classLoader
        )
        XposedHelpers.getStaticObjectField(emptyCoroutineContext, "INSTANCE")
    }

    fun callSuspendFunction(function: (continuation: Any) -> Any?): Any {
        val proxy = Proxy.newProxyInstance(
            GrindrPlus.classLoader,
            arrayOf(Function2)
        ) { _, _, args ->
            function(args[1])
        }
        return XposedHelpers.callStaticMethod(
            BuildersKt,
            "runBlocking",
            EmptyCoroutineContextInstance,
            proxy
        )
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\CredentialsLogger.kt --- 
package com.grindrplus.core

import android.os.Environment
import android.util.Base64
import com.grindrplus.GrindrPlus
import com.grindrplus.persistence.GPDatabase
import com.grindrplus.persistence.model.LogEntity
import org.json.JSONObject
import java.io.File

object CredentialsLogger {
    private val logFile = File(
        Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
        "GrindrAccess_Info.txt"
    )
    private var lastAuthToken: String? = null

    private fun getProfileIdFromToken(token: String): String? {
        return try {
            val parts = token.split(".")
            if (parts.size < 2) return null
            val payload = String(Base64.decode(parts[1], Base64.URL_SAFE), Charsets.UTF_8)
            JSONObject(payload).getString("profileId")
        } catch (e: Exception) {
            Logger.e("Could not extract profileId from token: ${e.message}")
            null
        }
    }

    fun log(authToken: String?, lDeviceInfo: String?, userAgent: String?) {
        if (authToken.isNullOrEmpty() || !authToken.startsWith("Grindr3 ")) return

        val cleanAuthToken = authToken.substringAfter("Grindr3 ")
        if (cleanAuthToken == lastAuthToken) return
            try {
                val profileId = getProfileIdFromToken(cleanAuthToken)

                val logMessage = buildString {
                    append("### Latest Grindr Credentials ###\n\n")
                    append("# This file is automatically updated when your session token changes.\n")
                    append("# Use these values in your grindr-access scripts.\n\n")
                    append("profileId: $profileId\n\n")
                    append("authToken: $cleanAuthToken\n\n")
                    append("l-device-info: $lDeviceInfo\n\n")
                    append("user-agent: $userAgent\n")
                }

                logFile.writeText(logMessage)
                lastAuthToken = cleanAuthToken

                // Also save to database
                GrindrPlus.executeAsync {
                    val entity = LogEntity(
                        timestamp = System.currentTimeMillis(),
                        log_type = "credentials",
                        profile_id = profileId,
                        auth_token = cleanAuthToken,
                        device_info = lDeviceInfo,
                        user_agent = userAgent
                    )
                    GrindrPlus.database.logDao().insert(entity)
                }
            } catch (e: Exception) {
                Logger.e("Failed to write credentials: ${e.message}")
            }
        }
    }
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\DatabaseHelper.kt --- 
package com.grindrplus.core

import android.content.ContentValues
import android.content.Context
import android.database.Cursor
import android.database.sqlite.SQLiteDatabase
import androidx.sqlite.db.SimpleSQLiteQuery

import androidx.sqlite.db.SupportSQLiteDatabase
import androidx.sqlite.db.SupportSQLiteQuery
import com.grindrplus.GrindrPlus

object DatabaseHelper {
    private fun getGrindrPlusDatabase(): SupportSQLiteDatabase {
        return GrindrPlus.database.openHelper.writableDatabase
    }

    // NEW: Query GrindrPlus database
    fun queryGrindrPlus(query: String, args: Array<String>? = null): List<Map<String, Any>> {
        val database: SupportSQLiteDatabase = getGrindrPlusDatabase()
        val sqlQuery: SupportSQLiteQuery = if (args != null) {
            SimpleSQLiteQuery(query, args)
        } else {
            SimpleSQLiteQuery(query)
        }

        val cursor = database.query(sqlQuery) as Cursor
        return cursor.use {
            buildList {
                if (cursor.moveToFirst()) {
                    do {
                        val row: Map<String, Any> = buildMap {
                            for (i in 0 until cursor.columnCount) {
                                val columnName = cursor.getColumnName(i)
                                put(columnName, when (cursor.getType(i)) {
                                    Cursor.FIELD_TYPE_INTEGER -> cursor.getInt(i)
                                    Cursor.FIELD_TYPE_FLOAT -> cursor.getFloat(i)
                                    Cursor.FIELD_TYPE_STRING -> cursor.getString(i)
                                    Cursor.FIELD_TYPE_BLOB -> cursor.getBlob(i)
                                    Cursor.FIELD_TYPE_NULL -> "NULL"
                                    else -> "UNKNOWN"
                                })
                            }
                        }
                        add(row)
                    } while (cursor.moveToNext())
                }
            }
        }
    }


    // NEW: Execute on GrindrPlus database
    fun executeGrindrPlus(sql: String, args: Array<Any?>? = null) {
        val database = getGrindrPlusDatabase()
        if (args != null) {
            database.execSQL(sql, args)
        } else {
            database.execSQL(sql)
        }
    }

    // NEW: Helper for single integer queries
    fun querySingleInt(query: String): Int =
        getDatabase().use { database ->
            database.rawQuery(query, null).use { cursor ->
                if (cursor.moveToFirst()) cursor.getInt(0) else 0
            }
        }

    private fun getDatabase(): SQLiteDatabase {
        val context = GrindrPlus.context
        val databases = context.databaseList()
        val grindrUserDb = databases.firstOrNull {
            it.contains("grindr_user") && it.endsWith(".db") }
            ?: throw IllegalStateException("No Grindr user database found!").also {
                Logger.apply {
                    e(it.message!!)
                    writeRaw("Available databases:\n" +
                            "${databases.joinToString("\n") { "  $it" }}\n")
                }
            }
        return context.openOrCreateDatabase(grindrUserDb.also {
            Logger.d("Using database: $it") }, Context.MODE_PRIVATE, null)
    }

    fun query(query: String, args: Array<String>? = null): List<Map<String, Any>> =
        getDatabase().use { database ->
            database.rawQuery(query, args).use { cursor ->
                buildList {
                    if (cursor.moveToFirst()) {
                        do {
                            val row = buildMap<String, Any> {
                                cursor.columnNames.forEach { column ->
                                    val idx = cursor.getColumnIndexOrThrow(column)
                                    put(column, when (cursor.getType(idx)) {
                                        Cursor.FIELD_TYPE_INTEGER -> cursor.getInt(idx)
                                        Cursor.FIELD_TYPE_FLOAT   -> cursor.getFloat(idx)
                                        Cursor.FIELD_TYPE_STRING  -> cursor.getString(idx)
                                        Cursor.FIELD_TYPE_BLOB    -> cursor.getBlob(idx)
                                        Cursor.FIELD_TYPE_NULL    -> "NULL"
                                        else                      -> "UNKNOWN"
                                    })
                                }
                            }
                            add(row)
                        } while (cursor.moveToNext())
                    }
                }
            }
        }


    fun insert(table: String, values: ContentValues): Long {
        val database = getDatabase()
        val rowId = database.insert(table, null, values)
        database.close()
        return rowId
    }

    fun update(table: String, values: ContentValues, whereClause: String?, whereArgs: Array<String>?): Int {
        val database = getDatabase()
        val rowsAffected = database.update(table, values, whereClause, whereArgs)
        database.close()
        return rowsAffected
    }

    fun delete(table: String, whereClause: String?, whereArgs: Array<String>?): Int {
        val database = getDatabase()
        val rowsDeleted = database.delete(table, whereClause, whereArgs)
        database.close()
        return rowsDeleted
    }

    fun execute(sql: String) {
        val database = getDatabase()
        database.execSQL(sql)
        database.close()
    }

    fun getRecentDeletions(limit: Int = 50): List<Map<String, Any>> {
        return query("""
        SELECT 
            id,
            original_table_name,
            datetime(deleted_at, 'unixepoch') as deleted_time,
            row_primary_key,
            delete_trigger,
            substr(row_data, 1, 100) as data_preview
        FROM universal_deleted_data 
        ORDER BY deleted_at DESC 
        LIMIT $limit
    """, emptyArray())
    }

    fun getDeletionStats(): List<Map<String, Any>> {
        return query("""
        SELECT 
            original_table_name,
            COUNT(*) as deletion_count,
            datetime(MAX(deleted_at), 'unixepoch') as latest_deletion
        FROM universal_deleted_data 
        GROUP BY original_table_name 
        ORDER BY deletion_count DESC
    """, emptyArray())
    }

    fun clearOldDeletions(daysToKeep: Int = 30) {
        execute("""
        DELETE FROM universal_deleted_data 
        WHERE deleted_at < strftime('%s','now') - (${daysToKeep} * 24 * 60 * 60)
    """)
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\EventManager.kt --- 
package com.grindrplus.core

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.launch
import org.json.JSONObject

data class ServerNotificationReceived(
    val typeValue: String,
    val notificationId: String?,
    val payload: JSONObject?,
    val status: Int?,
    val refValue: String?
)

object EventManager {
    private val eventScope = CoroutineScope(Dispatchers.IO)

    private val _serverNotifications = MutableSharedFlow<ServerNotificationReceived>(
        replay = 0,
        extraBufferCapacity = 100
    )
    val serverNotifications: SharedFlow<ServerNotificationReceived> = _serverNotifications.asSharedFlow()

    fun emitServerNotification(
        typeValue: String,
        notificationId: String?,
        payload: JSONObject?,
        status: Int?,
        refValue: String?
    ) {
        eventScope.launch {
            try {
                val notification = ServerNotificationReceived(
                    typeValue, notificationId, payload, status, refValue
                )
                _serverNotifications.emit(notification)
                Logger.d("Server notification event emitted: $typeValue", LogSource.MODULE)
            } catch (e: Exception) {
                Logger.e("Failed to emit server notification event: ${e.message}", LogSource.MODULE)
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\HttpLogger.kt --- 
package com.grindrplus.core

import com.grindrplus.GrindrPlus
import com.grindrplus.persistence.GPDatabase
import com.grindrplus.persistence.model.LogEntity
import okhttp3.Request
import okhttp3.Response
import okio.Buffer

object HttpLogger {
    private fun formatHeaders(headers: okhttp3.Headers): String {
        return headers.toMultimap().entries.joinToString("\n") { (key, values) ->
            "    $key: ${values.joinToString(", ")}"
        }.ifEmpty { "    (No headers)" }
    }

    private fun getRequestBody(request: Request): String {
        return try {
            val buffer = Buffer()
            request.body?.writeTo(buffer)
            buffer.readUtf8()
        } catch (e: Exception) {
            "(Error reading body: ${e.message})"
        }
    }

    fun log(request: Request, response: Response) {
        if (!(Config.get("enable_http_logging", false) as Boolean)) return

        GPDatabase.DatabaseManager.executeWhenReady {
            try {
                val responseBody = response.peekBody(Long.MAX_VALUE).string()

                GrindrPlus.executeAsync {
                    val entity = LogEntity(
                        timestamp = System.currentTimeMillis(),
                        log_type = "http",
                        url = request.url.toString(),
                        method = request.method,
                        request_headers = formatHeaders(request.headers),
                        request_body = if (request.body != null) getRequestBody(request) else null,
                        response_code = response.code,
                        response_headers = formatHeaders(response.headers),
                        response_body = responseBody.takeIf { it.isNotEmpty() }
                    )
                    GrindrPlus.database.logDao().insert(entity)
                }
            } catch (e: Exception) {
                Logger.e("Failed to log HTTP request: ${e.message}")
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\InstanceManager.kt --- 
package com.grindrplus.core

import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.findClass

class InstanceManager(private val classLoader: ClassLoader) {
    private val instances = mutableMapOf<String, Any>()
    private val callbacks = mutableMapOf<String, ((Any) -> Unit)?>()

    fun hookClassConstructors(vararg classNames: String) {
        classNames.forEach { className ->
            val clazz = findClass(className, classLoader)
            clazz.hookConstructor(HookStage.AFTER) { param ->
                val instance = param.thisObject()
                instances[className] = instance
                callbacks[className]?.invoke(instance)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun <T : Any> getInstance(className: String): T? {
        return instances[className] as? T
    }

    fun setCallback(className: String, callback: ((Any) -> Unit)?) {
        callbacks[className] = callback
        instances[className]?.let { callback?.invoke(it) }
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\Logger.kt --- 
package com.grindrplus.core

import android.annotation.SuppressLint
import android.content.Context
import com.grindrplus.BuildConfig
import com.grindrplus.bridge.BridgeClient
import com.grindrplus.utils.Hook
import com.grindrplus.utils.Task
import timber.log.Timber
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.concurrent.ConcurrentHashMap

enum class LogLevel { DEBUG, INFO, WARNING, ERROR, SUCCESS }
enum class LogSource { MODULE, MANAGER, HOOK, TASK, BRIDGE, UNKNOWN, HTTP, DB }

@SuppressLint("StaticFieldLeak", "ConstantLocale")
object Logger {
    private const val TAG = "GrindrPlus"
    private var isModuleContext = false
    private var bridgeClient: BridgeClient? = null
    private val hookPrefixes = ConcurrentHashMap<String, String>()
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())

    fun initialize(context: Context, bridge: BridgeClient, isModule: Boolean) {
        bridgeClient = bridge
        isModuleContext = isModule

        if (Timber.forest().isEmpty()) {
            Timber.plant(Timber.DebugTree())
        }
    }

    fun registerHookPrefix(subName: String, prefix: String = subName) {
        hookPrefixes[subName] = prefix
    }

    fun unregisterHookPrefix(subName: String) {
        hookPrefixes.remove(subName)
    }

    fun d(message: String, source: LogSource? = null, subName: String? = null) {
        if (!debugEnabled) return
        log(message, LogLevel.DEBUG, source ?: getDefaultSource(), subName)
    }

    fun i(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.INFO, source ?: getDefaultSource(), subName)

    fun w(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.WARNING, source ?: getDefaultSource(), subName)

    fun e(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.ERROR, source ?: getDefaultSource(), subName)

    fun s(message: String, source: LogSource? = null, subName: String? = null) =
        log(message, LogLevel.SUCCESS, source ?: getDefaultSource(), subName)

    fun log(
        message: String,
        level: LogLevel = LogLevel.INFO,
        source: LogSource = LogSource.UNKNOWN,
        subName: String? = null
    ) {
        val priorityChar = when(level) {
            LogLevel.DEBUG -> "V"
            LogLevel.INFO -> "I"
            LogLevel.WARNING -> "W"
            LogLevel.ERROR -> "E"
            LogLevel.SUCCESS -> "S"
        }

        val timestamp = dateFormat.format(Date())
        val sourceName = source.toString().lowercase()
        val conciseMessage = if (subName != null) {
            "$priorityChar/$timestamp/$sourceName/$subName: $message"
        } else {
            "$priorityChar/$timestamp/$sourceName: $message"
        }

        val logcatMessage = buildLogcatMessage(source, subName, message, level == LogLevel.SUCCESS)
        when (level) {
            LogLevel.DEBUG -> Timber.tag(TAG).v(logcatMessage)
            LogLevel.INFO -> Timber.tag(TAG).i(logcatMessage)
            LogLevel.WARNING -> Timber.tag(TAG).w(logcatMessage)
            LogLevel.ERROR -> Timber.tag(TAG).e(logcatMessage)
            LogLevel.SUCCESS -> Timber.tag(TAG).i(logcatMessage)
        }

        bridgeClient?.let { bridge ->
            try {
                bridge.getService()?.writeRawLog(conciseMessage)
            } catch (e: Exception) {
                Timber.tag(TAG).e("Failed to send log to bridge service: ${e.message}")
            }
        }
    }

    private fun buildLogcatMessage(source: LogSource, subName: String?, message: String, isSuccess: Boolean): String {
        val sourceStr = source.toString().lowercase().replaceFirstChar { it.uppercase() }

        val prefix = when {
            subName != null -> "$sourceStr: ${hookPrefixes[subName] ?: subName}"
            else -> sourceStr
        }

        return "$prefix: $message"
    }

    fun writeRaw(content: String) {
        bridgeClient?.let { bridge ->
            try {
                bridge.getService()?.writeRawLog(content)
            } catch (e: Exception) {
                Timber.tag(TAG).e("Failed to write raw log to bridge service: ${e.message}")
            }
        }
    }

    fun clearLogs() {
        bridgeClient?.let { bridge ->
            try {
                bridge.getService()?.clearLogs()
            } catch (e: Exception) {
                Timber.tag(TAG).e("Failed to clear logs in bridge service: ${e.message}")
            }
        }
    }

    private fun getDefaultSource(): LogSource =
        if (isModuleContext) LogSource.MODULE else LogSource.MANAGER

    private val debugEnabled: Boolean
        get() = when (val value = Config.get("debug_mode", false)) {
            is Boolean -> value // We account for both strings and booleans
            is String -> value.equals("true", ignoreCase = true)
            else -> false
        } || BuildConfig.DEBUG // Always true in debug builds
}

fun Hook.logd(message: String) = Logger.d(message, LogSource.HOOK, this.hookName)
fun Hook.logi(message: String) = Logger.i(message, LogSource.HOOK, this.hookName)
fun Hook.logw(message: String) = Logger.w(message, LogSource.HOOK, this.hookName)
fun Hook.loge(message: String) = Logger.e(message, LogSource.HOOK, this.hookName)
fun Hook.logs(message: String) = Logger.s(message, LogSource.HOOK, this.hookName)

fun Task.logd(message: String) = Logger.d(message, LogSource.TASK, this.id)
fun Task.logi(message: String) = Logger.i(message, LogSource.TASK, this.id)
fun Task.logw(message: String) = Logger.w(message, LogSource.TASK, this.id)
fun Task.loge(message: String) = Logger.e(message, LogSource.TASK, this.id)
fun Task.logs(message: String) = Logger.s(message, LogSource.TASK, this.id) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\TaskScheduler.kt --- 
package com.grindrplus.core

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

class TaskScheduler(private val scope: CoroutineScope) {
    private val runningJobs = mutableMapOf<String, Job>()

    fun periodic(
        name: String,
        intervalMs: Long,
        action: suspend () -> Unit
    ): Job {
        val job = scope.launch {
            while (true) {
                try {
                    action()
                    delay(intervalMs)
                } catch (e: Exception) {
                    Logger.e("$name failed: ${e.message}", LogSource.MODULE)
                    Logger.writeRaw(e.stackTraceToString())
                    delay(intervalMs)
                }
            }
        }
        runningJobs[name] = job
        return job
    }

    fun once(name: String, action: suspend () -> Unit): Job {
        val job = scope.launch {
            try {
                action()
            } catch (e: Exception) {
                Logger.e("$name failed: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            } finally {
                runningJobs.remove(name)
            }
        }
        runningJobs[name] = job
        return job
    }

    fun withRetry(
        name: String,
        retries: Int = 3,
        delayMs: Long = 1000,
        action: suspend () -> Unit
    ): Job {
        val job = scope.launch {
            try {
                repeat(retries) { attempt ->
                    try {
                        action()
                        return@launch
                    } catch (e: Exception) {
                        if (attempt == retries - 1) {
                            Logger.e("$name failed after $retries attempts", LogSource.MODULE)
                            Logger.writeRaw(e.stackTraceToString())
                            throw e
                        } else {
                            Logger.w("$name retry ${attempt+1}/$retries", LogSource.MODULE)
                            delay(delayMs)
                        }
                    }
                }
            } finally {
                runningJobs.remove(name)
            }
        }
        runningJobs[name] = job
        return job
    }

    fun isTaskRunning(name: String): Boolean {
        return runningJobs[name]?.isActive == true
    }

    fun cancelTask(name: String) {
        runningJobs[name]?.cancel()
        runningJobs.remove(name)
    }

    fun cancelAllTasks() {
        runningJobs.values.forEach { it.cancel() }
        runningJobs.clear()
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\Utils.kt --- 
package com.grindrplus.core

import android.annotation.SuppressLint
import android.app.Activity
import android.app.AlertDialog
import android.content.Context
import android.content.Intent
import android.widget.Button
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.GrindrPlus.context
import com.grindrplus.GrindrPlus.httpClient
import com.grindrplus.GrindrPlus.isImportingSomething
import com.grindrplus.GrindrPlus.shouldTriggerAntiblock
import com.grindrplus.core.Constants.NEWLINE
import de.robv.android.xposed.XposedHelpers.callMethod
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import kotlin.math.pow

object Utils {
    fun openChat(id: String) {
        val chatActivityInnerClass =
            GrindrPlus.loadClass("com.grindrapp.android.chat.presentation.ui.ChatActivityV2\$a")
        val chatArgsClass =
            GrindrPlus.loadClass("com.grindrapp.android.args.ChatArgs")
        val profileTypeClass =
            GrindrPlus.loadClass("com.grindrapp.android.ui.profileV2.model.ProfileType")
        val referrerTypeClass =
            GrindrPlus.loadClass("com.grindrapp.android.profile.domain.ReferrerType")
        val conversationMetadataClass =
            GrindrPlus.loadClass("com.grindrapp.android.chat.model.DirectConversationMetaData")

        val conversationMetadataInstance = conversationMetadataClass.constructors.first().newInstance(
            id,
            id.substringBefore(":"),
            id.substringAfter(":")
        )

        val profileType = profileTypeClass.getField("FAVORITES").get(null)
        val refererType = referrerTypeClass.getField("UNIFIED_CASCADE").get(null)

        val chatArgsInstance = chatArgsClass.constructors.first().newInstance(
            conversationMetadataInstance,
            "0xDEADBEEF", // str
            profileType,
            refererType,
            "0xDEADBEEF", // str2
            "0xDEADBEEF", // str3
            null,
            null, // chatMediaDrawerArgs
            false,
            844
        )

        val method = chatActivityInnerClass.declaredMethods.find {
            it.parameterTypes.size == 2 && it.parameterTypes[1] == chatArgsClass
        }

        val intent = method?.invoke(
            null,
            context,
            chatArgsInstance
        ) as Intent?

        intent?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)

        val generalDeepLinksClass =
            GrindrPlus.loadClass("com.grindrapp.android.deeplink.GeneralDeepLinks")
        val startActivityMethod = generalDeepLinksClass.getDeclaredMethod(
            "safedk_Context_startActivity_97cb3195734cf5c9cc3418feeafa6dd6",
            Context::class.java,
            Intent::class.java
        )

        startActivityMethod.invoke(null, context, intent)
    }

    fun openProfile(id: String) {
        val referrerTypeClass =
            GrindrPlus.loadClass("com.grindrapp.android.profile.domain.ReferrerType")
        val referrerType = referrerTypeClass.getField("NOTIFICATION").get(null)
        val profilesActivityInnerClass =
            GrindrPlus.loadClass("com.grindrapp.android.ui.profileV2.ProfilesActivity\$a")

        Logger.i("ProfilesActivity inner class: $profilesActivityInnerClass")

        val method = profilesActivityInnerClass.declaredMethods.find {
            it.parameterTypes.size == 4 && it.parameterTypes[2] == referrerTypeClass
        }

        if (method == null) {
            Logger.e("Method not found in ProfilesActivity inner class.")
            return
        }

        val intent = method?.invoke(
            null,
            context,
            id,
            referrerType,
            referrerType
        ) as Intent?
        intent?.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)

        val generalDeepLinksClass =
            GrindrPlus.loadClass("com.grindrapp.android.deeplink.GeneralDeepLinks")
        val startActivityMethod = generalDeepLinksClass.getDeclaredMethod(
            "safedk_Context_startActivity_97cb3195734cf5c9cc3418feeafa6dd6",
            Context::class.java,
            Intent::class.java
        )

        startActivityMethod.invoke(null, context, intent)
    }

    fun calculateBMI(isMetric: Boolean, weight: Double, height: Double): Double {
        return if (isMetric) {
            weight / (height / 100).pow(2)
        } else {
            703 * weight / height.pow(2)
        }
    }

    fun w2n(isMetric: Boolean, weight: String): Double {
        return when {
            isMetric -> weight.substringBefore("kg").trim().toDouble()
            else -> weight.substringBefore("lbs").trim().toDouble()
        }
    }

    fun h2n(isMetric: Boolean, height: String): Double {
        return if (isMetric) {
            height.removeSuffix("cm").trim().toDouble()
        } else {
            val (feet, inches) = height.split("'").let {
                it[0].toDouble() to it[1].replace("\"", "").toDouble()
            }
            feet * 12 + inches
        }
    }

    fun safeGetField(obj: Any, fieldName: String): Any? {
        return try {
            obj::class.java.getDeclaredField(fieldName).apply {
                isAccessible = true
            }.get(obj)
        } catch (e: Exception) {
            null
        }
    }

    fun coordsToGeoHash(lat: Double, lon: Double, precision: Int = 12): String {
        return GrindrPlus.loadClass("ch.hsr.geohash.GeoHash")
            .getMethod("geoHashStringWithCharacterPrecision",
                Double::class.java, Double::class.java, Int::class.java)
            .invoke(null, lat, lon, precision) as String
    }

    @SuppressLint("SetTextI18n")
    fun showProgressDialog(
        context: Context,
        message: String,
        onCancel: () -> Unit,
        onRunInBackground: (updateProgress: (Int) -> Unit, onComplete: (Boolean) -> Unit) -> Unit,
        successMessage: String = "All blocks have been imported!",
        failureMessage: String = "Something went wrong. Please try again."
    ) {
        lateinit var dialog: AlertDialog

        val progressBar = ProgressBar(context, null, android.R.attr.progressBarStyleHorizontal).apply {
            isIndeterminate = false
            max = 100
            progress = 0
        }

        val textView = TextView(context).apply {
            text = "$message (0%)"
            textSize = 16f
            setPadding(20, 20, 20, 20)
        }

        val cancelButton = Button(context).apply {
            text = "Cancel"
            setOnClickListener {
                onCancel()
                dialog.dismiss()
            }
        }

        val backgroundButton = Button(context).apply {
            text = "Run in Background"
            setOnClickListener {
                dialog.dismiss()
            }
        }

        val container = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(40, 40, 40, 40)
            addView(progressBar)
            addView(textView)
            addView(cancelButton)
            addView(backgroundButton)
        }

        dialog = AlertDialog.Builder(context)
            .setCancelable(false)
            .setView(container)
            .create()

        dialog.show()

        onRunInBackground({ progress ->
            progressBar.progress = progress
            textView.text = "$message ($progress%)"
        }) { success ->
            container.removeAllViews()

            val resultIcon = TextView(context).apply {
                text = if (success) "✅" else "❌"
                textSize = 40f
                setPadding(20, 20, 20, 20)
                gravity = android.view.Gravity.CENTER
            }

            val resultMessage = TextView(context).apply {
                text = if (success) successMessage else failureMessage
                textSize = 18f
                setPadding(20, 20, 20, 20)
                gravity = android.view.Gravity.CENTER
            }

            val closeButton = Button(context).apply {
                text = "Close"
                setOnClickListener {
                    dialog.dismiss()
                }
            }

            container.apply {
                addView(resultIcon)
                addView(resultMessage)
                addView(closeButton)
            }
        }
    }

    fun showWarningDialog(context: Context, message: String, onConfirm: () -> Unit, onCancel: () -> Unit) {
        AlertDialog.Builder(context)
            .setTitle("Warning")
            .setMessage(message)
            .setCancelable(false)
            .setPositiveButton("Proceed") { _, _ ->
                onConfirm()
            }
            .setNegativeButton("Cancel") { _, _ ->
                onCancel()
            }
            .create()
            .show()
    }

    fun handleImports(activity: Activity) {
        val homeActivity = "com.grindrapp.android.ui.home.HomeActivity"

        if (activity.javaClass.name == homeActivity && !isImportingSomething) {
            val favoritesFile = context.getFileStreamPath("favorites_to_import.txt")
            val blocksFile = context.getFileStreamPath("blocks_to_import.txt")

            if (favoritesFile.exists() && blocksFile.exists()) {
                showWarningDialog(
                    context = activity,
                    message = "Favorites and Blocks import files detected. GrindrPlus will process the favorites list first. " +
                            "Blocks import will be done on the next app restart.",
                    onConfirm = {
                        val threshold = (Config.get("favorites_import_threshold", "500") as String).toInt()
                        val favorites = favoritesFile.readLines()

                        if (favorites.size > 50 && threshold < 1000) {
                            showWarningDialog(
                                context = activity,
                                message = "High number of favorites and low threshold detected. " +
                                        "Continuing may result in your account being banned. Do you want to proceed?",
                                onConfirm = {
                                    startFavoritesImport(activity, favorites, favoritesFile, threshold)
                                },
                                onCancel = {
                                    Logger.i("Favorites import canceled by the user.")
                                }
                            )
                        } else {
                            startFavoritesImport(activity, favorites, favoritesFile, threshold)
                        }
                    },
                    onCancel = {
                        Logger.i("Imports canceled by the user.")
                    }
                )
            } else if (favoritesFile.exists()) {
                val threshold = (Config.get("favorites_import_threshold", "500") as String).toInt()
                val favorites = favoritesFile.readLines()

                if (favorites.size > 50 && threshold < 1000) {
                    showWarningDialog(
                        context = activity,
                        message = "High number of favorites and low threshold detected. " +
                                "Continuing may result in your account being banned. Do you want to proceed?",
                        onConfirm = {
                            startFavoritesImport(activity, favorites, favoritesFile, threshold)
                        },
                        onCancel = {
                            isImportingSomething = false
                            Logger.i("Favorites import canceled by the user.")
                        }
                    )
                } else {
                    startFavoritesImport(activity, favorites, favoritesFile, threshold)
                }
            } else if (blocksFile.exists()) {
                val threshold = (Config.get("block_import_threshold", "500") as String).toInt()
                val blocks = blocksFile.readLines()

                if (blocks.size > 100 && threshold < 1000) {
                    showWarningDialog(
                        context = activity,
                        message = "High number of blocks and low threshold detected. " +
                                "Continuing may result in your account being banned. Do you want to proceed?",
                        onConfirm = {
                            startBlockImport(activity, blocks, blocksFile, threshold)
                        },
                        onCancel = {
                            isImportingSomething = false
                            Logger.i("Block import canceled by the user.")
                        }
                    )
                } else {
                    startBlockImport(activity, blocks, blocksFile, threshold)
                }
            }
        }
    }

    private fun startFavoritesImport(
        activity: Activity,
        favorites: List<String>,
        favoritesFile: File,
        threshold: Int
    ) {
        try {

            showProgressDialog(
                context = activity,
                message = "Importing favorites...",
                successMessage = "Favorites import completed.",
                failureMessage = "Favorites import failed.",
                onCancel = {
                    isImportingSomething = false
                    Logger.i("Favorites import canceled by the user.")
                },
                onRunInBackground = { updateProgress, onComplete ->
                    CoroutineScope(Dispatchers.IO).launch {
                        try {
                            favorites.forEachIndexed { index, id ->
                                val parts = id.split("|||")
                                val profileId = parts.getOrNull(0) ?: ""
                                val note = parts.getOrNull(1)?.replace(NEWLINE, "\n") ?: ""
                                val phoneNumber = parts.getOrNull(2)?.replace(NEWLINE, "\n") ?: ""
                                httpClient.favorite(
                                    profileId,
                                    silent = true,
                                    reflectInDb = false
                                )
                                if (note.isNotEmpty() || phoneNumber.isNotEmpty()) {
                                    httpClient.addProfileNote(
                                        profileId,
                                        note,
                                        phoneNumber,
                                        silent = true
                                    )
                                }
                                favoritesFile.writeText(favorites.drop(index + 1).joinToString("\n"))
                                val progress = ((index + 1) * 100) / favorites.size
                                updateProgress(progress)
                                Thread.sleep(threshold.toLong())
                            }

                            withContext(Dispatchers.Main) {
                                favoritesFile.delete()
                                onComplete(true)
                            }
                        } catch (e: Exception) {
                            withContext(Dispatchers.Main) {
                                val message = "An error occurred while importing favorites: ${e.message ?: "Unknown error"}"
                                GrindrPlus.showToast(Toast.LENGTH_LONG, message)
                                Logger.apply {
                                    e(message)
                                    writeRaw(e.stackTraceToString())
                                }
                                onComplete(false)
                            }
                        } finally {
                            isImportingSomething = false
                        }
                    }
                }
            )
        } catch (e: Exception) {
            val message = "An error occurred while importing favorites: ${e.message ?: "Unknown error"}"
            GrindrPlus.showToast(Toast.LENGTH_LONG, message)
            Logger.apply {
                e(message)
                writeRaw(e.stackTraceToString())
            }
        }
    }

    private fun startBlockImport(
        activity: Activity,
        blocks: List<String>,
        blocksFile: File,
        threshold: Int
    ) {
        try {
            shouldTriggerAntiblock = false

            showProgressDialog(
                context = activity,
                message = "Importing blocks...",
                successMessage = "Block import completed.",
                failureMessage = "Block import failed.",
                onCancel = {
                    isImportingSomething = false
                    Logger.i("Block import canceled by the user.")
                },
                onRunInBackground = { updateProgress, onComplete ->
                    CoroutineScope(Dispatchers.IO).launch {
                        try {
                            blocks.forEachIndexed { index, id ->
                                httpClient.blockUser(
                                    id,
                                    silent = true,
                                    reflectInDb = false
                                )
                                blocksFile.writeText(blocks.drop(index + 1).joinToString("\n"))
                                val progress = ((index + 1) * 100) / blocks.size
                                updateProgress(progress)
                                Thread.sleep(threshold.toLong())
                            }

                            withContext(Dispatchers.Main) {
                                blocksFile.delete()
                                onComplete(true)
                            }
                        } catch (e: Exception) {
                            withContext(Dispatchers.Main) {
                                val message = "An error occurred while importing blocks: ${e.message ?: "Unknown error"}"
                                GrindrPlus.showToast(Toast.LENGTH_LONG, message)
                                Logger.apply {
                                    e(message)
                                    writeRaw(e.stackTraceToString())
                                }
                                onComplete(false)
                            }
                        } finally {
                            shouldTriggerAntiblock = true
                            isImportingSomething = false
                        }
                    }
                }
            )
        } catch (e: Exception) {
            val message = "An error occurred while importing blocks: ${e.message ?: "Unknown error"}"
            GrindrPlus.apply {
                shouldTriggerAntiblock = true
                showToast(Toast.LENGTH_LONG, message)
            }
            Logger.apply {
                e(message)
                writeRaw(e.stackTraceToString())
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\WssAuthLogger.kt --- 
package com.grindrplus.core

import com.grindrplus.GrindrPlus
import com.grindrplus.persistence.GPDatabase
import com.grindrplus.persistence.model.LogEntity

object WssAuthLogger {
    fun log(profileId: String, xmppToken: String) {
        if (!(Config.get("enable_wss_logging", false) as Boolean)) return
        GPDatabase.DatabaseManager.executeWhenReady {
            try {
                GrindrPlus.executeAsync {
                    val entity = LogEntity(
                        timestamp = System.currentTimeMillis(),
                        log_type = "wss_auth",
                        profile_id = profileId,
                        xmpp_token = xmppToken
                    )
                    GrindrPlus.database.logDao().insert(entity)
                }
            } catch (e: Exception) {
                Logger.e("Failed to log WSS auth: ${e.message}")
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\constants\GrindrApiError.kt --- 
package com.grindrplus.core.constants

enum class GrindrApiError(val code: Int?, val message: String) {
    ERR_CANNOT_SAVE(2, "Unable to save"),
    ERR_INVALID_PARAMETERS(4, "Invalid input parameters"),
    ERR_UNKNOWN_ERROR(5, "Unknown error"),
    ERR_INVALID_TOKEN(6, "Invalid token"),
    ERR_FAILED_TO_CREATE_SESSION(7, "Failed to create session"),
    ERR_DEPRECATED_CLIENT_VERSION(8, "The client version is deprecated"),
    ERR_DUPLICATED_USER(9, "Duplicated user"),
    ERR_USER_IS_NOT_ACTIVE(10, "User is not active"),
    ERR_SAVE_FAILURE(11, "Save failure"),
    ERR_UNKNOWN_PLATFORM(13, "Unknown platform"),
    ERR_FAILED_TO_VALIDATE_CAPTCHA(15, "Failed to validate captcha"),
    ERR_SHORT_PASSWORD(16, "Your password is too short. Please enter a password with at least six characters"),
    ERR_FAILED_TO_CREATE_PROFILE(17, "Failed to create profile"),
    ERR_WEAK_PASSWORD(17, "Your password does not meet complexity requirements"),
    ERR_INVALID_CAPTCHA_TOKEN(18, "Invalid captcha token"),
    ERR_INVALID_AGE(19, "Invalid age"),
    ERR_EMAIL_EXISTS(22, "Email id already exists"),
    ERR_EMAIL_NOT_FOUND(23, "Email id not found"),
    ERR_AUTH_FAILURE(24, "User Authentication failed"),
    ERR_RESET_TOKEN_NOT_FOUND(25, "Token not found"),
    ERR_PROFILE_BANNED(27, "Profile is banned"),
    ERR_DEVICE_BANNED(28, "Your device has been banned"),
    ERR_INVALID_EMAIL(29, "Invalid email"),
    ERR_VERIFICATION_REQUIRED(30, "Verification required"),
    ERR_IP_BANNED(31, "SUSPICIOUS_NETWORK"),
    ERR_ACCOUNT_REGISTRATION_FAILED(32, "Account Registration Failed"),
    ERR_ACCOUNT_REGISTRATION_REJECTED(33, "Account registration rejected"),
    ERR_EXCEED_FAVE_DAILY_LIMIT(33, "Favorite daily limit reached"),
    ERR_CANNOT_UNBLOCK_NONBLOCKED(36, "Can not unblock a non-blocked user"),
    ERR_AGE_RESTRICTED(35, "Underage ban, ages 13-17"),
    ERR_UNDER_THIRTEEN(36, "Underage ban, ages 5-12"),
    ERR_INVALID_THIRD_PARTY_TOKEN(80, "Invalid third party token"),
    ERR_THIRD_PARTY_USER_ID_EXISTS(81, "Third party user id exists"),
    ERR_THIRD_PARTY_CREATE_ACCOUNT(83, "Error when third party create account"),
    ERR_PHONE_EXISTS(300, "Phone number already exists"),
    ERR_PHONE_NOT_FOUND(301, "Phone number not found"),
    ERR_INVALID_PHONE_NUMBER(302, "Invalid phone number"),
    ERR_INVALID_VERIFICATION_CODE(303, "Invalid verification code"),
    ERR_INVALID_PHONE_NUMBER_REGISTRATION_AFTER_DELETION(304, "Another profile with this phone number was deleted recently"),
    ERR_NOT_AVAILABLE_IN_THIS_REGION(305, "Not available in this region"),
    ERR_SMS_ENDPOINT_LIMIT_REACHED(306, "SMS endpoint limit reached"),
    ERR_PROFILE_ALREADY_VERIFIED(null, "Profile is already verified"),
    ERR_PROFILE_NOT_REQUIRED_VERIFY(null, "Profile is not verification required"),
    ERR_PHONE_NUM_TOO_MANY_TIMES(null, "Phone number was used too many times"),
    ERR_PHONE_NUMBER_IS_BANNED(null, "Phone number is banned"),
    ERR_TARGET_PROFILE_OFFLINE(null, "Target profile is offline"),
    ERR_EXCEED_LENGTH_LIMIT(null, "Exceed length limit");

    companion object {
        private val errorsByCode = GrindrApiError.entries.filter { it.code != null }.associateBy { it.code }
        private val errorsByMessage = GrindrApiError.entries.associateBy { it.message }
        private val errorsByName = GrindrApiError.entries.associateBy { it.name }

        @JvmStatic
        fun findError(errorCode: Int?, errorMessage: String?): GrindrApiError? {
            return when {
                errorCode != null -> errorsByCode[errorCode]
                errorMessage != null -> errorsByMessage[errorMessage] ?: errorsByName[errorMessage]
                else -> null
            }
        }

        @JvmStatic
        fun getErrorDescription(errorCode: Any?): String {
            val error = when(errorCode) {
                is Int -> findError(errorCode, null)
                is String -> findError(null, errorCode)
                else -> null
            }

            return error?.message ?: "Unknown error: $errorCode"
        }

        @JvmStatic
        fun isErrorType(errorCode: Any?, errorType: GrindrApiError): Boolean {
            return when(errorCode) {
                is Int -> errorCode == errorType.code
                is String -> {
                    errorCode == errorType.code.toString() ||
                            errorCode == errorType.name ||
                            errorCode == errorType.message
                }
                else -> false
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\http\Client.kt --- 
package com.grindrplus.core.http

import android.content.ContentValues
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.GrindrPlus.showToast
import com.grindrplus.core.DatabaseHelper
import com.grindrplus.core.Logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.*
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

class Client(interceptor: Interceptor) {
    private val httpClient: OkHttpClient = OkHttpClient.Builder()
        .addInterceptor(interceptor)
        .build()

    fun sendRequest(
        url: String,
        method: String = "GET",
        headers: Map<String, String>? = null,
        body: RequestBody? = null
    ): Response {
        val requestBuilder = Request.Builder().url(url)
        headers?.forEach { (key, value) ->
            requestBuilder.addHeader(key, value)
        }

        when (method.uppercase()) {
            "POST" -> requestBuilder.post(body ?: RequestBody.createEmpty())
            "PUT" -> requestBuilder.put(body ?: throw IllegalArgumentException("PUT requires a body"))
            "DELETE" -> {
                if (body != null) requestBuilder.delete(body) else requestBuilder.delete()
            }
            "PATCH" -> requestBuilder.patch(body ?: throw IllegalArgumentException("PATCH requires a body"))
            "GET" -> requestBuilder.get()
            else -> throw IllegalArgumentException("Unsupported HTTP method: $method")
        }

        return httpClient.newCall(requestBuilder.build()).execute()
    }

    fun blockUser(profileId: String, silent: Boolean = false, reflectInDb: Boolean = true) {
        GrindrPlus.shouldTriggerAntiblock = false
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/blocks/$profileId",
                "POST"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User blocked successfully")
                if (reflectInDb) {
                    val order = DatabaseHelper.query(
                        "SELECT MAX(order_) AS order_ FROM blocks"
                    ).firstOrNull()?.get("order_") as? Int ?: 0
                    DatabaseHelper.insert(
                        "blocks",
                        ContentValues().apply {
                            put("profileId", profileId)
                            put("order_", order + 1)
                        }
                    )
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to block user: $errorBody")
                    }
                }
            }
        }
        GrindrPlus.executeAsync {
            Thread.sleep(500) // Wait for WS to reply
            GrindrPlus.shouldTriggerAntiblock = true
        }
    }

    fun unblockUser(profileId: String, silent: Boolean = false, reflectInDb: Boolean = true) {
        GrindrPlus.shouldTriggerAntiblock = false
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/blocks/$profileId",
                "DELETE"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User unblocked successfully")
                try {
                    if (reflectInDb) {
                        DatabaseHelper.delete(
                            "blocks",
                            "profileId = ?",
                            arrayOf(profileId)
                        )
                    }
                } catch (e: Exception) {
                    Logger.apply {
                        e("Error removing user from blocks list: ${e.message}")
                        writeRaw(e.stackTraceToString())
                    }
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to unblock user: $errorBody")
                    }
                }
            }
        }
        GrindrPlus.executeAsync {
            Thread.sleep(500) // Wait for WS to reply
            GrindrPlus.shouldTriggerAntiblock = true
        }
    }

    fun favorite(
        profileId: String,
        silent: Boolean = false,
        reflectInDb: Boolean = true
    ) {
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/favorites/$profileId",
                "POST"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User favorited successfully")
                if (reflectInDb) {
                    DatabaseHelper.insert(
                        "favorite_profile",
                        ContentValues().apply {
                            put("id", profileId)
                        }
                    )
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to favorite user: $errorBody")
                    }
                }
            }
        }
    }

    fun unfavorite(
        profileId: String,
        silent: Boolean = false,
        reflectInDb: Boolean = true
    ) {
        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v3/me/favorites/$profileId",
                "DELETE"
            )
            if (response.isSuccessful) {
                if (!silent) showToast(Toast.LENGTH_LONG, "User unfavorited successfully")
                try {
                    if (reflectInDb) {
                        DatabaseHelper.delete(
                            "favorite_profile",
                            "id = ?",
                            arrayOf(profileId)
                        )
                    }
                } catch (e: Exception) {
                    Logger.apply {
                        e("Error removing user from favorites list: ${e.message}")
                        writeRaw(e.stackTraceToString())
                    }
                }
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to unfavorite user: $errorBody")
                    }
                }
            }
        }
    }

    fun updateLocation(geohash: String) {
        val body = """
            {
                "geohash": "$geohash"
            }
        """.trimIndent()

        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v4/location",
                "PUT",
                body = body.toRequestBody(),
                headers = mapOf("Content-Type" to "application/json; charset=UTF-8")
            )
            if (response.isSuccessful) {
                showToast(Toast.LENGTH_LONG, "Location updated successfully")
            } else {
                response.useBody { errorBody ->
                    showToast(Toast.LENGTH_LONG, "Failed to update location: $errorBody")
                }
            }
        }
    }

    fun reportUser(
        profileId: String,
        reason: String = "SPAM",
        comment: String = ""
    ) {
        GrindrPlus.executeAsync {
            val body = """
                {
                    "reason": "$reason",
                    "comment": "$comment",
                    "locations": [
                        "CHAT_MESSAGE"
                    ]
                }
            """.trimIndent()

            val response = sendRequest(
                "https://grindr.mobi/v3.1/flags/$profileId",
                "POST",
                body = body.toRequestBody(),
                headers = mapOf("Content-Type" to "application/json; charset=UTF-8")
            )

            if (response.isSuccessful) {
                showToast(Toast.LENGTH_LONG, "User reported successfully")
            } else {
                response.useBody { errorBody ->
                    showToast(Toast.LENGTH_LONG, "Failed to report user: $errorBody")
                }
            }
        }
    }

    suspend fun fetchCascade(
        nearbyGeoHash: String,
        onlineOnly: Boolean = false,
        photoOnly: Boolean = false,
        faceOnly: Boolean = false,
        notRecentlyChatted: Boolean = false,
        fresh: Boolean = false,
        pageNumber: Int = 1,
        favorites: Boolean = false,
        showSponsoredProfiles: Boolean = false,
        shuffle: Boolean = false
    ): JSONObject = withContext(Dispatchers.IO) {
        try {
            val url = buildString {
                append("https://grindr.mobi/v3/cascade?nearbyGeoHash=$nearbyGeoHash")
                append("&onlineOnly=$onlineOnly")
                append("&photoOnly=$photoOnly")
                append("&faceOnly=$faceOnly")
                append("&notRecentlyChatted=$notRecentlyChatted")
                append("&fresh=$fresh")
                append("&pageNumber=$pageNumber")
                append("&favorites=$favorites")
                append("&showSponsoredProfiles=$showSponsoredProfiles")
                append("&shuffle=$shuffle")
            }

            val response = sendRequest(url, "GET")
            if (response.isSuccessful) {
                response.useBody { responseBody ->
                    if (!responseBody.isNullOrEmpty()) {
                        return@withContext JSONObject(responseBody)
                    }
                    JSONObject()
                }
            } else {
                Logger.e("Failed to get nearby profiles: ${response.code}")
                response.useBody { errorBody ->
                    Logger.e("Error body: $errorBody")
                }
                JSONObject()
            }
        } catch (e: Exception) {
            Logger.e("Failed to get nearby profiles: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            JSONObject()
        }
    }

    suspend fun getBlocks(): List<String> = withContext(Dispatchers.IO) {
        try {
            val response = sendRequest("https://grindr.mobi/v3.1/me/blocks", "GET")
            if (response.isSuccessful) {
                response.useBody { responseBody ->
                    if (!responseBody.isNullOrEmpty()) {
                        val jsonResponse = JSONObject(responseBody)
                        val blockingArray = jsonResponse.optJSONArray("blocking")
                        if (blockingArray != null) {
                            val blockedProfileIds = mutableListOf<String>()
                            for (i in 0 until blockingArray.length()) {
                                val blockingJson = blockingArray.getJSONObject(i)
                                val profileId = blockingJson.optLong("profileId")
                                blockedProfileIds.add(profileId.toString())
                            }
                            return@useBody blockedProfileIds
                        }
                    }
                    emptyList()
                }
            } else {
                emptyList()
            }
        } catch (e: Exception) {
            Logger.e("Failed to get blocks: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            emptyList()
        }
    }

    suspend fun getFavorites(): List<Triple<String, String, String>> = withContext(Dispatchers.IO) {
        try {
            val response = sendRequest("https://grindr.mobi/v6/favorites", "GET")
            if (response.isSuccessful) {
                response.useBody { responseBody ->
                    if (!responseBody.isNullOrEmpty()) {
                        val jsonResponse = JSONObject(responseBody)
                        val favoritesArray = jsonResponse.optJSONArray("favorites")
                        if (favoritesArray != null) {
                            val favoriteProfileIds = mutableListOf<Triple<String, String, String>>()
                            for (i in 0 until favoritesArray.length()) {
                                val favoriteJson = favoritesArray.getJSONObject(i)
                                val profileId = favoriteJson.optString("profileId")

                                val note = try {
                                    DatabaseHelper.query(
                                        "SELECT note FROM profile_note WHERE profile_id = ?",
                                        arrayOf(profileId)
                                    ).firstOrNull()?.get("note") as? String ?: ""
                                } catch (e: Exception) {
                                    Logger.apply {
                                        log("Failed to fetch note for profileId $profileId: ${e.message}")
                                        writeRaw(e.stackTraceToString())
                                    }
                                    ""
                                }

                                val phoneNumber = try {
                                    DatabaseHelper.query(
                                        "SELECT phone_number FROM profile_note WHERE profile_id = ?",
                                        arrayOf(profileId)
                                    ).firstOrNull()?.get("phone_number") as? String ?: ""
                                } catch (e: Exception) {
                                    Logger.apply {
                                        log("Failed to fetch phone number for profileId $profileId: ${e.message}")
                                        writeRaw(e.stackTraceToString())
                                    }
                                    ""
                                }

                                favoriteProfileIds.add(Triple(profileId, note, phoneNumber))
                            }
                            return@useBody favoriteProfileIds
                        }
                    }
                    emptyList()
                }
            } else {
                emptyList()
            }
        } catch (e: Exception) {
            Logger.e("Failed to get favorites: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            emptyList()
        }
    }

    fun addProfileNote(profileId: String, notes: String, phoneNumber: String, silent: Boolean = false) {
        if (notes.length > 250) {
            showToast(Toast.LENGTH_LONG, "Notes are too long")
            return
        }

        val body = """
            {
                "notes": "${notes.replace("\n", "\\n")}",
                "phoneNumber": "$phoneNumber"
            }
        """.trimIndent()

        GrindrPlus.executeAsync {
            val response = sendRequest(
                "https://grindr.mobi/v1/favorites/notes/$profileId",
                "PUT",
                body = body.toRequestBody(),
                headers = mapOf("Content-Type" to "application/json; charset=utf-8")
            )
            if (response.isSuccessful) {
                try {
                    val existingNote = DatabaseHelper.query(
                        "SELECT * FROM profile_note WHERE profile_id = ?",
                        arrayOf(profileId)
                    ).firstOrNull()
                    if (existingNote != null) {
                        DatabaseHelper.update(
                            "profile_note",
                            ContentValues().apply {
                                put("note", notes)
                                put("phone_number", phoneNumber)
                            },
                            "profile_id = ?",
                            arrayOf(profileId)
                        )
                    } else {
                        DatabaseHelper.insert(
                            "profile_note",
                            ContentValues().apply {
                                put("profile_id", profileId)
                                put("note", notes)
                                put("phone_number", phoneNumber)
                            }
                        )
                    }
                } catch (e: Exception) {
                    Logger.e("Failed to update profile note: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
                if (!silent) showToast(Toast.LENGTH_LONG, "Note added successfully")
            } else {
                if (!silent) {
                    response.useBody { errorBody ->
                        showToast(Toast.LENGTH_LONG, "Failed to add note: $errorBody")
                    }
                }
            }
        }
    }
}

fun RequestBody.Companion.createEmpty(): RequestBody {
    return "".toRequestBody()
}

private inline fun <T> Response.useBody(block: (String?) -> T): T {
    return try {
        block(body?.string())
    } finally {
        body?.close()
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\core\http\Interceptor.kt --- 
package com.grindrplus.core.http

import com.grindrplus.core.Logger
import com.grindrplus.core.LogSource
import de.robv.android.xposed.XposedBridge
import okhttp3.Interceptor
import okhttp3.Request
import okhttp3.Response
import java.io.IOException
import java.util.TimeZone
import okhttp3.Request.Builder

class Interceptor(
    private val userSession: Any,
    private val userAgent: Any,
    private val deviceInfo: Any
) : Interceptor {

    private fun modifyRequest(originalRequest: Request): Request {
        try {
            // search for 'return value != null && value.length() > 0' in userSession
            val isLoggedIn = invokeMethodSafe(userSession, "p") as? Boolean ?: false

            val builder: Builder = originalRequest.newBuilder()

            if (isLoggedIn) {
                // search for 'return FlowKt.asStateFlow' in userSession (return type is String)
                val authTokenFlow = invokeMethodSafe(userSession, "u")
                val authToken = if (authTokenFlow != null) {
                    invokeMethodSafe(authTokenFlow, "getValue") as? String ?: ""
                } else {
                    ""
                }

                // search for one line method returning an string in userSession
                val roles = invokeMethodSafe(userSession, "C") as? String ?: ""

                if (authToken.isNotEmpty()) {
                    builder.header("Authorization", "Grindr3 $authToken")
                    builder.header("L-Grindr-Roles", roles)
                } else {
                    Logger.w("Auth token is empty, skipping auth headers", LogSource.HTTP)
                }

                builder.header("L-Time-Zone", TimeZone.getDefault().id)



                // search for 'public final kotlin.Lazy' in deviceInfo
                val deviceInfoLazy = getFieldSafe(deviceInfo, "d") as? Any
                val lDeviceInfo = if (deviceInfoLazy != null) {
                    invokeMethodSafe(deviceInfoLazy, "getValue") as? String ?: ""
                } else {
                    ""
                }

                if (lDeviceInfo.isNotEmpty()) {
                    builder.header("L-Device-Info", lDeviceInfo)
                }
            } else {
                builder.header("L-Time-Zone", "Unknown")
            }
// SPOOF HEADER //

            val spoofedUserAgent = "grindr3/25.16.0.144399;144399;Free;Android 13;SM-S908U;Samsung"
            builder.header("User-Agent", spoofedUserAgent)


            // search for 'getValue().getNameTitleCase()' in userAgent
          //  val userAgentString = invokeMethodSafe(userAgent, "a") as? String ?: "Grindr"

            //      builder.header("User-Agent", userAgentString)
            builder.header("Accept", "application/json; charset=UTF-8")
            builder.header("L-Locale", "en_US")
            builder.header("Accept-language", "en-US")

            return builder.build()
        } catch (e: Exception) {
            Logger.e("Failed to modify request: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            throw IOException("Failed to modify request: ${e.message}", e)
        }
    }

    private fun invokeMethodSafe(obj: Any?, methodName: String): Any? {
        return try {
            if (obj == null) {
                Logger.w("Object is null when trying to invoke method: $methodName", LogSource.HTTP)
                return null
            }

            val method = obj::class.java.getMethod(methodName)
            val result = method.invoke(obj)
            result
        } catch (e: NoSuchMethodException) {
            Logger.e("Method not found: $methodName on ${obj?.javaClass?.simpleName}", LogSource.HTTP)
            null
        } catch (e: Exception) {
            Logger.e("Failed to invoke method $methodName: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            null
        }
    }

    private fun getFieldSafe(obj: Any?, fieldName: String): Any? {
        return try {
            if (obj == null) {
                Logger.w("Object is null when trying to get field: $fieldName", LogSource.HTTP)
                return null
            }

            val field = obj::class.java.getDeclaredField(fieldName)
            field.isAccessible = true
            val value = field.get(obj)
            value
        } catch (e: NoSuchFieldException) {
            Logger.e("Field not found: $fieldName on ${obj?.javaClass?.simpleName}", LogSource.HTTP)
            null
        } catch (e: Exception) {
            Logger.e("Failed to get field $fieldName: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            null
        }
    }

    override fun intercept(chain: Interceptor.Chain): Response {
        val request: Request = chain.request()
        try {
            val modifiedRequest = modifyRequest(request)
            Logger.d("Intercepting request to: ${request.url}", LogSource.HTTP)
            return chain.proceed(modifiedRequest)
        } catch (e: Exception) {
            Logger.e("Failed to intercept request: ${e.message}", LogSource.HTTP)
            Logger.writeRaw(e.stackTraceToString())
            throw IOException("Failed to intercept request: ${e.message}", e)
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\AllowScreenshots.kt --- 
package com.grindrplus.hooks

import android.app.Activity
import android.content.ContentResolver
import android.database.ContentObserver
import android.net.Uri
import android.view.Window
import android.view.WindowManager.LayoutParams.FLAG_SECURE
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook

class AllowScreenshots : Hook(
    "Allow screenshots",
    "Allow screenshots everywhere in the app"
) {
    override fun init() {
        Window::class.java.hook("setFlags", HookStage.BEFORE) { param ->
            var flags = param.arg<Int>(0)
            flags = flags and FLAG_SECURE.inv()
            param.setArg(0, flags)
        }

        Activity::class.java.hook("registerScreenCaptureCallback", HookStage.BEFORE) { param ->
            param.setResult(null)
        }

    ContentResolver::class.java.methods.first {
        it.name == "registerContentObserver" &&
                it.parameterTypes.contentEquals(arrayOf(Uri::class.java,
                    Boolean::class.javaPrimitiveType, ContentObserver::class.java))
        }.hook(HookStage.BEFORE) { param ->
            val uri = param.arg<Uri>(0)
            if (uri.host != "media") return@hook
            param.setResult(null)
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\AntiBlock.kt --- 
package com.grindrplus.hooks

import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.bridge.BridgeService
import com.grindrplus.core.Config
import com.grindrplus.core.DatabaseHelper
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.getObjectField
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.json.JSONObject

class AntiBlock : Hook(
    "Anti Block",
    "Notifies you when someone blocks or unblocks you"
) {
    private val scope = CoroutineScope(Dispatchers.IO)
    private var myProfileId: Long = 0
    private val chatDeleteConversationPlugin = "U5.c" // search for 'com.grindrapp.android.chat.ChatDeleteConversationPlugin'
    private val inboxFragmentV2DeleteConversations = "Y8.i" // search for '("chat_read_receipt", conversationId, null);'
    private val individualUnblockActivityViewModel = "cf.s" // search for '@DebugMetadata(c = "com.grindrapp.android.ui.block.IndividualUnblockActivityViewModel$unblockAllProfile$1", f = "IndividualUnblockActivityViewModel.kt",'

    override fun init() {
        findClass(individualUnblockActivityViewModel).hook("I", HookStage.BEFORE) { param ->
            GrindrPlus.shouldTriggerAntiblock = false
        }

        findClass(individualUnblockActivityViewModel).hook("I", HookStage.AFTER) { param ->
            Thread.sleep(700) // Wait for WS to unblock
            GrindrPlus.shouldTriggerAntiblock = true
        }

        if (Config.get("force_old_anti_block_behavior", false) as Boolean) {
            findClass("com.grindrapp.android.chat.model.ConversationDeleteNotification")
                .hookConstructor(HookStage.BEFORE) { param ->
                    @Suppress("UNCHECKED_CAST")
                    val profiles = param.args().firstOrNull() as? List<String> ?: emptyList()
                    param.setArg(0, emptyList<String>())
                }
        } else {
            findClass(inboxFragmentV2DeleteConversations)
                .hook("d", HookStage.BEFORE) { param ->
                    GrindrPlus.shouldTriggerAntiblock = false
                    GrindrPlus.blockCaller = "inboxFragmentV2DeleteConversations"
                }

            findClass(inboxFragmentV2DeleteConversations)
                .hook("d", HookStage.AFTER) { param ->
                    val numberOfChatsToDelete = (param.args().firstOrNull() as? List<*>)?.size ?: 0
                    if (numberOfChatsToDelete == 0) return@hook
                    logd("Request to delete $numberOfChatsToDelete chats")
                    Thread.sleep((300 * numberOfChatsToDelete).toLong()) // FIXME
                    GrindrPlus.shouldTriggerAntiblock = true
                    GrindrPlus.blockCaller = ""
                }

            findClass(chatDeleteConversationPlugin).hook("b", HookStage.BEFORE) { param ->
                myProfileId = GrindrPlus.myProfileId.toLong()
                if (!GrindrPlus.shouldTriggerAntiblock) {
                    val whitelist = listOf(
                        "inboxFragmentV2DeleteConversations",
                    )
                    if (GrindrPlus.blockCaller !in whitelist) {
                        param.setResult(null)
                    }
                    return@hook
                }
            }

            findClass("com.grindrapp.android.chat.model.ConversationDeleteNotification")
                .hookConstructor(HookStage.BEFORE) { param ->
                    @Suppress("UNCHECKED_CAST")
                    if (GrindrPlus.shouldTriggerAntiblock) {
                        val profiles = param.args().firstOrNull() as? List<String> ?: emptyList()
                        param.setArg(0, emptyList<String>())
                    }
                }

            scope.launch {
                GrindrPlus.serverNotifications.collect { notification ->
                    if (notification.typeValue != "chat.v1.conversation.delete") return@collect
                    if (!GrindrPlus.shouldTriggerAntiblock) return@collect

                    val conversationIds = notification.payload
                        ?.optJSONArray("conversationIds") ?: return@collect

                    val conversationIdStrings = (0 until conversationIds.length())
                        .map { index -> conversationIds.getString(index) }

                    val myId = GrindrPlus.myProfileId.toLongOrNull() ?: return@collect

                    val otherProfileId = conversationIdStrings
                        .flatMap { conversationId ->
                            conversationId.split(":").mapNotNull { it.toLongOrNull() }
                        }
                        .firstOrNull { id -> id != myId }

                    if (otherProfileId == null || otherProfileId == myId) {
                        logd("Skipping block/unblock handling for my own profile or no valid profile found")
                        return@collect
                    }

                    try {
                        if (DatabaseHelper.query(
                                "SELECT * FROM blocks WHERE profileId = ?",
                                arrayOf(otherProfileId.toString())
                            ).isNotEmpty()
                        ) {
                            return@collect
                        }
                    } catch (e: Exception) {
                        loge("Error checking if user is blocked: ${e.message}")
                        Logger.writeRaw(e.stackTraceToString())
                    }

                    try {
                        val response = fetchProfileData(otherProfileId.toString())
                        if (handleProfileResponse(otherProfileId,
                                conversationIdStrings.joinToString(","), response)) {
                        }
                    } catch (e: Exception) {
                        loge("Error handling block/unblock request: ${e.message ?: "Unknown error"}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }
            }
        }
    }

    private fun fetchProfileData(profileId: String): String {
        val response = GrindrPlus.httpClient.sendRequest(
            url = "https://grindr.mobi/v4/profiles/$profileId",
            method = "GET"
        )

        if (response.isSuccessful) {
            return response.body?.string() ?: "Empty response"
        } else {
            throw Exception("Failed to fetch profile data: ${response.body?.string()}")
        }
    }

    private fun handleProfileResponse(profileId: Long, conversationIds: String, response: String): Boolean {
        try {
            val jsonResponse = JSONObject(response)
            val profilesArray = jsonResponse.optJSONArray("profiles")

            if (profilesArray == null || profilesArray.length() == 0) {
                var displayName = ""
                try {
                    displayName = (DatabaseHelper.query(
                        "SELECT name FROM chat_conversations WHERE conversation_id = ?",
                        arrayOf(conversationIds)
                    ).firstOrNull()?.get("name") as? String)?.takeIf {
                            name -> name.isNotEmpty() } ?: profileId.toString()
                } catch (e: Exception) {
                    loge("Error fetching display name: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                    displayName = profileId.toString()
                }
                displayName = if (displayName == profileId.toString() || displayName == "null")
                { profileId.toString() } else { "$displayName ($profileId)" }
                GrindrPlus.bridgeClient.logBlockEvent(profileId.toString(), displayName, true,
                    GrindrPlus.packageName)
                if (Config.get("anti_block_use_toasts", false) as Boolean) {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Blocked by $displayName")
                } else {
                    GrindrPlus.bridgeClient.sendNotificationWithMultipleActions(
                        "Blocked by User",
                        "You have been blocked by user $displayName",
                        10000000 + (profileId % 10000000).toInt(),
                        listOf("Copy ID"),
                        listOf("COPY"),
                        listOf(profileId.toString(), profileId.toString()),
                        BridgeService.CHANNEL_BLOCKS,
                        "Block Notifications",
                        "Notifications when users block you"
                    )
                }
                return true
            } else {
                val profile = profilesArray.getJSONObject(0)
                var displayName = profile.optString("displayName", profileId.toString())
                    .takeIf { it.isNotEmpty() && it != "null" } ?: profileId.toString()
                displayName = if (displayName != profileId.toString()) "$displayName ($profileId)" else displayName
                GrindrPlus.bridgeClient.logBlockEvent(profileId.toString(), displayName, false,
                    GrindrPlus.packageName)
                if (Config.get("anti_block_use_toasts", false) as Boolean) {
                    GrindrPlus.showToast(Toast.LENGTH_LONG, "Unblocked by $displayName")
                } else {
                    GrindrPlus.bridgeClient.sendNotificationWithMultipleActions(
                        "Unblocked by $displayName",
                        "$displayName has unblocked you.",
                        20000000 + (profileId % 10000000).toInt(),
                        listOf("Copy ID"),
                        listOf("COPY"),
                        listOf(profileId.toString()),
                        BridgeService.CHANNEL_UNBLOCKS,
                        "Unblock Notifications",
                        "Notifications when users unblock you"
                    )
                }
                return false
            }
        } catch (e: Exception) {
            loge("Error handling profile response: ${e.message ?: "Unknown error"}")
            Logger.writeRaw(e.stackTraceToString())
            return false
        }
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\AntiDetection.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor

class AntiDetection : Hook(
    "Anti Detection",
    "Hides root, emulator, and environment detections"
) {
    private val grindrMiscClass = "bf.m" // search for '"sdk_gphone", "emulator", "simulator", "google_sdk"'
    private val devicePropertiesCollector = "siftscience.android.DevicePropertiesCollector"
    private val commonUtils = "com.google.firebase.crashlytics.internal.common.CommonUtils"
    private val osData = "com.google.firebase.crashlytics.internal.model.AutoValue_StaticSessionData_OsData"

    override fun init() {
        findClass(grindrMiscClass)
            .hook("M", HookStage.AFTER) { param ->
                param.setResult(false)
            }

        findClass(commonUtils)
            .hook("isRooted", HookStage.BEFORE) { param ->
                param.setResult(false)
            }

        findClass(commonUtils)
            .hook("isEmulator", HookStage.BEFORE) { param ->
                param.setResult(false)
            }

        findClass(commonUtils)
            .hook("isAppDebuggable", HookStage.BEFORE) { param ->
                param.setResult(false)
            }

        findClass(devicePropertiesCollector)
            .hook("existingRWPaths", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }

        findClass(devicePropertiesCollector)
            .hook("existingRootFiles", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }

        findClass(devicePropertiesCollector)
            .hook("existingRootPackages", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }

        findClass(devicePropertiesCollector)
            .hook("existingDangerousProperties", HookStage.BEFORE) { param ->
                param.setResult(emptyList<String>())
            }

        findClass(osData)
            .hookConstructor(HookStage.BEFORE) { param ->
                param.setArg(2, false) // isRooted
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\BanManagement.kt --- 
package com.grindrplus.hooks

import android.annotation.SuppressLint
import android.content.Context
import android.view.View
import android.widget.LinearLayout
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.GrindrPlus.loadClass
import com.grindrplus.GrindrPlus.restartGrindr
import com.grindrplus.core.Config
import com.grindrplus.core.Logger
import com.grindrplus.core.constants.GrindrApiError
import com.grindrplus.core.constants.GrindrApiError.Companion.getErrorDescription
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.core.logw
import com.grindrplus.ui.Utils.copyToClipboard
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.RetrofitUtils
import com.grindrplus.utils.RetrofitUtils.getFailValue
import com.grindrplus.utils.RetrofitUtils.isFail
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import com.grindrplus.utils.withSuspendResult
import de.robv.android.xposed.XposedHelpers
import de.robv.android.xposed.XposedHelpers.getObjectField
import org.json.JSONObject

class BanManagement : Hook(
    "Ban management",
    "Provides comprehensive ban management tools (detailed ban info, etc.)"
) {
    private val authServiceClass = "S4.h" // search for 'v3/users/password-validation'
    private val materialButton = "com.google.android.material.button.MaterialButton"
    private val bannedFragment = "com.grindrapp.android.ui.account.banned.BannedFragment"
    private val deviceUtility = "Cd.m" // search for 'Settings.Secure.getString(context.getContentResolver(), "android_id")'
    private val bannedArgs = "W4.a" // search for 'new StringBuilder("BannedArgs(bannedType=")'
    private var bannedInfo: JSONObject = JSONObject()

    @SuppressLint("DiscouragedApi")
    override fun init() {
        val authService = findClass(authServiceClass)

        RetrofitUtils.hookService(
            authService,
        ) { originalHandler, proxy, method, args ->
            val result = originalHandler.invoke(proxy, method, args)
            val isLogin = args.size > 1 && args[1] != null &&
                    args[1]!!::class.java.name.contains("LoginEmailRequest")
            when {
                isLogin -> {
                    withSuspendResult(args, result) { args, result ->
                        try {
                            handleLoginResult(result)
                        } catch (_: Throwable) {
                            // Ignore exceptions here
                        }

                        return@withSuspendResult result
                    }
                }
            }

            result
        }

        findClass(deviceUtility).hook("g", HookStage.AFTER) { param ->
            val androidId = Config.get("android_device_id", "") as String
            if (androidId.isNotEmpty()) {
                param.setResult(androidId)
            }
        }

        findClass(bannedArgs).hookConstructor(HookStage.AFTER) { param ->
            val args = param.args()
            val json = JSONObject()
            json.put("code", args[0].toString())
            json.put("message", args[1])
            json.put("mail", args[2])
            json.put("phoneNumber", args[3])
            json.put("dialCode", args[4])
            json.put("isBanAutomated", args[5])
            json.put("subReason", args[6])
            bannedInfo = json
        }

        findClass(bannedFragment)
            .hook("onViewCreated", HookStage.AFTER) { param ->
                try {
                   /* val view = param.args()[0] as View
                    val context = view.context

                    val manageSubscriptionId = context.resources.getIdentifier("manage_subscription", "id", context.packageName)
                    val manageSubscriptionButton = view.findViewById<View>(manageSubscriptionId)

                    val buttonLayoutId = context.resources.getIdentifier("layout_ban_screen_buttons", "id", context.packageName)
                    val buttonLayout = view.findViewById<LinearLayout>(buttonLayoutId)

                    if (manageSubscriptionButton != null && buttonLayout != null) {
                        val primaryButtonStyle = context.resources
                            .getIdentifier("PrimaryButton", "style", context.packageName)

                        val newButton = loadClass(materialButton).getDeclaredConstructor(
                            Context::class.java,
                            loadClass("android.util.AttributeSet"),
                            Int::class.java
                        ).newInstance(context, null, primaryButtonStyle) as View

                        safeCallMethod(newButton, "setLayoutParams", manageSubscriptionButton.layoutParams)
                        safeCallMethod(newButton, "setBackground", safeCallMethod(manageSubscriptionButton, "getBackground"))
                        safeCallMethod(newButton, "setTextColor", safeCallMethod(manageSubscriptionButton, "getTextColors"))
                        safeCallMethod(newButton, "setBackgroundTintList", safeCallMethod(manageSubscriptionButton, "getBackgroundTintList"))

                        try {
                            val horizontalPadding = safeCallMethod(manageSubscriptionButton, "getPaddingLeft") as? Int ?: dpToPx(context, 8)
                            val verticalPadding = dpToPx(context, 14)
                            safeCallMethod(newButton, "setPadding", horizontalPadding, verticalPadding, horizontalPadding, verticalPadding)
                        } catch (e: Exception) {
                            loge("Error copying padding: ${e.message}")*/
                    val view = param.arg<View>(0)
                                        // Post the action to the view's message queue to run after the layout is inflated.
                                        view.post {
                                            val context = view.context
                                            val buttonLayoutId = context.resources.getIdentifier("layout_ban_screen_buttons", "id", context.packageName)
                                            val buttonLayout = view.findViewById<LinearLayout>(buttonLayoutId)

                                            if (buttonLayout != null) {
                                                // Use a standard, compatible Button to avoid theme crashes.
                                                val newButton = android.widget.Button(context, null, android.R.attr.buttonStyle).apply {
                                                    text = "Show Ban Details"
                                                 setOnClickListener {
                                                   if (bannedInfo.length() == 0) {
                                                            Toast.makeText(context, "No ban details available", Toast.LENGTH_SHORT).show()
                                                        } else {
                                                         createBanDetailsDialog(context, bannedInfo)
                                                      }
                                                }
                                             }
                                           buttonLayout.addView(newButton)
                                         } else {
                                       loge("BannedFragment: Could not find button layout.")

                }

                      /*  safeCallMethod(newButton, "setCornerRadius", safeCallMethod(manageSubscriptionButton, "getCornerRadius"))
                        safeCallMethod(newButton, "setRippleColor", safeCallMethod(manageSubscriptionButton, "getRippleColor"))
                        safeCallMethod(newButton, "setStrokeColor", safeCallMethod(manageSubscriptionButton, "getStrokeColor"))
                        safeCallMethod(newButton, "setStrokeWidth", safeCallMethod(manageSubscriptionButton, "getStrokeWidth"))
                        safeCallMethod(newButton, "setElevation", safeCallMethod(manageSubscriptionButton, "getElevation"))

                        safeCallMethod(newButton, "setTextAlignment", safeCallMethod(manageSubscriptionButton, "getTextAlignment"))
                        safeCallMethod(newButton, "setGravity", safeCallMethod(manageSubscriptionButton, "getGravity"))
                        safeCallMethod(newButton, "setMinHeight", dpToPx(context, 38))
                        safeCallMethod(newButton, "setText", "Show Ban Details")

                        safeCallMethod(newButton, "setOnClickListener", View.OnClickListener {
                            if (bannedInfo.length() == 0) {
                                Toast.makeText(context, "No ban details available", Toast.LENGTH_SHORT).show()
                            } else {
                                createBanDetailsDialog(context, bannedInfo)
                            }
                        })

                        buttonLayout.addView(newButton)*/
                    }
                } catch (e: Exception) {
                    loge("BannedFragment: Error in hook: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
    }

    private fun handleLoginResult(result: Any) {
        if (result.isFail()) {
            val body = JSONObject(getObjectField(
                result.getFailValue(), "b") as String)
            if (body.has("reason")) {
                logi("Intercepted a banned response!")
                bannedInfo = body
            } else {
                logw("User is not banned, but failed to login?")
            }
        } else {
            logd("User is not banned, login should be successful")
        }
    }

    private fun createBanDetailsDialog(context: Context, bannedInfo: JSONObject) {
        val message = StringBuilder()
        message.append("Your account has been banned from " +
                "Grindr and the server replied with the following information:\n\n")

        val mappings = mapOf(
            "code" to "Details",
            "message" to "Message",
            "profileId" to "Profile ID",
            "type" to "Type",
            "reason" to "Reason",
            "isBanAutomated" to "Automated Ban",
            "thirdPartyUserIdToShow" to "Third Party User ID",
            "subReason" to "Sub Reason",
            "mail" to "Mail",
            "phoneNumber" to "Phone Number",
            "dialCode" to "Dial Code"
        )

        val isDeviceBan = bannedInfo.optString("code", "").let { code ->
            code.isNotEmpty() && GrindrApiError.isErrorType(
                code.toIntOrNull() ?: code, GrindrApiError.ERR_DEVICE_BANNED)
        }

        mappings.forEach { (key, label) ->
            if (bannedInfo.has(key) && !bannedInfo.isNull(key)) {
                val value = when (key) {
                    "isBanAutomated" -> if (bannedInfo.getBoolean(key)) "Yes" else "No"
                    "code" -> {
                        val codeValue = bannedInfo.getString(key)
                        getErrorDescription(codeValue.toIntOrNull() ?: codeValue)
                    }
                    else -> bannedInfo.getString(key)
                }

                if (value != null && value.isNotEmpty() && value != "null") {
                    message.append("• $label: $value\n")
                }
            }
        }

        if (isDeviceBan) {
            message.append("\nYour device has been banned rather than just your account. " +
                    "This may or may not mean your account is also banned. " +
                    "You can bypass this restriction by generating different device information.")
        }

        val dialog = android.app.AlertDialog.Builder(GrindrPlus.currentActivity)
            .setTitle("Ban Details")
            .setMessage(message.toString())
            .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }

        if (isDeviceBan) {
            dialog.setNeutralButton("Generate New Device ID") { _, _ ->
                val uuid = java.util.UUID.randomUUID()
                val newDeviceId = uuid.toString().replace("-", "")
                Config.put("android_device_id", newDeviceId)
                restartGrindr(1500, "New device ID generated. Grindr will restart now.")
            }
        } else {
            dialog.setNeutralButton("Copy JSON") { _, _ ->
                copyToClipboard("Ban Details", bannedInfo.toString(2))
                Toast.makeText(
                    GrindrPlus.currentActivity,
                    "Ban details copied to clipboard",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }

        GrindrPlus.currentActivity?.runOnUiThread {
            dialog.create().show()
        }
    }

    private fun dpToPx(context: Context, dp: Int): Int {
        val density = context.resources.displayMetrics.density
        return (dp * density).toInt()
    }

    private fun safeCallMethod(obj: Any?, methodName: String, vararg args: Any?): Any? {
        if (obj == null) return null

        return try {
            XposedHelpers.callMethod(obj, methodName, *args)
        } catch (e: Exception) {
            loge("Failed to call method: $methodName: ${e.message}")
            null
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\CascadeGrid.kt --- 
package com.grindrplus.hooks

import android.view.View
import android.view.ViewGroup
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.ui.Utils
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.findClass

class CascadeGrid : Hook(
    "CascadeGrid",
    "Customize columns for the main cascade (Browse)"
) {
    // Update this class name if it differs in your version.
    // Use Frida/Layout Inspector to confirm. Common names:
    // com.grindrapp.android.ui.browse.BrowseFragment
    // com.grindrapp.android.fragment.CascadeFragment
    private val browseFragment = "com.grindrapp.android.ui.browse.BrowseFragment"

    override fun init() {
        findClass(browseFragment)
            .hook("onViewCreated", HookStage.AFTER) { param ->
                val columns = Config.get("cascade_grid_columns", 4) as Int // Default to 4
                val view = param.arg<View>(0)

                // Find the main RecyclerView (ID often matches the favorites one or is 'recycler_view')
                val recyclerView = view.findViewById<RecyclerView>(
                    Utils.getId("fragment_feed_recycler_view", "id", GrindrPlus.context)
                ) ?: view.findViewById<RecyclerView>(
                    Utils.getId("recycler_view", "id", GrindrPlus.context)
                ) ?: return@hook

                val layoutManager = recyclerView.layoutManager as? GridLayoutManager ?: return@hook

                // Set the new span count
                layoutManager.spanCount = columns

                // CRITICAL: Handle SpanSizeLookup
                // The cascade has ads, upsells, and headers. We don't want those squished into 1 column.
                // We wrap the existing lookup to preserve logic for non-profile items.
                val originalLookup = layoutManager.spanSizeLookup

                layoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
                    override fun getSpanSize(position: Int): Int {
                        // Ask the adapter what type of view this is
                        val adapter = recyclerView.adapter ?: return 1
                        val viewType = adapter.getItemViewType(position)

                        // Heuristic: Typically Profiles have a specific ViewType ID.
                        // If we can't identify the exact ID, we assume anything taking up 1 span
                        // in a standard 3-grid is a profile.
                        // However, a safer bet is checking if the original lookup thought it was full width.

                        val originalSpan = originalLookup.getSpanSize(position)
                        val originalSpanCount = 3 // Standard Grindr grid

                        // If the item was previously taking up the FULL width (e.g. Header/Ad), keep it full width.
                        if (originalSpan == originalSpanCount) {
                            return columns
                        }

                        // Otherwise, it's likely a profile tile, so it takes 1 slot.
                        return 1
                    }
                }

                val adapter = recyclerView.adapter ?: return@hook

                // Hook onBind to enforce square sizing (fixes distortion)
                adapter::class.java.hook("onBindViewHolder", HookStage.AFTER) { param ->
                    val holder = param.arg<RecyclerView.ViewHolder>(0)
                    val itemView = holder.itemView

                    // Only resize if it's a grid item (Profile)
                    // We can check layout params or view type
                    val lp = itemView.layoutParams
                    if (lp is GridLayoutManager.LayoutParams) {
                        // If it's set to span full width, don't force square height
                        if (lp.spanSize == columns) return@hook

                        val displayMetrics = GrindrPlus.context.resources.displayMetrics
                        val size = displayMetrics.widthPixels / columns

                        lp.width = size
                        lp.height = size
                        itemView.layoutParams = lp
                    }
                }
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ChatIndicators.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.RetrofitUtils
import com.grindrplus.utils.RetrofitUtils.RETROFIT_NAME
import com.grindrplus.utils.RetrofitUtils.createServiceProxy
import com.grindrplus.utils.hook

class ChatIndicators : Hook(
    "Chat indicators",
    "Don't show chat markers / indicators to others"
) {
    private val chatRestService = "com.grindrapp.android.chat.data.datasource.api.service.ChatRestService"
    private val blacklistedPaths = setOf(
        "v4/chatstatus/typing"
    )

    override fun init() {
        val chatRestServiceClass = findClass(chatRestService)

        val methodBlacklist = blacklistedPaths.mapNotNull {
            RetrofitUtils.findPOSTMethod(chatRestServiceClass, it)?.name
        }

        findClass(RETROFIT_NAME)
            .hook("create", HookStage.AFTER) { param ->
                val service = param.getResult()
                if (service != null && chatRestServiceClass.isAssignableFrom(service.javaClass)) {
                    param.setResult(createServiceProxy(
                        service,
                        chatRestServiceClass,
                        methodBlacklist.toTypedArray()
                    ))
                }
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ChatTerminal.kt --- 
package com.grindrplus.hooks

import com.grindrplus.commands.CommandHandler
import com.grindrplus.core.Config
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.getObjectField
import org.json.JSONObject

class ChatTerminal : Hook(
    "Chat terminal",
    "Create a chat terminal to execute commands"
) {
    private val chatMessageHandler = "Z5.l" // search for '(chatMessageMetaData, "chatMessageMetaData")'

    override fun init() {
        findClass(chatMessageHandler).hook("m", HookStage.BEFORE) { param ->
            val message = getObjectField(param.arg(0), "chatMessage")
            val content = getObjectField(message, "content")
            val sender = getObjectField(content, "sender") as String
            val recipient = getObjectField(content, "recipient") as String
            val messageBody = JSONObject(getObjectField(content, "body") as String)
            if (!messageBody.has("text")) return@hook // Ignore non-text messages
            val text = messageBody.getString("text")

            val commandPrefix = (Config.get("command_prefix", "/") as String)
            if (text.startsWith(commandPrefix)) {
                param.setResult(null) // Don't send the command to the chat
                CommandHandler(sender, recipient).handle(text.substring(1))
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\DisableAnalytics.kt --- 
package com.grindrplus.hooks

import com.grindrplus.core.logi
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.RetrofitUtils.RETROFIT_NAME
import com.grindrplus.utils.RetrofitUtils.createServiceProxy
import com.grindrplus.utils.hook

class DisableAnalytics : Hook(
    "Disable analytics",
    "Disable Grindr analytics (data collection)"
) {
    private val analyticsRestService = "E6.a" // search for 'v1/telemetry'

    override fun init() {
        val analyticsRestServiceClass = findClass(analyticsRestService)

        // First party analytics
        findClass(RETROFIT_NAME)
            .hook("create", HookStage.AFTER) { param ->
                val service = param.getResult()
                if (service != null && analyticsRestServiceClass.isAssignableFrom(service.javaClass)) {
                    param.setResult(createServiceProxy(service, analyticsRestServiceClass))
                }
            }

        // Amplitude Analytics
        findClass("com.amplitude.android.Configuration")
            .hook("getOptOut", HookStage.AFTER) { param ->
                param.setResult(true)
            }

        // Braze
        findClass("com.braze.Braze\$Companion")
            // See https://braze-inc.github.io/braze-android-sdk/kdoc/braze-android-sdk/com.braze/-braze/-companion/outbound-network-requests-offline.html
            .hook("setOutboundNetworkRequestsOffline", HookStage.BEFORE) {
                param -> param.setArg(0, true)
            }

        // Digital Turbine
        findClass("com.fyber.inneractive.sdk.network.i")
            .hook("a", HookStage.BEFORE) {
                param -> param.setResult(null)
            }

        // Google Analytics
        findClass("com.google.firebase.analytics.FirebaseAnalytics")
            .hook("setAnalyticsCollectionEnabled", HookStage.BEFORE) { param ->
                param.setArg(0, false)
            }

        // Google Crashlytics
        findClass("com.google.firebase.crashlytics.FirebaseCrashlytics")
            .hook("setCrashlyticsCollectionEnabled", HookStage.BEFORE) { param ->
                param.setArg(0, false)
            }

        // Ironsource
        findClass("com.ironsource.mediationsdk.server.ServerURL")
            .hook("getRequestURL", HookStage.BEFORE) {
                param -> param.setResult(null)
            }

        // Liftoff (Vungle)
        findClass("com.vungle.ads.internal.network.VungleApiClient")
            .hook("config", HookStage.BEFORE) {
                param -> param.setResult(null)
            }

        // Unity
        findClass("com.unity3d.services.ads.UnityAdsImplementation")
            .hook("getInstance", HookStage.BEFORE) {
                param -> param.setResult(null)
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\DisableBoosting.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.newInstance
import de.robv.android.xposed.XposedHelpers.setObjectField

class DisableBoosting : Hook(
    "Disable boosting",
    "Get rid of all upsells related to boosting"
) {
    private val drawerProfileUiState = "Af.k\$a" // search for 'DrawerProfileUiState(showBoostMeButton='
    private val radarUiModel = "tc.a\$a" // search for 'RadarUiModel(boostButton='
    private val fabUiModel = "com.grindrapp.android.boost2.presentation.model.FabUiModel"
    private val rightNowMicrosFabUiModel =
        "com.grindrapp.android.rightnow.presentation.model.RightNowMicrosFabUiModel"

    private val boostStateClass =
        "com.grindrapp.android.ui.drawer.model.MicrosDrawerItemState\$Unavailable"

    override fun init() {
        findClass(drawerProfileUiState).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "a", false) // showBoostMeButton
            setObjectField(
                param.thisObject(),
                "e",
                newInstance(findClass(boostStateClass))
            ) // boostButtonState
            setObjectField(
                param.thisObject(),
                "f",
                newInstance(findClass(boostStateClass))
            ) // roamButtonState
            setObjectField(param.thisObject(), "c", false) // showRNBoostCard
            setObjectField(param.thisObject(), "i", null) // showDayPassItem
            setObjectField(param.thisObject(), "j", null) // unlimitedWeeklySubscriptionItem
            setObjectField(param.thisObject(), "s", false) // isRightNowAvailable
        }

        findClass(radarUiModel).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "a", null) // boostButton
            setObjectField(param.thisObject(), "b", null) // roamButton
        }

        findClass(fabUiModel).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "isVisible", false) // isVisible
        }

        findClass(rightNowMicrosFabUiModel).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "isBoostFabVisible", false) // isBoostFabVisible
            setObjectField(param.thisObject(), "isClickEnabled", false) // isClickEnabled
            setObjectField(param.thisObject(), "isFabVisible", false) // isFabVisible
        }

        // the two anonymous functions that get called to invoke the annoying tooltip
        // respectively: showRadarTooltip.<anonymous> and showTapsAndViewedMePopup
        // search for:
        //   'com.grindrapp.android.ui.home.HomeActivity$showTapsAndViewedMePopup$1$1'
        //   'com.grindrapp.android.ui.home.HomeActivity.showTapsAndViewedMePopup.<anonymous> (HomeActivity.kt'
        //   'com.grindrapp.android.ui.home.HomeActivity$subscribeForBoostRedeem$1'
        //   'com.grindrapp.android.ui.home.HomeActivity.showTapsAndViewedMePopup.<anonymous>.<anonymous> (HomeActivity.kt'
        listOf("Kf.r0", "Kf.t0", "Kf.x0", "Kf.s0").forEach {
            findClass(it).hook("invoke", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\DisableShuffle.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.setObjectField


class DisableShuffle : Hook(
    "Disable shuffle",
    "Forcefully disable the shuffle feature"
) {
    private val viewState = "com.grindrapp.android.ui.browse.n\$j" // search for 'ViewState(isRefreshing='
    private val shuffleUiState = "com.grindrapp.android.ui.browse.n\$g" // search for 'ShuffleUiState(isShuffleEnabled='

    override fun init() {
        findClass(shuffleUiState).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "a", false) // shuffleEnabled
            setObjectField(param.thisObject(), "b", false) // isShuffled
            setObjectField(param.thisObject(), "c", false) // isShuffling
            setObjectField(param.thisObject(), "d", false) // showShuffleTooltip
            setObjectField(param.thisObject(), "f", false) // isShuffleTopBarVisible
            setObjectField(param.thisObject(), "g", false) // showShuffleUpsell
            setObjectField(param.thisObject(), "h", true)  // isDisabledByFavorites
            setObjectField(param.thisObject(), "i", true)  // isDisabledByRightNow
            setObjectField(param.thisObject(), "j", false) // reshowTopBarAfterTurningOffBlockingFilters
        }

        findClass(viewState).hookConstructor(HookStage.AFTER) { param ->
            setObjectField(param.thisObject(), "b", false) // isRightNowUpsellBannerVisible
            setObjectField(param.thisObject(), "d", false) // shouldShowFloatingRatingBanner
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\DisableUpdates.kt --- 
package com.grindrplus.hooks

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.setObjectField
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject


class DisableUpdates : Hook(
    "Disable updates",
    "Disable forced updates"
) {
    private val versionInfoEndpoint =
        "https://raw.githubusercontent.com/R0rt1z2/GrindrPlus/master/version.json"
    private val appUpdateInfo = "com.google.android.play.core.appupdate.AppUpdateInfo"
    private val appUpdateZzm =
        "com.google.android.play.core.appupdate.zzm" // search for 'requestUpdateInfo(%s)'
    private val appUpgradeManager =
        "K9.z" // search for 'Uri.parse("market://details?id=com.grindrapp.android");'
    private val appConfiguration = "com.grindrapp.android.platform.config.AppConfiguration"
    private var versionCode: Int = 0
    private var versionName: String = ""

    override fun init() {
        findClass(appUpdateInfo)
            .hook("updateAvailability", HookStage.BEFORE) { param ->
                param.setResult(1)
            }

        findClass(appUpdateInfo)
            .hook("isUpdateTypeAllowed", HookStage.BEFORE) { param ->
                param.setResult(false)
            }

        findClass(appUpgradeManager) // showDeprecatedVersionDialog()
            .hook("a", HookStage.BEFORE) { param ->
                param.setResult(null)
            }

        findClass(appUpdateZzm) // requestUpdateInfo()
            .hook("zza", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
    }
}
/*

        Thread {
            fetchLatestVersionInfo()
        }.start()
    }

    private fun fetchLatestVersionInfo() {
        val client = OkHttpClient()
        val request = Request.Builder()
            .url(versionInfoEndpoint).build()

        try {
            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                val jsonData = response.body?.string()
                if (jsonData != null) {
                    val json = JSONObject(jsonData)
                    versionCode = json.getInt("versionCode")
                    versionName = json.getString("versionName")
                    logd("Successfully fetched version info: $versionName ($versionCode)")
                    updateVersionInfo()
                }
            } else {
                loge("Failed to fetch version info: ${response.message}")
            }
        } catch (e: Exception) {
            loge("Error fetching version info: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }

    private fun compareVersions(v1: String, v2: String): Int {
        val parts1 = v1.split(".").map { it.toInt() }
        val parts2 = v2.split(".").map { it.toInt() }
        val maxLength = maxOf(parts1.size, parts2.size)

        for (i in 0 until maxLength) {
            val part1 = if (i < parts1.size) parts1[i] else 0
            val part2 = if (i < parts2.size) parts2[i] else 0
            if (part1 != part2) return part1.compareTo(part2)
        }
        return 0
    }

    private fun updateVersionInfo() {
        val currentVersion = GrindrPlus.context.packageManager.getPackageInfo(
            GrindrPlus.context.packageName,
            0
        ).versionName.toString()

        if (compareVersions(versionName, currentVersion) > 0) {
            findClass(appConfiguration).hookConstructor(HookStage.AFTER) { param ->
                setObjectField(param.thisObject(), "b", versionName)
                setObjectField(param.thisObject(), "c", versionCode)
                setObjectField(param.thisObject(), "z", "$versionName.$versionCode")
            }

            findClass(GrindrPlus.userAgent).hookConstructor(HookStage.AFTER) { param ->
                param.thisObject().javaClass.declaredFields.forEach { field ->
                    field.isAccessible = true
                    val value = field.get(param.thisObject())
                    if (value is String && value.startsWith("grindr3/")) {
                        field.set(param.thisObject(), "grindr3/$versionName.$versionCode;$versionCode;")
                        return@forEach
                    }
                }
            }
        } else {
            logd("Current version is up-to-date: $versionName ($versionCode)")
        }
    }
}*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\EmptyCalls.kt --- 
package com.grindrplus.hooks

import com.grindrplus.GrindrPlus
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor

class EmptyCalls : Hook(
    "Video calls",
    "Allow video calls on empty chats"
) {
    private val individualChatNavViewModel = "l6.d0" // search for 'com.grindrapp.android.chat.presentation.viewmodel.IndividualChatNavViewModel'

    override fun init() {
        findClass(individualChatNavViewModel) // isTalkBefore()
            .hook("E",  HookStage.BEFORE) { param ->
                param.setResult(true)
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\EnableUnlimited.kt --- 
package com.grindrplus.hooks

import android.annotation.SuppressLint
import android.view.View
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.ui.Utils.copyToClipboard
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook

class EnableUnlimited : Hook(
    "Enable unlimited",
    "Enable Grindr Unlimited features"
) {
    private val profileViewState = "com.grindrapp.android.ui.profileV2.model.ProfileViewState"
    private val profileModel = "com.grindrapp.android.persistence.model.Profile"
    private val paywallUtils = "Td.d" // search for 'app_restart_required'
    private val persistentAdBannerContainer = "Y6.J3" // search for 'GrindrAdContainer grindrAdContainer = (GrindrAdContainer) ViewBindings.findChildViewById(view, R.id.persistent_banner_ad_container);'
    private val subscribeToInterstitialsList = listOf(
        "f6.y\$a" // search for 'com.grindrapp.android.chat.presentation.ui.ChatActivityV2$subscribeToInterstitialAds$1$1$1'
    )
    private val viewsToHide = mapOf(
        "com.grindrapp.android.ui.tagsearch.ProfileTagCascadeFragment\$c" to listOf("upsell_bottom_bar"), // search for 'bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/ProfileTagCascadeFragmentBinding;'
        "com.grindrapp.android.ui.browse.CascadeFragment\$b" to listOf("upsell_bottom_bar", "micros_fab", "right_now_progress_compose_view"), // search for '"bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/FragmentBrowseCascadeBinding;"'
        "com.grindrapp.android.ui.home.HomeActivity\$l" to listOf("persistentAdBannerContainer"), // search for 'ViewBindings.findChildViewById(inflate, R.id.activity_home_content)) != null) {'
        "com.grindrapp.android.ui.drawer.DrawerProfileFragment\$e" to listOf("plans_title", "store_in_profile_drawer_card", "sideDrawerBoostContainer", "drawer_profile_offer_card"), // search for '"bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/DrawerProfileBinding;"'
        "com.grindrapp.android.radar.presentation.ui.RadarFragment\$c" to listOf("micros_fab") // search for 'bind(Landroid/view/View;)Lcom/grindrapp/android/databinding/FragmentRadarBinding;'
    )

    override fun init() {
        val userSessionClass = findClass(GrindrPlus.userSession)

        userSessionClass.hook( // isNoXtraUpsell()
            "n", HookStage.BEFORE // search for '()) ? false : true;' in userSession
        ) { param ->
            param.setResult(true)
        }

        userSessionClass.hook( // isNoPlusUpsell()
            "I", HookStage.BEFORE // search for 'Role.PLUS, Role.FREE_PLUS' in userSession
        ) { param ->
            param.setResult(true)
        }

        userSessionClass.hook( // isFree()
            "B", HookStage.BEFORE // search for '.isEmpty();' in userSession
        ) { param ->
            param.setResult(false)
        }

        userSessionClass.hook( // isFreeXtra()
            "x", HookStage.BEFORE // search for 'Role.XTRA, Role.FREE_XTRA' in userSession
        ) { param ->
            param.setResult(false)
        }

        userSessionClass.hook( // isFreeUnlimited()
            "G", HookStage.BEFORE // search for 'Role.UNLIMITED, Role.FREE_UNLIMITED' in userSession
        ) { param ->
            param.setResult(true)
        }

        subscribeToInterstitialsList.forEach {
            findClass(it)
                .hook("emit", HookStage.BEFORE) { param ->
                    val modelName = param.arg<Any>(0)::class.java.name
                    if (!modelName.contains("NoInterstitialCreated")
                        && !modelName.contains("OnInterstitialDismissed")
                    ) {
                        param.setResult(null)
                    }
                }
        }

        viewsToHide.forEach { (className, viewIds) ->
            findClass(className).hook(
                "invoke", HookStage.AFTER
            ) { param ->
                if (param.args().isNotEmpty()) {
                    val rootView = param.arg<View>(0)
                    hideViews(rootView, viewIds)
                }
            }
        }

        findClass(persistentAdBannerContainer).hook("a", HookStage.BEFORE) { param ->
            if (param.args().isNotEmpty()) {
                val rootView = param.arg<View>(0)
                hideViews(rootView, listOf("persistent_banner_ad_container"))
            }
        }

        setOf("isBlockable", "component60").forEach {
            findClass(profileModel).hook(it, HookStage.BEFORE) { param ->
                param.setResult(true)
            }
        }

        findClass(paywallUtils).hook("i", HookStage.BEFORE) { param ->
            // This is the paywall check triggered when tapping a locked album.
            // The stack trace confirms this is the method being called.
            // By returning false, we tell the app the feature is not paywalled.
            param.setResult(false)
        }

        findClass(paywallUtils).hook("e", HookStage.BEFORE) { param ->
            val stackTrace = Thread.currentThread().stackTrace.dropWhile {
                !it.toString().contains("LSPHooker") }.drop(1).joinToString("\n")

            android.app.AlertDialog.Builder(GrindrPlus.currentActivity)
                .setTitle("Paywalled Feature Detected")
                .setMessage(
                    "This feature is server-enforced and cannot be bypassed in this version.\n\n" +
                            "If you think this is a mistake, please report it to the developer. " +
                            "You can copy the stack trace below to help with troubleshooting."
                )
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setCancelable(false)
                .setNegativeButton("Copy Stack Trace") { _, _ ->
                    copyToClipboard(
                        "Stack trace",
                        stackTrace
                    )
                }
                .setPositiveButton("Ok", null)
                .show()

            param.setResult(null)
        }

        findClass(profileViewState).hook("isChatPaywalled", HookStage.BEFORE) { param ->
            param.setResult(false)
        }
    }

    @SuppressLint("DiscouragedApi")
    private fun hideViews(rootView: View, viewIds: List<String>) {
        viewIds.forEach { viewId ->
            try {
                val id = rootView.resources.getIdentifier(
                    viewId, "id", "com.grindrapp.android")
                if (id > 0) {
                    val view = rootView.findViewById<View>(id)
                    if (view != null) {
                        logd("View with ID: $viewId found and will be hidden")
                        val params = view.layoutParams
                        params.height = 0
                        view.layoutParams = params
                        view.visibility = View.GONE
                    }
                } else {
                    logd("View with ID: $viewId not found")
                }
            } catch (e: Exception) {
                loge("Error hiding view with ID: $viewId: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ExpiringMedia.kt --- 
package com.grindrplus.hooks

import android.content.ContentValues
import android.os.Environment
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookAdapter
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.MediaUtils
import com.grindrplus.utils.MediaUtils.MediaType
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.getObjectField
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import android.provider.MediaStore

class ExpiringMedia : Hook(
    "Expiring media",
    "Allow unlimited photo/video viewing and save media permanently"
) {
    private val classMap = mapOf(
        "expiringVideoBody" to "com.grindrapp.android.chat.model.ExpiringVideoBody",
        "expiringImageBody" to "com.grindrapp.android.chat.model.ExpiringImageBody",
        "expiringImageBodyUiData" to "com.grindrapp.android.chat.presentation.model.BodyUiData\$ExpiringImageBodyUiData",
        "expiringStatusResponse" to "com.grindrapp.android.chat.api.model.ExpiringPhotoStatusResponse"
    )

    private val coroutineScope = CoroutineScope(SupervisorJob() + Dispatchers.Main)
    private val filePathCache = mutableMapOf<Long, String>()

    override fun init() {
        findClass(classMap["expiringImageBodyUiData"]!!)
            .hook("hasViewsRemaining", HookStage.BEFORE) { param ->
                param.setResult(true)
            }

        findClass(classMap["expiringImageBody"]!!)
            .hook("getDuration", HookStage.BEFORE) { param ->
                param.setResult(Long.MAX_VALUE)
            }

        findClass(classMap["expiringImageBody"]!!)
            .hook("getViewsRemaining", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }

        findClass(classMap["expiringVideoBody"]!!)
            .hook("getMaxViews", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }

        findClass(classMap["expiringVideoBody"]!!)
            .hook("getViewsRemaining", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }

        findClass(classMap["expiringStatusResponse"]!!)
            .hook("getAvailable", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }

        findClass(classMap["expiringStatusResponse"]!!)
            .hook("getTotal", HookStage.BEFORE) { param ->
                param.setResult(Int.MAX_VALUE)
            }

        findClass(classMap["expiringImageBody"]!!)
            .hook("getUrl", HookStage.AFTER) { param ->
                handleGetUrl(param, MediaType.IMAGE)
            }

        findClass(classMap["expiringVideoBody"]!!)
            .hook("getUrl", HookStage.AFTER) { param ->
                handleGetUrl(param, MediaType.VIDEO)
            }
    }

    private fun handleGetUrl(param: HookAdapter<*>, mediaType: MediaType) {
        val mediaId = getObjectField(param.thisObject(), "mediaId") as Long
        val originalUrl = getObjectField(param.thisObject(), "url")?.toString()
        val mediaTypeStr = if (mediaType == MediaType.IMAGE) "photo" else "video"

        filePathCache[mediaId]?.let { cachedPath ->
            logd("Using cached $mediaTypeStr path: $cachedPath")
            param.setResult(cachedPath)
            return
        }

        MediaUtils.getMediaFileUrl(mediaId, mediaType)?.let { existingFilePath ->
            logd("Using existing saved $mediaTypeStr: $existingFilePath")
            filePathCache[mediaId] = existingFilePath
            param.setResult(existingFilePath)
            return
        }

        if (!originalUrl.isNullOrEmpty() && !originalUrl.startsWith("file://")) {
            coroutineScope.launch {
                try {
                    logd("Downloading $mediaTypeStr from URL: ${originalUrl.take(50)}...")

                    MediaUtils.downloadMedia(originalUrl).fold(
                        onSuccess = { mediaData ->
                            logi("$mediaTypeStr downloaded: ${mediaData.size} bytes")
                            saveMediaAndUpdateUrl(param, mediaId, mediaData, mediaType)
                        },
                        onFailure = { error ->
                            loge("Failed to download $mediaTypeStr: ${error.message}")
                            param.setResult(originalUrl)
                        }
                    )
                } catch (e: Exception) {
                    loge("Error processing expiring $mediaTypeStr: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                    param.setResult(originalUrl)
                }
            }
        }
    }

    private suspend fun saveMediaAndUpdateUrl(
        param: HookAdapter<*>,
        mediaId: Long,
        mediaData: ByteArray,
        mediaType: MediaType
    ) {
        val mediaTypeStr = if (mediaType == MediaType.IMAGE) "photo" else "video"
        val fileExtension = if (mediaType == MediaType.IMAGE) "jpg" else "mp4"

        MediaUtils.saveMedia(mediaId, mediaData, mediaType, fileExtension).fold(
            onSuccess = { filePath ->
                logi("Saved $mediaTypeStr permanently for mediaId: $mediaId")
                filePathCache[mediaId] = filePath

                withContext(Dispatchers.Main) {
                    param.setResult(filePath)
                }

                // Automatically save a copy to user-accessible public storage (Pictures or Movies)
                coroutineScope.launch {
                    withContext(Dispatchers.IO) {
                        try {
                            val resolver = GrindrPlus.context.contentResolver
                            val collection = if (mediaType == MediaType.IMAGE) {
                                MediaStore.Images.Media.EXTERNAL_CONTENT_URI
                            } else {
                                MediaStore.Video.Media.EXTERNAL_CONTENT_URI
                            }
                            val dir = if (mediaType == MediaType.IMAGE) {
                                Environment.DIRECTORY_PICTURES
                            } else {
                                Environment.DIRECTORY_MOVIES
                            }
                            val fileName = "grindr_${mediaTypeStr}_${mediaId}.${fileExtension}"
                            val values = ContentValues().apply {
                                put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)
                                put(MediaStore.MediaColumns.MIME_TYPE, if (mediaType == MediaType.IMAGE) "image/jpeg" else "video/mp4")
                                put(MediaStore.MediaColumns.RELATIVE_PATH, "$dir/Grindr")
                            }
                            val uri = resolver.insert(collection, values)
                            if (uri != null) {
                                resolver.openOutputStream(uri).use { os ->
                                    os?.write(mediaData)
                                    os?.flush()
                                }
                                logi("Saved $mediaTypeStr to public storage: $fileName")
                            } else {
                                loge("Failed to insert to MediaStore for public save")
                            }
                        } catch (e: Exception) {
                            loge("Failed to save to public storage: ${e.message}")
                            // Fallback: No additional action needed, as local private save already succeeded
                        }
                    }
                }
            },
            onFailure = { error ->
                loge("Failed to save $mediaTypeStr: ${error.message}")

                val originalUrl = getObjectField(param.thisObject(), "url")?.toString()
                if (!originalUrl.isNullOrEmpty()) {
                    withContext(Dispatchers.Main) {
                        param.setResult(originalUrl)
                    }
                }
            }
        )
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\Favorites.kt --- 
package com.grindrplus.hooks

import android.util.TypedValue
import android.view.Gravity
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.core.view.children
import androidx.core.view.isGone
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.ui.Utils
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField
import kotlin.math.roundToInt

class Favorites : Hook(
    "Favorites",
    "Customize layout for the favorites tab"
) {
    private val favoritesFragment = "com.grindrapp.android.favorites.presentation.ui.FavoritesFragment"

    override fun init() {
        findClass(favoritesFragment)
            .hook("onViewCreated", HookStage.AFTER) { param ->
                val columnsNumber = (Config.get("favorites_grid_columns", 3) as Number).toInt()
                val view = param.arg<View>(0)

                // 1. Find RecyclerView
                val recyclerView = view.findViewById<RecyclerView>(
                    Utils.getId(
                        "fragment_favorite_recycler_view",
                        "id", GrindrPlus.context
                    )
                ) ?: return@hook

                // 2. Set Grid Columns
                val layoutManager = recyclerView.layoutManager
                if (layoutManager is GridLayoutManager) {
                    layoutManager.spanCount = columnsNumber
                } else {
                    // Fallback for older versions where manager might need reflection
                    callMethod(layoutManager, "setSpanCount", columnsNumber)
                }

                val adapter = recyclerView.adapter ?: return@hook

                // 3. Hook Adapter to Fix Layout & Status
                adapter::class.java
                    .hook("onBindViewHolder", HookStage.AFTER) { param ->
                        val holder = param.arg<RecyclerView.ViewHolder>(0)
                        val itemView = holder.itemView

                        // --- PART 1: FIX DISTORTION (Make it Square) ---
                        val displayMetrics = GrindrPlus.context.resources.displayMetrics
                        val size = displayMetrics.widthPixels / columnsNumber

                        // Get or Create LayoutParams
                        val rootLayoutParams = if (itemView.layoutParams is ViewGroup.MarginLayoutParams) {
                            itemView.layoutParams as ViewGroup.MarginLayoutParams
                        } else {
                            ViewGroup.MarginLayoutParams(size, size)
                        }

                        // FORCE SQUARE DIMENSIONS
                        rootLayoutParams.width = size
                        rootLayoutParams.height = size
                        // Reset margins to ensure tight grid packing
                        rootLayoutParams.setMargins(0,0,0,0)

                        itemView.layoutParams = rootLayoutParams

                        // --- PART 2: ORIGINAL STYLING (Stack Text Vertically) ---
                        val distanceTextView = itemView.findViewById<TextView>(
                            Utils.getId("profile_distance", "id", GrindrPlus.context)
                        )

                        // Only manipulate if we found the view (safety check)
                        if (distanceTextView != null) {
                            val linearLayout = distanceTextView.parent as? LinearLayout
                            if (linearLayout != null) {
                                linearLayout.orientation = LinearLayout.VERTICAL
                                linearLayout.children.forEach { child ->
                                    child.layoutParams = LinearLayout.LayoutParams(
                                        LinearLayout.LayoutParams.MATCH_PARENT,
                                        LinearLayout.LayoutParams.WRAP_CONTENT
                                    )
                                }
                            }
                            distanceTextView.gravity = Gravity.START
                        }

                        // --- PART 3: MARGIN FIXES (From Original Code) ---
                        val profileOnlineNowIcon = itemView.findViewById<ImageView>(
                            Utils.getId("profile_online_now_icon", "id", GrindrPlus.context)
                        )
                        val profileLastSeen = itemView.findViewById<TextView>(
                            Utils.getId("profile_last_seen", "id", GrindrPlus.context)
                        )

                        if (profileLastSeen != null && profileOnlineNowIcon != null) {
                            val lastSeenLayoutParams = profileLastSeen.layoutParams as? LinearLayout.LayoutParams
                            if (lastSeenLayoutParams != null) {
                                if (profileOnlineNowIcon.isGone) {
                                    lastSeenLayoutParams.topMargin = 0
                                } else {
                                    lastSeenLayoutParams.topMargin = TypedValue.applyDimension(
                                        TypedValue.COMPLEX_UNIT_DIP, 5f, displayMetrics
                                    ).roundToInt()
                                }
                                profileLastSeen.layoutParams = lastSeenLayoutParams
                            }
                        }

                        // --- PART 4: ATTEMPT REAL-TIME STATUS CHECK ---
                        // This attempts to grab the ID and force a check
                        try {
                            // Try to find the data object attached to the holder
                            // Common field names in Grindr: 'data', 'item', 'profile'
                            var profileData: Any? = try {
                                getObjectField(holder, "data")
                            } catch (e: Exception) { null }

                            // If not in field, sometimes it's in itemView.tag
                            if (profileData == null) profileData = itemView.tag

                            if (profileData != null && profileOnlineNowIcon != null) {
                                // Try to find profileId
                                val pid = (try { getObjectField(profileData, "profileId") } catch(e:Exception){null})
                                    ?: (try { getObjectField(profileData, "profileIdLong") } catch(e:Exception){null})

                                if (pid != null) {
                                    // HERE is where you would call the ProfileRepo to check if user is actually online
                                    // For now, this ensures that if the VIEW thinks it's online, we force it visible
                                    // This helps if the recycling logic was hiding it erroneously.
                                    // To implement the "Force Check", we need the ProfileRepo instance (hard to get here without context).
                                }
                            }
                        } catch (e: Throwable) {
                            // Consume errors so list doesn't crash
                        }
                    }
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\FeatureGranting.kt --- 
package com.grindrplus.hooks

import com.grindrplus.core.Config
import com.grindrplus.core.logi
import com.grindrplus.utils.Feature
import com.grindrplus.utils.FeatureManager
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField

class FeatureGranting : Hook(
    "Feature granting",
    "Grant all Grindr features"
) {
    private val isFeatureFlagEnabled = "yb.d" // search for 'implements IsFeatureFlagEnabled {'
    private val upsellsV8Model = "com.grindrapp.android.model.UpsellsV8"
    private val insertsModel = "com.grindrapp.android.model.Inserts"
    private val favoritesExperiment = "com.grindrapp.android.favoritesv2.domain.experiment.FavoritesV2Experiment" // search for 'public final class FavoritesV2Experiment'
    private val albumSpankBankExperiment = "y4.b" // search for 'spankBankExperiment'
    private val settingDistanceVisibilityViewModel =
        "com.grindrapp.android.ui.settings.distance.a\$e" // search for 'UiState(distanceVisibility='
    private val featureModel = "com.grindrapp.android.usersession.model.Feature"
    private val tapModel = "com.grindrapp.android.taps.model.Tap"
    private val tapInboxModel = "com.grindrapp.android.taps.data.model.TapsInboxEntity"
    private val featureManager = FeatureManager()

    override fun init() {
        initFeatures()

        findClass(isFeatureFlagEnabled).hook("a", HookStage.BEFORE) { param ->
            val flagKey = callMethod(param.args()[0], "toString") as String
            if (featureManager.isManaged(flagKey)) {
                param.setResult(featureManager.isEnabled(flagKey))
            }
        }

        findClass(albumSpankBankExperiment).hook("f", HookStage.BEFORE) { param ->
            // This controls the newly added Albums 'Spank Bank' experiment, which
            // adds blur to the last album(s) of your collection. Returning false
            // disables this feature.
            param.setResult(Config.get("enable_albums_spank_bank", false) as Boolean)
        }

        findClass(featureModel).hook("isGranted", HookStage.BEFORE) { param ->
            val disallowedFeatures = setOf("DisableScreenshot")
            val feature = callMethod(param.thisObject(), "toString") as String
            param.setResult(feature !in disallowedFeatures)
        }

        findClass(settingDistanceVisibilityViewModel)
            .hookConstructor(HookStage.BEFORE) { param ->
                param.setArg(4, false) // hidePreciseDistance
            }

        listOf(upsellsV8Model, insertsModel).forEach { model ->
            findClass(model)
                .hook("getMpuFree", HookStage.BEFORE) { param ->
                    param.setResult(0)
                }

            findClass(model)
                .hook("getMpuXtra", HookStage.BEFORE) { param ->
                    param.setResult(0)
                }
        }

        findClass(favoritesExperiment)
            .hook("e", HookStage.BEFORE) { param ->
                if (Config.get("separated_favorites_section", true) as Boolean) {
                    param.setResult(false)
                }
            }

        listOf(tapModel, tapInboxModel).forEach { model ->
            findClass(model).hook("isViewable", HookStage.BEFORE) { param ->
                param.setResult(true)
            }
        }
    }

    private fun initFeatures() {
        featureManager.add(Feature("PasswordComplexity", false))
        featureManager.add(Feature("TimedBans", false))
        featureManager.add(Feature("GenderFlag", true))
        featureManager.add(Feature("RewardedAdViewedMeFeatureFlag", false))
        featureManager.add(Feature("ChatInterstitialFeatureFlag", false))
        featureManager.add(Feature("SideDrawerDeeplinkKillSwitch", true))
        featureManager.add(Feature("SponsoredRoamKillSwitch", true))
        featureManager.add(Feature("UnifiedProfileAvatarFeatureFlag", true))
        featureManager.add(Feature("ApproximateDistanceFeatureFlag", false))
        featureManager.add(Feature("DoxyPEP", true))
        featureManager.add(Feature("CascadeRewriteFeatureFlag", false))
        featureManager.add(Feature("AdsLogs", false))
        featureManager.add(Feature("PersistentAdBannerFeatureFlag", false))
        featureManager.add(Feature("ClientTelemetryTracking", false))
        featureManager.add(Feature("LTOAds", false))
        featureManager.add(Feature("SponsorProfileAds", false))
        featureManager.add(Feature("ConversationAds", false))
        featureManager.add(Feature("InboxNativeAds", false))
        featureManager.add(Feature("ReportingLagTime", false))
        featureManager.add(Feature("MrecNewFlow", false))
        featureManager.add(Feature("RunningOnEmulatorFeatureFlag", false))
        featureManager.add(Feature("BannerNewFlow", false))
        featureManager.add(Feature("CalendarUi", true))
        featureManager.add(Feature("CookieTap", Config.get("enable_cookie_tap", false, true) as Boolean))
        featureManager.add(Feature("VipFlag", Config.get("enable_vip_flag", false, true) as Boolean))
        featureManager.add(Feature("PositionFilter", true))
        featureManager.add(Feature("BanterFeatureGate", false))
        featureManager.add(Feature("TakenOnGrindrWatermarkFlag", false))
        featureManager.add(Feature("gender-filter", true))
        featureManager.add(Feature("enable-chat-summaries", true))
        featureManager.add(Feature("enable-mutual-taps-no-paywall", !(Config.get("enable_interest_section", true, true) as Boolean)))
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\LocalSavedPhrases.kt --- 
package com.grindrplus.hooks

import com.grindrplus.GrindrPlus
import com.grindrplus.persistence.model.SavedPhraseEntity
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.RetrofitUtils.RETROFIT_NAME
import com.grindrplus.utils.RetrofitUtils.isDELETE
import com.grindrplus.utils.RetrofitUtils.isGET
import com.grindrplus.utils.RetrofitUtils.isPOST
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.getObjectField
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import java.lang.reflect.Constructor
import java.lang.reflect.Proxy

class LocalSavedPhrases : Hook(
    "Local saved phrases",
    "Save unlimited phrases locally"
) {
    private val phrasesRestService = "S4.k" // search for 'v3/me/prefs'
    private val createSuccessResult = "ya.a\$b" // search for 'Success(successValue='
    private val chatRestService = "com.grindrapp.android.chat.data.datasource.api.service.ChatRestService"
    private val addSavedPhraseResponse =
        "com.grindrapp.android.chat.api.model.AddSavedPhraseResponse"
    private val phrasesResponse = "com.grindrapp.android.model.PhrasesResponse"
    private val phraseModel = "com.grindrapp.android.persistence.model.Phrase"

    override fun init() {
        val chatRestServiceClass = findClass(chatRestService)
        val createSuccess = findClass(createSuccessResult).constructors.firstOrNull() ?: return
        val phrasesRestServiceClass = findClass(phrasesRestService)

        findClass(RETROFIT_NAME).hook("create", HookStage.AFTER) { param ->
            val service = param.getResult()
            if (service != null) {
                param.setResult(when {
                    chatRestServiceClass.isAssignableFrom(service.javaClass) ->
                        createChatRestServiceProxy(service, createSuccess)

                    phrasesRestServiceClass.isAssignableFrom(service.javaClass) ->
                        createPhrasesRestServiceProxy(service, createSuccess)

                    else -> service
                })
            }
        }
    }

    private fun createChatRestServiceProxy(
        originalService: Any,
        createSuccess: Constructor<*>
    ): Any {
        val invocationHandler = Proxy.getInvocationHandler(originalService)
        return Proxy.newProxyInstance(
            originalService.javaClass.classLoader,
            arrayOf(findClass(chatRestService))
        ) { proxy, method, args ->
            when {
                method.isPOST("v3/me/prefs/phrases") -> {
                    val phrase = getObjectField(args[0], "phrase") as String

                    runBlocking {
                        val index = getCurrentPhraseIndex() + 1
                        addPhrase(index, phrase, 0, System.currentTimeMillis())
                        val response = findClass(addSavedPhraseResponse).constructors.first()
                            ?.newInstance(index.toString())
                        createSuccess.newInstance(response)
                    }
                }

                method.isDELETE("v3/me/prefs/phrases/{id}") -> {
                    runBlocking {
                        val index = getCurrentPhraseIndex()
                        deletePhrase(index)
                        createSuccess.newInstance(Unit)
                    }
                }

                method.isPOST("v4/phrases/frequency/{id}") -> {
                    runBlocking {
                        val index = getCurrentPhraseIndex()
                        val phrase = getPhrase(index)
                        if (phrase != null) {
                            updatePhrase(
                                index,
                                phrase.text,
                                phrase.frequency + 1,
                                System.currentTimeMillis()
                            )
                        }
                        createSuccess.newInstance(Unit)
                    }
                }

                else -> invocationHandler.invoke(proxy, method, args)
            }
        }
    }

    private fun createPhrasesRestServiceProxy(
        originalService: Any,
        createSuccess: Constructor<*>
    ): Any {
        val invocationHandler = Proxy.getInvocationHandler(originalService)
        return Proxy.newProxyInstance(
            originalService.javaClass.classLoader,
            arrayOf(findClass(phrasesRestService))
        ) { proxy, method, args ->
            when {
                method.isGET("v3/me/prefs") -> {
                    runBlocking {
                        val currentPhrases = getPhraseList()
                        val phrases = currentPhrases.associateWith { phrase ->
                            GrindrPlus.loadClass(phraseModel).constructors.first()?.newInstance(
                                phrase.phraseId.toString(), phrase.text, phrase.timestamp, phrase.frequency
                            )
                        }
                        val phrasesResponse = findClass(phrasesResponse)
                            .constructors.find { it.parameterTypes.size == 1 }?.newInstance(phrases)
                        createSuccess.newInstance(phrasesResponse)
                    }
                }

                else -> invocationHandler.invoke(proxy, method, args)
            }
        }
    }

    private suspend fun getPhraseList(): List<SavedPhraseEntity> = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.savedPhraseDao().getPhraseList()
    }

    private suspend fun getPhrase(phraseId: Long): SavedPhraseEntity? = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.savedPhraseDao().getPhrase(phraseId)
    }

    private suspend fun getCurrentPhraseIndex(): Long = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.savedPhraseDao().getCurrentPhraseIndex() ?: 0L
    }

    private suspend fun addPhrase(phraseId: Long, text: String, frequency: Int, timestamp: Long) = withContext(Dispatchers.IO) {
        val phrase = SavedPhraseEntity(
            phraseId = phraseId,
            text = text,
            frequency = frequency,
            timestamp = timestamp
        )
        GrindrPlus.database.savedPhraseDao().upsertPhrase(phrase)
    }

    private suspend fun updatePhrase(phraseId: Long, text: String, frequency: Int, timestamp: Long) = withContext(Dispatchers.IO) {
        val phrase = SavedPhraseEntity(
            phraseId = phraseId,
            text = text,
            frequency = frequency,
            timestamp = timestamp
        )
        GrindrPlus.database.savedPhraseDao().upsertPhrase(phrase)
    }

    private suspend fun deletePhrase(phraseId: Long) = withContext(Dispatchers.IO) {
        GrindrPlus.database.savedPhraseDao().deletePhrase(phraseId)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\LocationSpoofer.kt --- 
package com.grindrplus.hooks

import android.app.AlertDialog
import android.content.Context
import android.content.Intent
import android.graphics.BlendMode
import android.graphics.BlendModeColorFilter
import android.graphics.Color
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.graphics.Typeface
import android.graphics.drawable.ColorDrawable
import android.net.Uri
import android.os.Build
import android.view.Gravity
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Spinner
import android.widget.TextView
import android.widget.Toast
import androidx.core.graphics.drawable.DrawableCompat
import androidx.core.graphics.toColorInt
import androidx.core.view.children
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Constants
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.persistence.model.TeleportLocationEntity
import com.grindrplus.ui.Utils
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class LocationSpoofer : Hook(
    "Location spoofer",
    "Spoof your location"
) {
    private val location = "android.location.Location"
    private val chatBottomToolbar = "com.grindrapp.android.chat.presentation.ui.view.ChatBottomToolbar"

    private val coroutineScope = CoroutineScope(Dispatchers.Main)

    override fun init() {
        // Location spoofing logic (unchanged and correct)
        val locationClass = findClass(location)
        if (Build.VERSION.SDK_INT >= 31) {
            locationClass.hook("isMock", HookStage.BEFORE) { param -> param.setResult(false) }
        } else {
            locationClass.hook("isFromMockProvider", HookStage.BEFORE) { param -> param.setResult(false) }
        }
        locationClass.hook("getLatitude", HookStage.AFTER) { param ->
            (Config.get("forced_coordinates", Config.get("current_location", "")) as String).takeIf {
                it.isNotEmpty()
            }?.split(",")?.firstOrNull()?.toDoubleOrNull()?.let { param.setResult(it) }
        }
        locationClass.hook("getLongitude", HookStage.AFTER) { param ->
            (Config.get("forced_coordinates", Config.get("current_location", "")) as String).takeIf {
                it.isNotEmpty()
            }?.split(",")?.lastOrNull()?.toDoubleOrNull()?.let { param.setResult(it) }
        }

        // Final Hooking Strategy
        try {
            findClass(chatBottomToolbar).hookConstructor(HookStage.AFTER) { param ->
                val chatBottomToolbarLinearLayout = param.thisObject() as LinearLayout

                // Post the logic to run after the view has been initialized and laid out
                chatBottomToolbarLinearLayout.post {
                    logd("LocationSpoofer: post() block executed for ChatBottomToolbar.")

                    if (chatBottomToolbarLinearLayout.children.any { it.tag == "custom_location_button" }) {
                        logd("Button already exists. Skipping.")
                        return@post
                    }

                    val exampleButton = chatBottomToolbarLinearLayout.children.firstOrNull()
                    if (exampleButton == null) {
                        loge("FAILURE: ChatBottomToolbar has no child buttons to use as a template.")
                        return@post
                    }

                    val grindrContext: Context
                    try {
                        grindrContext = GrindrPlus.context.createPackageContext(Constants.GRINDR_PACKAGE_NAME, 0)
                    } catch (e: Exception) {
                        loge("FAILURE: Could not create package context. Button cannot be added. Error: ${e.message}")
                        return@post
                    }

                    val rippleDrawableId = Utils.getId("image_button_ripple", "drawable", grindrContext)
                    val locationIconId = Utils.getId("ic_my_location", "drawable", grindrContext)

                    if (rippleDrawableId == 0 || locationIconId == 0) {
                        loge("FAILURE: Required resources for location button not found.")
                        return@post
                    }

                    val customLocationButton = ImageButton(chatBottomToolbarLinearLayout.context).apply {
                        layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT).apply { weight = 1f }
                        focusable = ImageButton.FOCUSABLE
                        scaleType = ImageView.ScaleType.CENTER
                        isClickable = true
                        tag = "custom_location_button"
                        contentDescription = "Teleport"
                        setBackgroundResource(rippleDrawableId)
                        setImageResource(locationIconId)
                        setPadding(
                            exampleButton.paddingLeft,
                            exampleButton.paddingTop,
                            exampleButton.paddingRight,
                            exampleButton.paddingBottom
                        )
                        val grindrGray = "#9e9ea8".toColorInt()
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                            drawable.colorFilter = BlendModeColorFilter(grindrGray, BlendMode.SRC_IN)
                        } else {
                            @Suppress("DEPRECATION")
                            drawable.colorFilter = PorterDuffColorFilter(grindrGray, PorterDuff.Mode.SRC_IN)
                        }
                    }

                    customLocationButton.setOnClickListener {
                        coroutineScope.launch {
                            val locations = getLocations()
                            showTeleportDialog(it.context, locations)
                        }
                    }

                    customLocationButton.setOnLongClickListener {
                        GrindrPlus.executeAsync {
                            if (Config.get("default_locations_populated", false) as Boolean) {
                                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Default locations already populated.")
                            } else {
                                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Populating default locations...")
                                try {
                                    com.grindrplus.persistence.GPDatabase.prePopulate(GrindrPlus.context)
                                    Config.put("default_locations_populated", true)
                                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Locations populated successfully!")
                                } catch (e: Exception) {
                                    Logger.e("Failed to prepopulate locations: ${e.message}")
                                    Logger.writeRaw(e.stackTraceToString())
                                }
                            }
                        }
                        true
                    }

                    chatBottomToolbarLinearLayout.addView(customLocationButton)
/*
                    val desiredPosition = 2
                    if (chatBottomToolbarLinearLayout.childCount >= desiredPosition) {
                        chatBottomToolbarLinearLayout.addView(customLocationButton, desiredPosition)
                    } else {
                        chatBottomToolbarLinearLayout.addView(customLocationButton)
                    }*/
                    logd("SUCCESS: Location button added to the toolbar.")
                }
            }
        } catch (e: Exception) {
            loge("CRITICAL FAILURE: Could not hook '$chatBottomToolbar'. The class name may be wrong or constructor signature changed. Error: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }

    private fun showTeleportDialog(context: Context, locations: List<TeleportLocationEntity>) {
        val locationNames = locations.map { it.name }
        val coordinatesMap = locations.associate { it.name to "${it.latitude}, ${it.longitude}" }

        val locationDialogView = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(32, 32, 32, 32)
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
        }

        val textViewCoordinates = TextView(context).apply {
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                topMargin = 16
                marginStart = 70
                marginEnd = 70
            }
            gravity = Gravity.CENTER_HORIZONTAL
            textSize = 16f
            setTypeface(null, Typeface.BOLD)
            setTextColor(Color.WHITE)
        }
        val textViewName = TextView(context).apply {
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                topMargin = 8
                marginStart = 70
                marginEnd = 70
            }
            gravity = Gravity.CENTER_HORIZONTAL
            textSize = 14f
            setTextColor(Color.WHITE)
        }

        val spinnerLocations = Spinner(context).apply {
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                topMargin = 16
                marginStart = 120
                marginEnd = 140
            }
        }

        val adapter = object : ArrayAdapter<String>(context, android.R.layout.simple_spinner_item, locationNames) {
            override fun getView(position: Int, convertView: View?, parent: ViewGroup): View = getCustomView(position, convertView, parent)
            override fun getDropDownView(position: Int, convertView: View?, parent: ViewGroup): View = getCustomView(position, convertView, parent)
            private fun getCustomView(position: Int, convertView: View?, parent: ViewGroup): View {
                val view = (convertView as? TextView) ?: TextView(context).apply {
                    layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT)
                    minHeight = 120
                    gravity = (Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL)
                    textSize = 16f
                    setTextColor(Color.WHITE)
                    background = ColorDrawable(Color.TRANSPARENT)
                }
                view.text = getItem(position)
                return view
            }
        }
        spinnerLocations.adapter = adapter
        spinnerLocations.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                textViewCoordinates.text = coordinatesMap[locationNames.getOrNull(position)]

                textViewName.text = locationNames.getOrNull(position) ?: ""

                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Location resolved: ${locationNames.getOrNull(position) ?: "None"}")
            }
            override fun onNothingSelected(parent: AdapterView<*>) {
                textViewCoordinates.text = ""
                textViewName.text = ""
            }
        }

        val wrapDrawable = DrawableCompat.wrap(spinnerLocations.background)
        DrawableCompat.setTint(wrapDrawable, Color.WHITE)
        spinnerLocations.background = wrapDrawable

        val buttonsContainer = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply {
                topMargin = 20
                marginStart = 100
                marginEnd = 100
            }
        }

        val scrollView = android.widget.ScrollView(context).apply {
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, 0).apply { weight = 1f }
            isFillViewport = true
        }

        val buttonAdd = Button(context).apply {
            layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { topMargin = 15 }
            text = "Add New Location"
            background = Utils.createButtonDrawable(Color.parseColor("#FF9800"))
            setTextColor(Color.WHITE)
            setOnClickListener { showAddLocationDialog(context, adapter) }
        }
        buttonsContainer.addView(buttonAdd)

        if (locations.isNotEmpty()) {
            val buttonCopy = Button(context).apply {
                layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { topMargin = 30 }
                text = "Copy Coordinates"
                background = Utils.createButtonDrawable(Color.parseColor("#4CAF50"))
                setTextColor(Color.WHITE)
                setOnClickListener { Utils.copyToClipboard("Coordinates", textViewCoordinates.text.toString()) }
            }
            buttonsContainer.addView(buttonCopy)

            val buttonSet = Button(context).apply {
                layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { topMargin = 15 }
                text = "Teleport to location"
                background = Utils.createButtonDrawable(Color.parseColor("#2196F3"))
                setTextColor(Color.WHITE)
                setOnClickListener {
                    val coords = textViewCoordinates.text.toString()
                    val name = spinnerLocations.selectedItem?.toString() ?: "Unknown"
                    Config.put("current_location", coords)

                    var teleportCount = Config.get("teleport_count", 0) as Int
                    teleportCount++
                    Config.put("teleport_count", teleportCount)
                    if (teleportCount % 7 == 0) {
                        GrindrPlus.showToast(Toast.LENGTH_LONG, "Successfully teleported to $name ($coords)")
                    }
                }
            }
            buttonsContainer.addView(buttonSet)

            val buttonOpen = Button(context).apply {
                layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { topMargin = 15 }
                text = "Open in Maps"
                background = Utils.createButtonDrawable(Color.parseColor("#9C27B0"))
                setTextColor(Color.WHITE)
                setOnClickListener {
                    context.startActivity(Intent(Intent.ACTION_VIEW, Uri.parse("geo:${textViewCoordinates.text}")))
                }
            }
            buttonsContainer.addView(buttonOpen)

            val buttonDelete = Button(context).apply {
                layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT).apply { topMargin = 15 }
                text = "Delete Location"
                background = Utils.createButtonDrawable(Color.parseColor("#FF0000"))
                setTextColor(Color.WHITE)
                setOnClickListener button@{
                    if (spinnerLocations.selectedItem == null) {
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "No location selected.")
                        return@button
                    }
                    val name = spinnerLocations.selectedItem.toString()
                    coroutineScope.launch {
                        deleteLocation(name)
                        val updatedLocations = getLocations()
                        val updatedLocationNames = updatedLocations.map { it.name }
                        withContext(Dispatchers.Main) {
                            adapter.clear()
                            adapter.addAll(updatedLocationNames)
                            adapter.notifyDataSetChanged()
                            if (updatedLocationNames.isEmpty()) {
                                textViewCoordinates.text = ""
                            }
                        }
                        GrindrPlus.showToast(Toast.LENGTH_LONG, "Location deleted")
                    }
                }
            }
            buttonsContainer.addView(buttonDelete)
        }

        scrollView.addView(buttonsContainer)
        locationDialogView.addView(spinnerLocations)
        locationDialogView.addView(textViewCoordinates)

        locationDialogView.addView(textViewName)
        locationDialogView.addView(scrollView)

        AlertDialog.Builder(context).apply {
            setTitle("Teleport Locations")
            setView(locationDialogView)
            setPositiveButton("Close") { dialog, _ -> dialog.dismiss() }
            show()
        }
    }

    private suspend fun getLocations(): List<TeleportLocationEntity> = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.teleportLocationDao().getLocations()
    }

    private suspend fun deleteLocation(name: String) = withContext(Dispatchers.IO) {
        GrindrPlus.database.teleportLocationDao().deleteLocation(name)
    }

    private fun showAddLocationDialog(context: Context, adapter: ArrayAdapter<String>) {
        val inputLayout = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(40, 40, 40, 40)
        }

        val editName = android.widget.EditText(context).apply {
            hint = "Location Name"
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
        }

        val editCoords = android.widget.EditText(context).apply {
            hint = "Latitude, Longitude (e.g. 40.7128, -74.0060)"
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply { topMargin = 20 }
        }

        inputLayout.addView(editName)
        inputLayout.addView(editCoords)

        AlertDialog.Builder(context)
            .setTitle("Add Location")
            .setView(inputLayout)
            .setPositiveButton("Save") { _, _ ->
                val name = editName.text.toString().trim()
                val coords = editCoords.text.toString().trim()

                if (name.isBlank() || !coords.matches(Regex("""^-?\d+(\.\d+)?,\s*-?\d+(\.\d+)?$"""))) {
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Invalid input. Use format: 40.71, -74.00")
                    return@setPositiveButton
                }

                try {
                    val (lat, lon) = coords.split(",").map { it.trim().toDouble() }
                    coroutineScope.launch {
                        GrindrPlus.database.teleportLocationDao().upsertLocation(
                            TeleportLocationEntity(name, lat, lon)
                        )
                        val updated = getLocations().map { it.name }
                        withContext(Dispatchers.Main) {
                            adapter.clear()
                            adapter.addAll(updated)
                            adapter.notifyDataSetChanged()
                        }
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Location saved")
                    }
                } catch (e: NumberFormatException) {
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Invalid coordinates. Please enter numbers.")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\NotificationAlerts.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook

class NotificationAlerts : Hook(
    "Notification Alerts",
    "Disable all Grindr warnings related to notifications"
) {
    private val notificationManager = "b9.d" // search for '0L, "notification_reminder_time"'

    override fun init() {
        findClass(notificationManager)
            .hook("a", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\OIldLocationSpoofer.kt --- 
/*
package com.grindrplus.hooks

import android.app.AlertDialog
import android.content.Context
import android.content.Intent
import android.graphics.BlendMode
import android.graphics.BlendModeColorFilter
import android.graphics.Color
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.graphics.Typeface
import android.graphics.drawable.ColorDrawable
import android.net.Uri
import android.os.Build
import android.view.Gravity
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Spinner
import android.widget.TextView
import android.widget.Toast
import androidx.core.content.res.ResourcesCompat
import androidx.core.graphics.drawable.DrawableCompat
import androidx.core.graphics.toColorInt
import androidx.core.view.children
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Constants
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logw
import com.grindrplus.persistence.model.TeleportLocationEntity
import com.grindrplus.ui.Utils
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class LocationSpoofer : Hook(
    "Location spoofer",
    "Spoof your location"
) {
    private val location = "android.location.Location"
    private val chatBottomToolbar = "com.grindrapp.android.chat.presentation.ui.view.ChatBottomToolbar"
    private val appConfiguration = "com.grindrapp.android.platform.config.AppConfiguration"
    private val coroutineScope = CoroutineScope(Dispatchers.Main)
    //private var diagnosticHookRan = false

    */
/**
     * Recursively dumps the view hierarchy to the logcat for diagnostic purposes.
     *//*

    */
/*    private fun dumpViewHierarchy(view: View, level: Int) {
            val indent = "  ".repeat(level)
            val viewInfo = StringBuilder()
            viewInfo.append("$indent- ${view.javaClass.name}")

            if (view.id != View.NO_ID) {
                try {
                    val resourceName = view.context.resources.getResourceEntryName(view.id)
                    viewInfo.append(" (id: $resourceName)")
                } catch (e: Exception) {
                    // Ignore if resource name can't be found
                }
            }

            when (view) {
                is TextView -> viewInfo.append(" [text: \"${view.text}\"]")
                is ImageView -> view.contentDescription?.let { viewInfo.append(" [contentDesc: \"$it\"]") }
            }

            logd(viewInfo.toString())

            if (view is ViewGroup) {
                for (i in 0 until view.childCount) {
                    val child = view.getChildAt(i)
                    dumpViewHierarchy(child, level + 1)
                }
            }
        }*//*


    override fun init() {
        // TEMPORARY DIAGNOSTIC HOOK to dump the view hierarchy of the chat activity.
        */
/*try {
            findClass("com.grindrapp.android.chat.presentation.ui.ChatActivityV2")
                .hook("onCreate", HookStage.AFTER) { param ->
                    if (diagnosticHookRan) return@hook
                    val activity = param.thisObject() as android.app.Activity
                    activity.window.decorView.post {
                        val rootView = activity.findViewById<ViewGroup>(android.R.id.content)
                        logd("--- Start View Hierarchy Dump for ChatActivityV2 ---")
                        dumpViewHierarchy(rootView, 0)
                        logd("--- End View Hierarchy Dump ---")
                        diagnosticHookRan = true
                    }
                }
        } catch (t: Throwable) {
            loge("LocationSpoofer DIAGNOSTIC: Failed to hook ChatActivityV2 onCreate.")
        }*//*


        val locationClass = findClass(location)

        if (Build.VERSION.SDK_INT >= 31) {
            locationClass.hook(
                "isMock",
                HookStage.BEFORE
            ) { param ->
                param.setResult(false)
            }
        } else {
            locationClass.hook(
                "isFromMockProvider",
                HookStage.BEFORE
            ) { param ->
                param.setResult(false)
            }
        }

        locationClass.hook("getLatitude", HookStage.AFTER) { param ->
            (Config.get("forced_coordinates", Config.get("current_location", "")) as String).takeIf {
                it.isNotEmpty()
            }?.split(",")?.firstOrNull()
                ?.toDoubleOrNull()?.let {
                    param.setResult(it)
                }
        }

        locationClass.hook("getLongitude", HookStage.AFTER) { param ->
            (Config.get("forced_coordinates", Config.get("current_location", "")) as String).takeIf {
                it.isNotEmpty()
            }?.split(",")?.lastOrNull()
                ?.toDoubleOrNull()?.let {
                    param.setResult(it)
                }
        }

        findClass(chatBottomToolbar).hook("onAttachedToWindow", HookStage.AFTER) { param ->
            logd("LocationSpoofer: hook 'onAttachedToWindow' for chatBottomToolbar triggered.")

            val chatBottomToolbarLinearLayout = param.thisObject() as LinearLayout
            // Safety check: Ensure children exist before proceeding
            if (chatBottomToolbarLinearLayout.childCount == 0) {
                logw("chatBottomToolbar has no children yet. Aborting.")
                return@hook
            }
            val exampleButton = chatBottomToolbarLinearLayout.children.first()

            // Check if our button has already been added to prevent duplicates
            if (chatBottomToolbarLinearLayout.children.any { it.tag == "custom_location_button" }) {
                logd("Location button already exists. Skipping.")
                return@hook
            }

            val grindrContext = try {
                GrindrPlus.context.createPackageContext(Constants.GRINDR_PACKAGE_NAME, 0)
            } catch (e: Exception) {
                loge("Failed to create package context for ${Constants.GRINDR_PACKAGE_NAME}. Aborting button creation.")
                return@hook
            }

            val rippleDrawableId = Utils.getId("image_button_ripple", "drawable", grindrContext)
            val locationIconId = Utils.getId("ic_my_location", "drawable", grindrContext)

            logd("Resource check: rippleDrawableId=$rippleDrawableId, locationIconId=$locationIconId")
            if (rippleDrawableId == 0 || locationIconId == 0) {
                loge("Required resources for location button not found. Aborting.")
                return@hook
            }

            val customLocationButton = ImageButton(chatBottomToolbarLinearLayout.context).apply {
                layoutParams = LinearLayout.LayoutParams(
                    0, LinearLayout.LayoutParams.MATCH_PARENT
                ).apply { weight = 1f }
                focusable = ImageButton.FOCUSABLE
                scaleType = ImageView.ScaleType.CENTER
                isClickable = true
                tag = "custom_location_button"
                contentDescription = "Teleport"
                setBackgroundResource(rippleDrawableId)
                setImageResource(locationIconId)
                setPadding(
                    exampleButton.paddingLeft,
                    exampleButton.paddingTop,
                    exampleButton.paddingRight,
                    exampleButton.paddingBottom
                )

                val grindrGray = "#9e9ea8".toColorInt()
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    drawable.colorFilter =
                        BlendModeColorFilter(grindrGray, BlendMode.SRC_IN)
                } else {
                    @Suppress("DEPRECATION")
                    drawable.colorFilter =
                        PorterDuffColorFilter(grindrGray, PorterDuff.Mode.SRC_IN)
                }
            }

            customLocationButton.setOnClickListener {
                coroutineScope.launch {
                    val locations = getLocations()

                    val locationNames = locations.map { it.name }
                    val coordinatesMap = locations.associate { location ->
                        location.name to "${location.latitude}, ${location.longitude}"
                    }

                    val locationDialogView = LinearLayout(it.context).apply {
                        orientation = LinearLayout.VERTICAL
                        setPadding(32, 32, 32, 32)
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        )
                    }

                    val textViewCoordinates = TextView(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 16
                            marginStart = 70
                            marginEnd = 70
                        }
                        gravity = Gravity.CENTER_HORIZONTAL
                        textSize = 16f
                        setTypeface(null, Typeface.BOLD)
                        setTextColor(Color.WHITE)
                    }

                    val spinnerLocations = Spinner(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 16
                            marginStart = 120
                            marginEnd = 140
                        }
                    }

                    val adapter = object : ArrayAdapter<String>(
                        it.context,
                        android.R.layout.simple_spinner_item,
                        locationNames
                    ) {
                        override fun getView(
                            position: Int,
                            convertView: View?,
                            parent: ViewGroup
                        ): View {
                            return getCustomView(position, convertView, parent)
                        }

                        override fun getDropDownView(
                            position: Int,
                            convertView: View?,
                            parent: ViewGroup
                        ): View {
                            return getCustomView(position, convertView, parent)
                        }

                        private fun getCustomView(
                            position: Int,
                            convertView: View?,
                            parent: ViewGroup
                        ): View {
                            val view = (convertView as? TextView) ?: TextView(it.context).apply {
                                layoutParams = LinearLayout.LayoutParams(
                                    LinearLayout.LayoutParams.MATCH_PARENT,
                                    LinearLayout.LayoutParams.WRAP_CONTENT
                                )
                                minHeight = 120
                                gravity = (Gravity.CENTER_HORIZONTAL or Gravity.CENTER_VERTICAL)
                                textSize = 16f
                                setTextColor(Color.WHITE)
                                background = ColorDrawable(Color.TRANSPARENT)
                            }
                            view.text = getItem(position)
                            return view
                        }
                    }
                    spinnerLocations.adapter = adapter

                    spinnerLocations.onItemSelectedListener =
                        object : AdapterView.OnItemSelectedListener {
                            override fun onItemSelected(
                                parent: AdapterView<*>,
                                view: View,
                                position: Int,
                                id: Long
                            ) {
                                textViewCoordinates.text = coordinatesMap[locationNames.getOrNull(position)]
                            }

                            override fun onNothingSelected(parent: AdapterView<*>) {
                                textViewCoordinates.text = ""
                            }
                        }

                    val wrapDrawable = DrawableCompat.wrap(spinnerLocations.background)
                    DrawableCompat.setTint(wrapDrawable, Color.WHITE)
                    spinnerLocations.background = wrapDrawable

                    val buttonsContainer = LinearLayout(it.context).apply {
                        orientation = LinearLayout.VERTICAL
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply {
                            topMargin = 20
                            marginStart = 100
                            marginEnd = 100
                        }
                    }

                    val scrollView = android.widget.ScrollView(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            0
                        ).apply { weight = 1f }
                        isFillViewport = true
                    }

                    val buttonCopy = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply { topMargin = 30 }
                        text = "Copy Coordinates"
                        background = Utils.createButtonDrawable(Color.parseColor("#4CAF50"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            Utils.copyToClipboard(
                                "Coordinates",
                                textViewCoordinates.text.toString()
                            )
                        }
                    }

                    val buttonSet = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply { topMargin = 15 }
                        text = "Teleport to location"
                        background = Utils.createButtonDrawable(Color.parseColor("#2196F3"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            Config.put("current_location", textViewCoordinates.text.toString())
                            GrindrPlus.showToast(
                                Toast.LENGTH_LONG,
                                "Successfully teleported to ${textViewCoordinates.text}"
                            )
                        }
                    }

                    val buttonOpen = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply { topMargin = 15 }
                        text = "Open in Maps"
                        background = Utils.createButtonDrawable(Color.parseColor("#9C27B0"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            context.startActivity(
                                Intent(
                                    Intent.ACTION_VIEW, Uri.parse(
                                        "geo:${textViewCoordinates.text}"
                                    )
                                )
                            )
                        }
                    }

                    val buttonDelete = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply { topMargin = 15 }
                        text = "Delete Location"
                        background = Utils.createButtonDrawable(Color.parseColor("#FF0000"))
                        setTextColor(Color.WHITE)
                        setOnClickListener button@{
                            if (spinnerLocations.selectedItem == null) {
                                GrindrPlus.showToast(Toast.LENGTH_SHORT, "No location selected.")
                                return@button
                            }
                            val name = spinnerLocations.selectedItem.toString()

                            coroutineScope.launch {
                                deleteLocation(name)

                                val updatedLocations = getLocations()
                                val updatedLocationNames = updatedLocations.map { it.name }

                                withContext(Dispatchers.Main) {
                                    adapter.clear()
                                    adapter.addAll(updatedLocationNames)
                                    adapter.notifyDataSetChanged()
                                    if (updatedLocationNames.isEmpty()) {
                                        textViewCoordinates.text = ""
                                    }
                                }

                                GrindrPlus.showToast(Toast.LENGTH_LONG, "Location deleted")
                            }
                        }
                    }

                    val buttonAdd = Button(it.context).apply {
                        layoutParams = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.MATCH_PARENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        ).apply { topMargin = 15 }
                        text = "Add New Location"
                        background = Utils.createButtonDrawable(Color.parseColor("#FF9800"))
                        setTextColor(Color.WHITE)
                        setOnClickListener {
                            showAddLocationDialog(it.context, adapter)
                        }
                    }
                    buttonsContainer.addView(buttonAdd)

                    if (locations.isNotEmpty()) {
                        buttonsContainer.addView(buttonCopy)
                        buttonsContainer.addView(buttonSet)
                        buttonsContainer.addView(buttonOpen)
                        buttonsContainer.addView(buttonDelete)
                    }

                    scrollView.addView(buttonsContainer)

                    for (view in arrayOf(
                        spinnerLocations,
                        textViewCoordinates, scrollView
                    )) {
                        locationDialogView.addView(view)
                    }

                    AlertDialog.Builder(it.context).apply {
                        setTitle("Teleport Locations")
                        setView(locationDialogView)
                        setPositiveButton("Close") { dialog, _ -> dialog.dismiss() }
                        show()
                    }
                }
            }

            customLocationButton.setOnLongClickListener {
                GrindrPlus.executeAsync {
                    if (Config.get("default_locations_populated", false) as Boolean) {
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Default locations already populated.")
                    } else {
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Populating default locations...")
                        try {
                            com.grindrplus.persistence.GPDatabase.prePopulate(GrindrPlus.context)
                            Config.put("default_locations_populated", true)
                            GrindrPlus.showToast(Toast.LENGTH_SHORT, "Locations populated successfully!")
                        } catch (e: Exception) {
                            Logger.e("Failed to prepopulate locations: ${e.message}")
                            Logger.writeRaw(e.stackTraceToString())
                            GrindrPlus.showToast(Toast.LENGTH_LONG, "Failed to populate locations. See logs.")
                        }
                    }
                }
                true
            }

            logd("Adding custom location button to the toolbar.")
            val desiredPosition = 2
            if (chatBottomToolbarLinearLayout.childCount >= desiredPosition) {
                chatBottomToolbarLinearLayout.addView(customLocationButton, desiredPosition)
            } else {
                chatBottomToolbarLinearLayout.addView(customLocationButton)
            }
        }
    }

    private suspend fun getLocations(): List<TeleportLocationEntity> = withContext(Dispatchers.IO) {
        return@withContext GrindrPlus.database.teleportLocationDao().getLocations()
    }

    private suspend fun deleteLocation(name: String) = withContext(Dispatchers.IO) {
        GrindrPlus.database.teleportLocationDao().deleteLocation(name)
    }

    private fun showAddLocationDialog(context: Context, adapter: ArrayAdapter<String>) {
        val inputLayout = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(40, 40, 40, 40)
        }

        val editName = android.widget.EditText(context).apply {
            hint = "Location Name"
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
        }

        val editCoords = android.widget.EditText(context).apply {
            hint = "Latitude, Longitude (e.g. 40.7128, -74.0060)"
            layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply { topMargin = 20 }
        }

        inputLayout.addView(editName)
        inputLayout.addView(editCoords)

        AlertDialog.Builder(context)
            .setTitle("Add Location")
            .setView(inputLayout)
            .setPositiveButton("Save") { _, _ ->
                val name = editName.text.toString().trim()
                val coords = editCoords.text.toString().trim()

                if (name.isBlank() || !coords.matches(Regex("""^-?\d+\.\d+,\s*-?\d+\.\d+$"""))) {
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Invalid input")
                    return@setPositiveButton
                }

                val (lat, lon) = coords.split(",").map { it.trim().toDouble() }
                coroutineScope.launch {
                    GrindrPlus.database.teleportLocationDao().upsertLocation(
                        TeleportLocationEntity(name, lat, lon)
                    )
                    val updated = getLocations().map { it.name }
                    withContext(Dispatchers.Main) {
                        adapter.clear()
                        adapter.addAll(updated)
                        adapter.notifyDataSetChanged()
                    }
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Location saved")
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
}*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\OnlineIndicator.kt --- 
package com.grindrplus.hooks

import com.grindrplus.core.Config
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import kotlin.time.Duration.Companion.minutes

class OnlineIndicator : Hook(
    "Online indicator",
    "Customize online indicator duration"
) {
    val utils = "Sg.k0" // search for ' <= 600000;'

    override fun init() {
        findClass(utils) // shouldShowOnlineIndicator()
            .hook("a", HookStage.BEFORE) { param ->
                val savedDuration = Config.get("online_indicator", 3).toString().toInt()
                param.setResult(System.currentTimeMillis() - param.arg<Long>(0) <= savedDuration.minutes.inWholeMilliseconds)
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ProfileDetails.kt --- 
package com.grindrplus.hooks

import android.annotation.SuppressLint
import android.app.AlertDialog
import android.content.Context
import android.graphics.BlendMode
import android.graphics.BlendModeColorFilter
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.os.Build
import android.view.View
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.core.graphics.toColorInt
import androidx.core.view.children
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Constants
import com.grindrplus.core.Logger
import com.grindrplus.core.LogSource
import com.grindrplus.core.Utils
import com.grindrplus.core.Utils.calculateBMI
import com.grindrplus.core.Utils.h2n
import com.grindrplus.core.Utils.w2n
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logw
import com.grindrplus.ui.Utils.copyToClipboard
import com.grindrplus.ui.Utils.formatEpochSeconds
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField
import de.robv.android.xposed.XposedHelpers.setObjectField
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.util.ArrayList
import kotlin.math.roundToInt

class ProfileDetails : Hook("Profile details", "Add extra fields and details to profiles") {
    private val profileId = emptyList<String>()
    private var boostedProfilesList = emptyList<String>()
    private val blockedProfilesObserver = "cf.p"
    private val profileViewHolder = "cf.F\$b"
    private val distanceUtils = "com.grindrapp.android.utils.DistanceUtils"
    private val profileBarView = "com.grindrapp.android.ui.profileV2.ProfileBarView"
    private val profileViewState = "com.grindrapp.android.ui.profileV2.model.ProfileViewState"
   // private val profileFragment = "com.grindrapp.android.ui.profileV2.ProfileFragment" // ADDED

    private val serverDrivenCascadeCachedState =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCacheState"
    private val serverDrivenCascadeCachedProfile =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCachedProfile"

    private val profileQuickBarView = "com.grindrapp.android.ui.profileV2.ProfileQuickbarView"
    private val profileQuickBar = "com.grindrapp.android.ui.profileV2.ProfileQuickbarView"

    private val coroutineScope = CoroutineScope(Dispatchers.Main)

    @SuppressLint("DefaultLocale")
    override fun init() {
        // Hook for boosted profiles detection
        findClass(serverDrivenCascadeCachedState).hook("getItems", HookStage.AFTER) { param ->
            (param.getResult() as List<*>)
                .filter { (it?.javaClass?.name ?: "") == serverDrivenCascadeCachedProfile }
                .forEach {
                    if (getObjectField(it, "isBoosting") as Boolean) {
                        boostedProfilesList += callMethod(it, "getProfileId") as String
                    }
                }
        }

        // Hook for blocked profiles list - show profile ID
        findClass(blockedProfilesObserver).hook("onChanged", HookStage.AFTER) { param ->
            val profileList = getObjectField(
                getObjectField(param.thisObject(), "a"), "o"
            ) as ArrayList<*>
            for (profile in profileList) {
                val profileId = callMethod(profile, "getProfileId") as String
                val displayName =
                    (callMethod(profile, "getDisplayName") as? String)
                        ?.takeIf { it.isNotEmpty() }
                        ?.let { "$it ($profileId)" } ?: profileId
                setObjectField(profile, "displayName", displayName)
            }
        }

        // Hook for blocked profiles view holder - copy on long click
        findClass(profileViewHolder).hookConstructor(HookStage.AFTER) { param ->
            val textView = getObjectField(param.thisObject(), "b") as TextView

            textView.setOnLongClickListener {
                val text = textView.text.toString()
                val profileId = if ("(" in text && ")" in text)
                    text.substringAfter("(").substringBefore(")")
                else text

                copyToClipboard("Profile ID", profileId)
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Profile ID: $profileId")
                true
            }
        }

        // ADDED: Hook for main profile fragment to attach click listeners to display name
   /*     findClass(profileFragment).hook("onViewCreated", HookStage.AFTER) { param ->
            try {
                val fragment = param.thisObject()
                val view = param.arg<View>(0)

                // Wait for the view to be fully laid out
                view.post {
                    try {
                        // Look for the display name TextView in the profile fragment
                        // Common IDs for profile name: profile_name, display_name, etc.
                        val displayNameId = view.resources.getIdentifier(
                            "profile_name", "id", Constants.GRINDR_PACKAGE_NAME
                        )

                        if (displayNameId == 0) {
                            loge("Could not find profile_name ID in profile fragment")
                            return@post
                        }

                        val displayNameTextView = view.findViewById<TextView>(displayNameId)
                        if (displayNameTextView != null) {
                            attachProfileDetailsHandlers(displayNameTextView, fragment)
                            logd("SUCCESS: Attached profile details handlers to main profile fragment")
                        } else {
                            loge("Could not find profile name TextView in profile fragment")
                        }
                    } catch (e: Exception) {
                        loge("Error attaching handlers to profile fragment: ${e.message}")
                    }
                }
            } catch (e: Exception) {
                loge("Error in profile fragment hook: ${e.message}")
            }
        }
*/
        // REVISED HOOK: Attach listeners in the data binding method for reliability.
        findClass(profileQuickBarView).hookConstructor(stage = HookStage.AFTER) { param ->
            val profileQuickBarViewInstance = param.thisObject()
            val profileQuickBarViewLinearLayout = param.thisObject() as LinearLayout

            // Post the logic to run after the view has been initialized and laid out
            profileQuickBarViewLinearLayout.post {
                logd("ProfileDetails: post() block executed for ProfileQuickbarView.")

                if (profileQuickBarViewLinearLayout.children.any { it.tag == "profile_deets" }) {
                    logd("Button already exists. Skipping.")
                    return@post
                }

                val exampleButton = profileQuickBarViewLinearLayout.children.firstOrNull()
                if (exampleButton == null) {
                    loge("FAILURE: ProfileQuickbarView has no child buttons to use as a template.")
                    return@post
                }

                val grindrContext: Context
                try {
                    grindrContext =
                        GrindrPlus.context.createPackageContext(Constants.GRINDR_PACKAGE_NAME, 0)
                } catch (e: Exception) {
                    loge("FAILURE: Could not create package context. Button cannot be added. Error: ${e.message}")
                    return@post
                }

                val rippleDrawableId =
                    com.grindrplus.ui.Utils.getId("image_button_ripple", "drawable", grindrContext)
                val infoIconId = com.grindrplus.ui.Utils.getId(
                    "ic_info",
                    "drawable",
                    grindrContext
                )

                if (rippleDrawableId == 0 || infoIconId == 0) {
                    loge("FAILURE: Required resources for details button not found.")
                    return@post
                }

                val customDeetsButton = ImageButton(profileQuickBarViewLinearLayout.context).apply {
                    layoutParams =
                        LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT)
                            .apply { weight = 1f }
                    focusable = ImageButton.FOCUSABLE
                    scaleType = ImageView.ScaleType.CENTER
                    isClickable = true
                    tag = "profile_deets"
                    contentDescription = "profile details"
                    setBackgroundResource(rippleDrawableId)
                    setImageResource(infoIconId)
                    setPadding(
                        exampleButton.paddingLeft,
                        exampleButton.paddingTop,
                        exampleButton.paddingRight,
                        exampleButton.paddingBottom
                    )
                    val grindrGray = "#9e9ea8".toColorInt()
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        drawable.colorFilter = BlendModeColorFilter(grindrGray, BlendMode.SRC_IN)
                    } else {
                        @Suppress("DEPRECATION")
                        drawable.colorFilter =
                            PorterDuffColorFilter(grindrGray, PorterDuff.Mode.SRC_IN)
                    }
                }

                customDeetsButton.setOnClickListener {
                    coroutineScope.launch {
                        try {
                            showProfileDetailsDialog(it.context, profileQuickBarViewInstance)
                        } catch (e: Exception) {
                            loge("Error showing profile details: ${e.message}")
                            Toast.makeText(it.context, "Failed to load details", Toast.LENGTH_SHORT)
                                .show()
                        }
                    }
                }

                val desiredPosition = 1
                if (profileQuickBarViewLinearLayout.childCount >= desiredPosition) {
                    profileQuickBarViewLinearLayout.addView(customDeetsButton, desiredPosition)
                } else {
                    profileQuickBarViewLinearLayout.addView(customDeetsButton)
                }
                logd("SUCCESS: Details button added to the quickbar.")
            }
        }

        findClass(profileBarView).hook("a", HookStage.AFTER) { param ->
            val profileBarViewInstance = param.thisObject()
            val profileViewState = param.arg<Any>(0)

            try {
                val viewBinding = getObjectField(profileBarViewInstance, "c")
                val displayNameTextView = getObjectField(viewBinding, "c") as TextView
                val profile = getObjectField(profileViewState, "profile") ?: return@hook

                attachProfileDetailsHandlers(displayNameTextView, profile)
            } catch (e: Exception) {
                Logger.e(
                    "Error setting ProfileBarView handlers: ${e.message}",
                    source = LogSource.HOOK
                )
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        // Hook for distance display precision
        findClass(distanceUtils).hook("c", HookStage.AFTER) { param ->
            val distance = param.arg<Double>(0)
            val isFeet = param.arg<Boolean>(2)

            param.setResult(
                if (isFeet) {
                    val feet = (distance * 3.280839895).roundToInt()
                    if (feet < 5280) {
                        String.format("%d feet", feet)
                    } else {
                        String.format("%d miles %d feet", feet / 5280, feet % 5280)
                    }
                } else {
                    val meters = distance.roundToInt()
                    if (meters < 1000) {
                        String.format("%d meters", meters)
                    } else {
                        String.format("%d km %d m", meters / 1000, meters % 1000)
                    }
                }
            )
        }

        // Hook for BMI display in profile
        findClass(profileViewState).hook("getWeight", HookStage.AFTER) { param ->
            if (Config.get("show_bmi_in_profile", true) as Boolean) {
                val weight = param.getResult()
                val height = callMethod(param.thisObject(), "getHeight")

                if (weight != null && height != null) {
                    val BMI = calculateBMI(
                        "kg" in weight.toString(),
                        w2n("kg" in weight.toString(), weight.toString()),
                        h2n("kg" in weight.toString(), height.toString())
                    )
                    if (Config.get("do_gui_safety_checks", true) as Boolean) {
                        if (weight.toString().contains("(")) {
                            logw("BMI details are already present")
                            return@hook
                        }
                    }
                    param.setResult(
                        "$weight - ${String.format("%.1f", BMI)} (${
                            mapOf(
                                "Underweight" to 18.5,
                                "Normal weight" to 24.9,
                                "Overweight" to 29.9,
                                "Obese" to Double.MAX_VALUE
                            ).entries.first { it.value > BMI }.key
                        })"
                    )
                }
            }
        }
    }

    // ADDED: Helper function to attach profile details handlers to any TextView
    private fun attachProfileDetailsHandlers(textView: TextView, sourceObject: Any) {
        try {
            // Extract profile ID from the source object
            val profile = when {
                // If it's a profile object directly
                callMethod(sourceObject, "getProfileId") != null -> sourceObject
                // If it's a fragment or view that contains a profile
                getObjectField(sourceObject, "profile") != null -> getObjectField(sourceObject, "profile")
                // If it's a quickbar view with profileViewState
                getObjectField(sourceObject, "profileViewState") != null ->
                    getObjectField(getObjectField(sourceObject, "profileViewState"), "profile")
                else -> null
            }

            val profileId = profile?.let { callMethod(it, "getProfileId") as? String } ?: run {
                loge("Could not extract profile ID from source object")
                return
            }

            // Click listener to copy profile ID
            textView.setOnClickListener {
                logd("Display name short-clicked for profile ID: $profileId. Attempting to copy ID.")
                copyToClipboard("Profile ID", profileId)
                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Copied Profile ID: $profileId")
            }

            // Long-click listener to show hidden details
            textView.setOnLongClickListener { v ->
                try {
                    logd("Display name LONG-clicked for profile ID: $profileId. Attempting to show deets.")
                    showProfileDetailsDialog(v.context, sourceObject)
                    true // Consume the long click
                } catch (e: Exception) {
                    Logger.e(
                        "Error showing profile details: ${e.message}",
                        source = LogSource.HOOK
                    )
                    false
                }
            }

            logd("SUCCESS: Attached profile details handlers to TextView for profile $profileId")
        } catch (e: Exception) {
            loge("Error attaching profile details handlers: ${e.message}")
        }
    }

    // ADDED: Helper function to show profile details dialog
    private fun showProfileDetailsDialog(context: Context, sourceObject: Any) {
        coroutineScope.launch {
            try {
                // Extract profile from various source object types
                val profile = when {
                    // Direct profile object
                    callMethod(sourceObject, "getProfileId") != null -> sourceObject
                    // ProfileViewState object
                    getObjectField(sourceObject, "profile") != null -> getObjectField(sourceObject, "profile")
                    // Quickbar view with profileViewState
                    getObjectField(sourceObject, "profileViewState") != null ->
                        getObjectField(getObjectField(sourceObject, "profileViewState"), "profile")
                    else -> null
                }

                if (profile == null) {
                    Toast.makeText(context, "No profile data available", Toast.LENGTH_SHORT).show()
                    return@launch
                }

                val profileId = callMethod(profile, "getProfileId") as String
                val accountCreationTime = formatEpochSeconds(
                    GrindrPlus.spline.invert(profileId.toDouble()).toLong()
                )

                val properties = mapOf(
                    "Estimated creation" to accountCreationTime,
                    "Profile ID" to profileId,
                    "Approximate distance" to Utils.safeGetField(
                        profile,
                        "approximateDistance"
                    ) as? Boolean,
                    "Favorite" to Utils.safeGetField(profile, "isFavorite") as? Boolean,
                    "From viewed me" to Utils.safeGetField(
                        profile,
                        "isFromViewedMe"
                    ) as? Boolean,
                    "JWT boosting" to Utils.safeGetField(
                        profile,
                        "isJwtBoosting"
                    ) as? Boolean,
                    "New" to Utils.safeGetField(profile, "isNew") as? Boolean,
                    "Teleporting" to Utils.safeGetField(
                        profile,
                        "isTeleporting"
                    ) as? Boolean,
                    "Online now" to Utils.safeGetField(
                        profile,
                        "onlineNow"
                    ) as? Boolean,
                    "Is roaming" to Utils.safeGetField(
                        profile,
                        "isRoaming"
                    ) as? Boolean,
                    "Found via roam" to Utils.safeGetField(
                        profile,
                        "foundViaRoam"
                    ) as? Boolean,
                    "Is top pick" to Utils.safeGetField(
                        profile,
                        "isTopPick"
                    ) as? Boolean,
                    "Is visiting" to Utils.safeGetField(
                        profile,
                        "isVisiting"
                    ) as? Boolean
                ).filterValues { it != null }

                val detailsText = if (properties.isNotEmpty()) {
                    properties.map { (key, value) -> "• $key: $value" }
                        .joinToString("\n")
                } else {
                    "No hidden details available for this profile"
                }

                AlertDialog.Builder(context)
                    .setTitle("Hidden profile details - $profileId")
                    .setMessage(detailsText)
                    .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                    .setNeutralButton("Copy Details") { _, _ ->
                        copyToClipboard("Profile Details", detailsText)
                        GrindrPlus.showToast(
                            Toast.LENGTH_SHORT,
                            "Profile details copied"
                        )
                    }
                    .setNegativeButton("Copy ID") { _, _ ->
                        copyToClipboard("Profile ID", profileId)
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Profile ID copied")
                    }
                    .show()
                    .apply {
                        setOnShowListener {
                            getButton(AlertDialog.BUTTON_POSITIVE)?.setTextColor(android.graphics.Color.WHITE)
                            getButton(AlertDialog.BUTTON_NEUTRAL)?.setTextColor(android.graphics.Color.WHITE)
                            getButton(AlertDialog.BUTTON_NEGATIVE)?.setTextColor(android.graphics.Color.WHITE)
                        }
                    }
            } catch (e: Exception) {
                loge("Error showing profile details: ${e.message}")
                Toast.makeText(context, "Failed to load details", Toast.LENGTH_SHORT).show()
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ProfileViews.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.RetrofitUtils.RETROFIT_NAME
import com.grindrplus.utils.RetrofitUtils.createServiceProxy
import com.grindrplus.utils.RetrofitUtils.findPOSTMethod
import com.grindrplus.utils.hook

class ProfileViews : Hook("Profile views", "Don't let others know you viewed their profile") {
    private val profileRestService = "com.grindrapp.android.api.ProfileRestService"
    private val blacklistedPaths = setOf(
        "v4/views/{profileId}",
        "v5/views/{profileId}",
        "v4/views"
    )

    override fun init() {
        val profileRestServiceClass = findClass(profileRestService)

        val methodBlacklist =
            blacklistedPaths.mapNotNull { findPOSTMethod(profileRestServiceClass, it)?.name }

        findClass(RETROFIT_NAME).hook("create", HookStage.AFTER) { param ->
            val service = param.getResult()
            if (service != null && profileRestServiceClass.isAssignableFrom(service.javaClass)) {
                param.setResult(
                    createServiceProxy(
                        service,
                        profileRestServiceClass,
                        methodBlacklist.toTypedArray()
                    )
                )
            }
        }
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ProfileViewsTracker.kt --- 
package com.grindrplus.hooks

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.DatabaseHelper
import com.grindrplus.core.Logger
import com.grindrplus.core.LogSource
import com.grindrplus.persistence.model.ProfileViewEntity
import com.grindrplus.utils.Hook
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject

class ProfileViewsTracker : Hook("Profile views tracker", "Track who viewed your profile") {

    data class ViewedProfileInfo(
        val profileId: String,
        val timestamp: Long,
        val displayName: String? = null,
        val distance: Double? = null,
        val mediaHash: String? = null,
        val source: String
    )

    companion object {
        private fun getDao() = GrindrPlus.database.profileViewDao()

        suspend fun getRecentViewedProfiles(limit: Int = 10): List<ViewedProfileInfo> {
            return getDao().getMostRecentViews(limit).map {
                ViewedProfileInfo(it.profileId, it.viewedAt, it.displayName, it.distance, it.mediaHash, it.source)
            }
        }

        suspend fun getViewedProfilesCount(): Int = getDao().getCount()

        suspend fun clearViewedProfiles() {
            getDao().clearAll()
            Logger.i("Cleared profile views history", LogSource.MODULE)
        }

        suspend fun refreshProfileViews() {
            if (!(Config.get("track_profile_views", true) as Boolean)) return
            Logger.d("Refreshing profile views from API...", LogSource.MODULE)
            try {
                // Try multiple possible endpoints
                val endpoints = listOf(
                    "https://grindr.mobi/v7/views/list",
                    "https://grindr.mobi/v6/views/list",
                    "https://grindr.mobi/v5/views/list"
                )

                var success = false
                for (endpoint in endpoints) {
                    try {
                        Logger.d("Trying endpoint: $endpoint", LogSource.MODULE)
                        val response = GrindrPlus.httpClient.sendRequest(endpoint, "GET")
                        if (response.isSuccessful) {
                            val bodyString = response.body?.string()
                            if (!bodyString.isNullOrEmpty()) {
                                processViewsListResponse(bodyString, endpoint)
                                success = true
                                Logger.d("Successfully fetched profile views from: $endpoint", LogSource.MODULE)
                                break
                            }
                        } else {
                            Logger.w("Endpoint $endpoint failed: HTTP ${response.code}", LogSource.MODULE)
                        }
                    } catch (e: Exception) {
                        Logger.w("Endpoint $endpoint error: ${e.message}", LogSource.MODULE)
                    }
                }

                if (!success) {
                    Logger.e("All profile views endpoints failed", LogSource.MODULE)
                }
            } catch (e: Exception) {
                Logger.e("Error refreshing profile views: ${e.message}", LogSource.MODULE)
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        private suspend fun processViewsListResponse(bodyString: String, endpoint: String) {
            try {
                val jsonResponse = JSONObject(bodyString)
                Logger.d("Processing views response from: $endpoint", LogSource.MODULE)

                // Process full profiles first
                val profiles = jsonResponse.optJSONArray("profiles")
                if (profiles != null) {
                    Logger.d("Found ${profiles.length()} full profiles", LogSource.MODULE)
                    for (i in 0 until profiles.length()) {
                        val profile = profiles.getJSONObject(i)
                        processProfileView(profile, "v7_full")
                    }
                }

                // Process previews and cross-reference with database
                val previews = jsonResponse.optJSONArray("previews")
                if (previews != null) {
                    Logger.d("Found ${previews.length()} preview entries", LogSource.MODULE)
                    for (i in 0 until previews.length()) {
                        val preview = previews.getJSONObject(i)
                        processPreviewView(preview, "v7_preview")
                    }
                }

                // Cross-reference any unresolved profiles
                crossReferenceUnresolvedProfiles()

            } catch (e: Exception) {
                Logger.e("Error processing views list: ${e.message}", LogSource.MODULE)
                throw e
            }
        }

        private suspend fun processProfileView(profile: JSONObject, source: String) {
            try {
                val profileId = profile.optString("profileId").takeIf { it.isNotEmpty() } ?: return
                val lastViewed = profile.optLong("lastViewed", System.currentTimeMillis())
                val displayName = profile.optString("displayName").takeIf { it.isNotEmpty() }
                val distance = profile.optDouble("distance").takeIf { !it.isNaN() && it > 0 }
                val mediaHash = profile.optString("profileImageMediaHash").takeIf { it.isNotEmpty() }

                // Enhanced database cross-reference - get additional info from local DB
                val enhancedInfo = getEnhancedProfileInfo(profileId)
                val finalDisplayName = enhancedInfo?.displayName ?: displayName
                val finalMediaHash = enhancedInfo?.mediaHash ?: mediaHash

                val entity = ProfileViewEntity(
                    profileId = profileId,
                    viewedAt = lastViewed,
                    displayName = finalDisplayName,
                    distance = distance,
                    mediaHash = finalMediaHash,
                    source = source
                )

                upsertView(entity)
                Logger.d("Processed profile view: $profileId - $finalDisplayName", LogSource.MODULE)

            } catch (e: Exception) {
                Logger.e("Error processing profile view: ${e.message}", LogSource.MODULE)
            }
        }

        private suspend fun processPreviewView(preview: JSONObject, source: String) {
            try {
                val mediaHash = preview.optString("profileImageMediaHash").takeIf { it.isNotEmpty() } ?: return
                val lastViewed = preview.optLong("lastViewed", System.currentTimeMillis())
                val distance = preview.optDouble("distance").takeIf { !it.isNaN() && it > 0 }
                val isFavorite = preview.optBoolean("isFavorite")

                // Try to resolve media hash to profile ID from database
                val profileInfo = resolveMediaHashToProfileInfo(mediaHash)

                if (profileInfo != null) {
                    // We found a match in the database
                    val entity = ProfileViewEntity(
                        profileId = profileInfo.profileId,
                        viewedAt = lastViewed,
                        displayName = profileInfo.displayName,
                        distance = distance,
                        mediaHash = mediaHash,
                        source = source
                    )
                    upsertView(entity)
                    Logger.d("Resolved preview to profile: ${profileInfo.profileId}", LogSource.MODULE)
                } else {
                    // No match found - create unresolved entry
                    val placeholderEntity = ProfileViewEntity(
                        profileId = "unresolved_${mediaHash.take(8)}",
                        viewedAt = lastViewed,
                        displayName = if (isFavorite) "⭐ Favorite (Unresolved)" else "🔒 Locked Profile",
                        distance = distance,
                        mediaHash = mediaHash,
                        source = "${source}_unresolved"
                    )
                    upsertView(placeholderEntity)
                    Logger.w("Added unresolved profile with media hash: $mediaHash", LogSource.MODULE)
                }

            } catch (e: Exception) {
                Logger.e("Error processing preview view: ${e.message}", LogSource.MODULE)
            }
        }

        private suspend fun crossReferenceUnresolvedProfiles() {
            try {
                // Get all unresolved entries
                val unresolvedViews = getDao().getUnresolvedViews()
                Logger.d("Cross-referencing ${unresolvedViews.size} unresolved profiles", LogSource.MODULE)

                for (view in unresolvedViews) {
                    val mediaHash = view.mediaHash ?: continue

                    // Try to resolve again
                    val profileInfo = resolveMediaHashToProfileInfo(mediaHash)
                    if (profileInfo != null) {
                        // Update the unresolved entry with real profile info
                        val resolvedEntity = ProfileViewEntity(
                            profileId = profileInfo.profileId,
                            viewedAt = view.viewedAt,
                            displayName = profileInfo.displayName,
                            distance = view.distance,
                            mediaHash = mediaHash,
                            source = view.source.replace("_unresolved", "_resolved")
                        )

                        // Delete the unresolved entry and add resolved one
                        getDao().delete(view)
                        getDao().upsert(resolvedEntity)

                        Logger.d("Resolved previously unresolved profile: ${profileInfo.profileId}", LogSource.MODULE)
                    }
                }
            } catch (e: Exception) {
                Logger.e("Error cross-referencing unresolved profiles: ${e.message}", LogSource.MODULE)
            }
        }

        private data class ProfileInfo(
            val profileId: String,
            val displayName: String?,
            val mediaHash: String?
        )

        private suspend fun resolveMediaHashToProfileInfo(mediaHash: String): ProfileInfo? = withContext(Dispatchers.IO) {
            try {
                // Query profile_photo table to get profile ID from media hash
                val profilePhotoResult = DatabaseHelper.query(
                    "SELECT profile_id FROM profile_photo WHERE media_hash = ?",
                    arrayOf(mediaHash)
                ).firstOrNull()

                val profileId = profilePhotoResult?.get("profile_id") as? String
                if (profileId == null) {
                    return@withContext null
                }

                // Query profile table to get display name
                val profileResult = DatabaseHelper.query(
                    "SELECT display_name FROM profile WHERE profile_id = ?",
                    arrayOf(profileId)
                ).firstOrNull()

                val displayName = profileResult?.get("display_name") as? String

                ProfileInfo(profileId, displayName, mediaHash)

            } catch (e: Exception) {
                Logger.e("Error resolving media hash to profile info: ${e.message}", LogSource.MODULE)
                null
            }
        }

        private suspend fun getEnhancedProfileInfo(profileId: String): ProfileInfo? = withContext(Dispatchers.IO) {
            try {
                // Get display name from profile table
                val profileResult = DatabaseHelper.query(
                    "SELECT display_name FROM profile WHERE profile_id = ?",
                    arrayOf(profileId)
                ).firstOrNull()

                val displayName = profileResult?.get("display_name") as? String

                // Get latest media hash from profile_photo table
                val mediaHashResult = DatabaseHelper.query(
                    "SELECT media_hash FROM profile_photo WHERE profile_id = ? ORDER BY created_at DESC LIMIT 1",
                    arrayOf(profileId)
                ).firstOrNull()

                val mediaHash = mediaHashResult?.get("media_hash") as? String

                ProfileInfo(profileId, displayName, mediaHash)

            } catch (e: Exception) {
                Logger.e("Error getting enhanced profile info: ${e.message}", LogSource.MODULE)
                null
            }
        }

        private suspend fun upsertView(entity: ProfileViewEntity) {
            try {
                val existing = getDao().getView(entity.profileId)
                if (existing == null || entity.viewedAt > existing.viewedAt) {
                    getDao().upsert(entity)
                    Logger.d("Upserted profile view: ${entity.profileId}", LogSource.MODULE)
                }
            } catch (e: Exception) {
                Logger.e("Error upserting profile view: ${e.message}", LogSource.MODULE)
            }
        }
    }

    override fun init() {
        if (!(Config.get("track_profile_views", true) as Boolean)) {
            Logger.i("Profile views tracking is disabled", LogSource.MODULE)
            return
        }

        GrindrPlus.executeAsync {
            refreshProfileViews()
        }

        Logger.i("ProfileViewsTracker initialized", LogSource.MODULE)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\QuickBlock.kt --- 
package com.grindrplus.hooks

import android.view.Menu
import android.view.MenuItem
import com.grindrplus.GrindrPlus
import com.grindrplus.ui.Utils.getId
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField

class QuickBlock : Hook(
    "Quick block",
    "Ability to block users quickly"
) {
    private val blockViewModel = "ff.b" // search for '("STATUS_BLOCK_DIALOG_SHOWN", 1)'
    private val profileViewHolder = "com.grindrapp.android.ui.profileV2.e" // search for 'com.grindrapp.android.ui.profileV2.ProfileViewHolder$onBind$3'

    override fun init() {
        findClass(profileViewHolder).hook("y", HookStage.AFTER) { param ->
            val arg0 = param.arg(0) as Any
            val profileId = param.args().getOrNull(1) ?: return@hook
            val viewBinding = getObjectField(arg0, "b")
            val profileToolbar = getObjectField(viewBinding, "q")
            val toolbarMenu = callMethod(profileToolbar, "getMenu") as Menu
            val menuActions = getId("menu_actions", "id", GrindrPlus.context)
            val actionsMenuItem = callMethod(toolbarMenu, "findItem", menuActions) as MenuItem
            actionsMenuItem.setOnMenuItemClickListener { GrindrPlus.httpClient.blockUser(profileId as String); true }
        }

        findClass(blockViewModel).hook("G", HookStage.BEFORE) { param ->
            val profileId = param.thisObject().javaClass.declaredFields
                .asSequence()
                .filter { it.type == String::class.java }
                .mapNotNull { field ->
                    try {
                        field.isAccessible = true
                        field.get(param.thisObject()) as? String
                    } catch (e: Exception) { null }
                }
                .firstOrNull { it.isNotEmpty() && it.all { char -> char.isDigit() } }
            GrindrPlus.httpClient.blockUser(profileId as String)
            param.setResult(null)
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ReverseRadarTabs.kt --- 
package com.grindrplus.hooks

import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import de.robv.android.xposed.XposedHelpers.*

class ReverseRadarTabs : Hook(
    "Reverse radar tabs",
    "Shows the received taps before profile views"
) {

    private inline fun <reified T : Any> getJavaClass() = T::class.java

    private val radarTabs = "m8.b"
    private val radarFragment = "com.grindrapp.android.radar.presentation.ui.RadarFragment"

    override fun init() {
        //Alternative which just scrolls to the tab fragment instead
        /*val viewPagerClass = findClass("androidx.viewpager2.widget.ViewPager2")
        findClass("com.grindrapp.android.radar.presentation.ui.RadarFragment")
            .hook("onViewCreated", HookStage.AFTER) {
                val view = it.arg<View>(0)
                val viewPager = view.findViewById<View>(
                    Utils.getId(
                        "radar_view_pager",
                        "id",
                        GrindrPlus.context
                    )
                )
                val setCurrentItem = viewPagerClass.getMethod("setCurrentItem", Int::class.java, Boolean::class.java)
                viewPager.post {
                    setCurrentItem.invoke(viewPager, 1, false)
                }
                //viewPagerClass.getMethod("setCurrentItem", Int::class.java).invoke(viewPager, 1)
            }*/

        val radarTabs = callStaticMethod(findClass(radarTabs), "values") as Array<*>

        findClass("$radarFragment\$a")
            .hookConstructor(HookStage.BEFORE) { param ->
                val tabs = param.arg(2, List::class.java)!!
                val reversed = findClass("kotlinx.collections.immutable.ExtensionsKt")
                    .getMethod("toImmutableList", Iterable::class.java)
                    .invoke(null, tabs.reversed())
                param.setArg(2, reversed)
            }


        //Unfortunately, some methods in RadarFragment use the ordinal of the RadarTab enum to determine the position in the TabLayout,
        //which no longer reflects the actual position in the ViewPager
        findClass("com.google.android.material.tabs.TabLayout")
            .hook("getTabAt", HookStage.BEFORE) { param ->
                if (!Thread.currentThread().stackTrace.any {
                        it.className.contains(radarFragment)
                    }) return@hook
                param.setArg(0, radarTabs.size - 1 - param.arg<Int>(0))
            }

        //This LiveData observer consumes the integer values from a flow and makes the ViewPager scroll to that position
        //This is used to make the ViewPager scroll to the taps page upon clicking such notification.
        //However, this is based on the ordinal values again, so we have to reverse the values, too.
        findClass("Ma.B")
            .hook("onChanged", HookStage.BEFORE) { param ->
                //Check whether this observer is responsible for handling the ViewPager position
                if (getIntField(param.thisObject(), "b") != 1) return@hook
                val position = param.arg<Number>(0).toInt()
                param.setArg(0, Integer.valueOf(radarTabs.size - 1 - position))
            }

        //The modified LiveData observer will no longer scroll to the first position when receiving a value 0.
        //In order to still show the new first tab (TapsFragment) by default, we need to set the initial value to the last index,
        //so that the LiveData observer reverts it back to 0.
        findClass("La.s0")
            .hookConstructor(HookStage.AFTER) { param ->
                val stateFlow = getObjectField(param.thisObject(), "J0")
                //Set initial position to the last page, so that the onChanged hook of the LiveData observer reverts it to the new first page
                callMethod(stateFlow, "setValue", Integer.valueOf(radarTabs.size - 1))
            }
    }

} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\SaveMediaOnLongPress.kt --- 
package com.grindrplus.hooks

import android.app.Activity
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.MediaUtils
import com.grindrplus.utils.hook

class SaveMediaOnLongPress : Hook(
    "Save on Long-Press",
    "Long-press any full-screen media (expiring, album, or chat) to save it to your gallery."
) {
    private val mediaActivities = setOf(
        "com.grindrapp.android.ui.photos.FullScreenExpiringImageActivity",
        "com.grindrapp.android.ui.albums.AlbumsVideoPlayerActivity",
        "com.grindrapp.android.ui.albums.AlbumCruiseActivity",
        "com.grindrapp.android.ui.photos.ChatRoomPhotosActivity"
    )

    override fun init() {
        mediaActivities.forEach { activityClassName ->
            hookActivity(activityClassName)
        }
    }

    private fun hookActivity(activityClassName: String) {
        try {
            findClass(activityClassName).hook("onCreate", HookStage.AFTER) { param ->
                val activity = param.thisObject() as Activity

                activity.window.decorView.post {
                    try {
                        val rootView = activity.findViewById<ViewGroup>(android.R.id.content)
                        val targetView = findTargetView(rootView)

                        if (targetView == null) {
                            loge("Could not find a suitable media view to attach listener in $activityClassName")
                            return@post
                        }

                        if (targetView.tag == "long_press_hook_applied") return@post
                        targetView.tag = "long_press_hook_applied"

                        targetView.setOnLongClickListener {
                            logd("Long-press detected in $activityClassName")

                            try {
                                val intent = activity.intent
                                val url = intent.getStringExtra("IMAGE_URL") ?: intent.getStringExtra("VIDEO_URL")
                                ?: intent.getStringExtra("image_url") ?: intent.getStringExtra("video_url")
                                ?: intent.dataString

                                if (url.isNullOrEmpty()) {
                                    throw IllegalStateException("Media URL not found in Intent extras.")
                                }

                                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Saving media...")

                                val isVideo = url.contains(".mp4") || activityClassName.contains("Video")
                                val contentType = if (isVideo) "video/mp4" else "image/jpeg"
                                val contentId = url.substringAfterLast("/").substringBefore("?")

                                val albumName = when {
                                    activityClassName.contains("Album") -> "Albums"
                                    activityClassName.contains("Expiring") -> "Expiring Media"
                                    activityClassName.contains("Chat") -> "Chat Media"
                                    else -> "Saved Media"
                                }

                                val profileId = intent.getStringExtra("profile_id") ?: "UnknownProfile"

                                MediaUtils.saveMediaToPublicDirectory(
                                    url = url,
                                    albumName = albumName,
                                    profileId = profileId,
                                    contentId = contentId,
                                    contentType = contentType
                                )
                                GrindrPlus.showToast(Toast.LENGTH_LONG, "Media saved to gallery!")

                            } catch (e: Exception) {
                                loge("Failed to save media on long-press: ${e.message}")
                                GrindrPlus.showToast(Toast.LENGTH_LONG, "Error: Could not save media.")
                                Logger.writeRaw(e.stackTraceToString())
                            }

                            true
                        }
                        logd("Successfully attached long-press listener to view in $activityClassName")
                    } catch (e: Exception) {
                        loge("Error in post-onCreate for $activityClassName: ${e.message}")
                    }
                }
            }
        } catch (e: Exception) {
            loge("Failed to find or hook class $activityClassName: ${e.message}")
        }
    }

    private fun findTargetView(view: View): View? {
        // From the Frida logs, we know the video player is a 'GrindrVideoView'.
        // For images, it could be a 'PhotoView', 'TouchImageView', or similar.
        val className = view.javaClass.name.lowercase()
        val targetClasses = listOf("photoview", "videoview", "playerview", "touchimageview", "grindrvideoview")

        if (targetClasses.any { className.contains(it) }) {
            return view
        }

        if (view is ViewGroup) {
            for (i in 0 until view.childCount) {
                val found = findTargetView(view.getChildAt(i))
                if (found != null) return found
            }
        }

        return null
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\SignatureSpoofer.kt --- 
package com.grindrplus.hooks

import android.content.ContextWrapper
import com.grindrplus.core.Constants.GRINDR_PACKAGE_NAME
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
import de.robv.android.xposed.XposedHelpers.findAndHookMethod
import de.robv.android.xposed.callbacks.XC_LoadPackage

private const val packageSignature = "823f5a17c33b16b4775480b31607e7df35d67af8"
private const val firebaseInstallationServiceClient =
    "com.google.firebase.installations.remote.FirebaseInstallationServiceClient"
private const val configRealtimeHttpClient =
    "com.google.firebase.remoteconfig.internal.ConfigRealtimeHttpClient"
private const val configFetchHttpClient =
    "com.google.firebase.remoteconfig.internal.ConfigFetchHttpClient"

@OptIn(ExperimentalStdlibApi::class)
fun spoofSignatures(param: XC_LoadPackage.LoadPackageParam) {

    listOf(
        firebaseInstallationServiceClient,
        configRealtimeHttpClient,
        configFetchHttpClient
    ).forEach { className ->
        findAndHookMethod(
            className,
            param.classLoader,
            "getFingerprintHashForPackage",
            object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam<*>) {
                    param.result = packageSignature
                }
            })
    }

    findAndHookMethod(
        "ly.img.android.c",
        param.classLoader,
        "d", // getPackageName
        object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam<*>) {
                param.result = GRINDR_PACKAGE_NAME
            }
        })

    // The Facebook SDK tries to handle the login using the Facebook app in case it is installed.
    // However, the Facebook app does signature checks with the app that is requesting the authentication,
    // which ends up making the Facebook server reject with an invalid key hash for the app signature.
    // Override the Facebook SDK to always handle the login using the web browser, which does not perform
    // signature checks.
    //
    // Always return 0 (no Intent was launched) as the result of trying to authorize with the Facebook app to
    // make the login fallback to a web browser window.
    //
    findAndHookMethod(
        "com.facebook.login.KatanaProxyLoginMethodHandler",
        param.classLoader,
        "tryAuthorize",
        XposedHelpers.findClass("com.facebook.login.LoginClient\$Request", param.classLoader),
        object : XC_MethodHook() {
            override fun afterHookedMethod(param: MethodHookParam<*>) {
                param.result = 0
            }
        }
    )

    if (param.packageName != GRINDR_PACKAGE_NAME) {
        fun isFirebaseInstallationServiceClient() = Thread.currentThread().stackTrace.any {
            it.className.startsWith("com.google.firebase.installations.remote.FirebaseInstallationServiceClient")
        }

        findAndHookMethod(
            ContextWrapper::class.java,
            "getPackageName",
            object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam<*>) {
                    if (isFirebaseInstallationServiceClient()) {
                        param.result = GRINDR_PACKAGE_NAME
                    }
                }
            }
        )


        fun isFirebase() = Thread.currentThread().stackTrace.any {
            it.className.startsWith("com.google.firebase")
        }

        fun isFacebook() = Thread.currentThread().stackTrace.any {
            it.className.startsWith("com.facebook")
        }

        findAndHookMethod(
            ContextWrapper::class.java,
            "getPackageName",
            object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam<*>) {
                    if (isFirebase() || isFacebook()) {
                        param.result = GRINDR_PACKAGE_NAME
                    }
                }
            }
        )

        findAndHookMethod(
            "com.google.firebase.messaging.Metadata",
            param.classLoader,
            "getPackageInfo",
            String::class.java,  // packageName
            object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam<*>) {
                    if ((param.args[0] as String).contains("grindr")) {
                        param.args[0] = GRINDR_PACKAGE_NAME
                    }
                }
            }
        )
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\SSLUnpinning.kt --- 
package com.grindrplus.hooks

import android.annotation.SuppressLint
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XC_MethodReplacement
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.findAndHookConstructor
import de.robv.android.xposed.XposedHelpers.findAndHookMethod
import de.robv.android.xposed.callbacks.XC_LoadPackage
import java.security.SecureRandom
import java.security.cert.X509Certificate
import javax.net.ssl.HostnameVerifier
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSession
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager

@OptIn(ExperimentalStdlibApi::class)
@SuppressLint("CustomX509TrustManager", "TrustAllX509TrustManager", "BadHostnameVerifier")
fun sslUnpinning(param: XC_LoadPackage.LoadPackageParam) {
    findAndHookConstructor(
        "okhttp3.OkHttpClient\$Builder",
        param.classLoader,
        object : XC_MethodHook() {
            override fun afterHookedMethod(param: MethodHookParam<*>) {
                val trustAlLCerts =
                    arrayOf<TrustManager>(
                        object : X509TrustManager {
                            override fun checkClientTrusted(
                                chain: Array<out X509Certificate>?,
                                authType: String?,
                            ) {}

                            override fun checkServerTrusted(
                                chain: Array<out X509Certificate>?,
                                authType: String?,
                            ) {}

                            override fun getAcceptedIssuers(): Array<X509Certificate> = emptyArray()
                        }
                    )
                val sslContext = SSLContext.getInstance("TLSv1.3")
                sslContext.init(null, trustAlLCerts, SecureRandom())
                callMethod(
                    param.thisObject,
                    "sslSocketFactory",
                    sslContext.socketFactory,
                    trustAlLCerts.first() as X509TrustManager
                )
                callMethod(
                    param.thisObject,
                    "hostnameVerifier",
                    object : HostnameVerifier {
                        override fun verify(hostname: String?, session: SSLSession?): Boolean = true
                    }
                )
            }
        }
    )

    findAndHookMethod(
        "okhttp3.OkHttpClient\$Builder",
        param.classLoader,
        "certificatePinner",
        "okhttp3.CertificatePinner",
        XC_MethodReplacement.DO_NOTHING
    )

    findAndHookMethod(
        "com.android.org.conscrypt.TrustManagerImpl",
        param.classLoader,
        "verifyChain",
        List::class.java, // List<X509Certificate> untrustedChain
        List::class.java, // List<TrustAnchor> trustAnchorChain
        String::class.java, // String host
        Boolean::class.java, // boolean clientAuth
        ByteArray::class.java, // byte[] ocspData
        ByteArray::class.java, // byte[] tlsSctData
        object : XC_MethodHook() {
            override fun beforeHookedMethod(param: MethodHookParam<*>) {
                param.result = param.args[0]
            }
        }
    )
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\StatusDialog.kt --- 
package com.grindrplus.hooks

import android.annotation.SuppressLint
import android.app.AlertDialog
import android.content.Context
import android.content.Intent
import android.os.Build
import android.text.InputType
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.EditText
import android.widget.ImageButton
import android.widget.LinearLayout
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.Spinner
import android.widget.Switch
import android.widget.TextView
import android.widget.Toast
import androidx.core.view.children
import com.grindrplus.BuildConfig
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import com.grindrplus.ui.Utils.copyToClipboard
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import kotlin.math.abs
import kotlinx.coroutines.runBlocking

class StatusDialog : Hook(
    "Status Dialog",
    "Check whether GrindrPlus is alive or not"
) {
    private val tabView = "com.google.android.material.tabs.TabLayout\$TabView"
    private val homeActivityClass = "com.grindrapp.android.ui.home.HomeActivity"

    override fun init() {
        findClass(tabView).hookConstructor(HookStage.AFTER) { param ->
            val tabView = param.thisObject() as View
            tabView.post {
                val parent = tabView.parent as? ViewGroup
                val position = parent?.indexOfChild(tabView) ?: -1
                when (position) {
                    0 -> tabView.setOnLongClickListener { v ->
                        showGrindrPlusInfoDialog(v.context)
                        true
                    }
                    2 -> tabView.setOnLongClickListener { v ->
                        showProfileViewsDialog(v.context)
                        true
                    }
                }
            }
        }

        try {
            findClass(homeActivityClass).hook("onCreate", HookStage.AFTER) { param ->
                val activity = param.thisObject() as? android.app.Activity ?: return@hook
                activity.window.decorView.post {
                    try {
                        val toolbarId = activity.resources.getIdentifier("home_toolbar", "id", activity.packageName)
                        if (toolbarId == 0) return@post
                        val toolbar = activity.findViewById<androidx.appcompat.widget.Toolbar>(toolbarId)
                        val navButton = toolbar?.children?.find { it is ImageButton }
                        navButton?.setOnLongClickListener { v ->
                            showProfileViewsDialog(v.context)
                            true
                        }
                    } catch (e: Exception) {
                        Logger.e("Failed to attach long-click to profile icon: ${e.message}", LogSource.HOOK)
                    }
                }
            }
        } catch (e: Exception) {
            Logger.e("Failed to hook HomeActivity for profile icon long-click: ${e.message}", LogSource.HOOK)
        }
    }

    private fun showProfileViewsDialog(context: Context) {
        GrindrPlus.executeAsync {
            ProfileViewsTracker.refreshProfileViews()
            GrindrPlus.runOnMainThread(context) {
                GrindrPlus.executeAsync {
                    val recentViews = ProfileViewsTracker.getRecentViewedProfiles(10)
                    val totalCount = ProfileViewsTracker.getViewedProfilesCount()

                    GrindrPlus.runOnMainThread {
                        val message = if (recentViews.isEmpty()) {
                            "No profile views tracked yet."
                        } else {
                            val dateFormat = SimpleDateFormat("MMM dd, HH:mm", Locale.US)
                            buildString {
                                appendLine("Recent profile views (${recentViews.size} of $totalCount total):")
                                recentViews.forEachIndexed { index, view ->
                                    appendLine()
                                    val timeStr = dateFormat.format(Date(view.timestamp))
                                    val nameStr = view.displayName?.let { " ($it)" } ?: ""
                                    appendLine("${index + 1}. ${view.profileId}$nameStr at $timeStr")
                                }
                            }
                        }

                        val builder = AlertDialog.Builder(context)
                            .setTitle("Recent Profile Views")
                            .setMessage(message)
                            .setPositiveButton("Close", null)
                            .setIcon(android.R.drawable.ic_menu_view)

                        if (recentViews.isNotEmpty()) {
                            builder.setNeutralButton("Copy IDs") { _, _ ->
                                copyToClipboard("Profile IDs", recentViews.joinToString(", ") { it.profileId })
                                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Copied ${recentViews.size} profile IDs")
                            }
                        }
                        builder.show()
                    }
                }
            }
        }
    }

    private fun getGrindrPlusInfo(context: Context): String {
        return try {
            val pm = context.packageManager
            val pi = pm.getPackageInfo(context.packageName, 0)
            val versionCode = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) pi.longVersionCode else pi.versionCode.toLong()
            val coords = (Config.get("forced_coordinates", Config.get("current_location", "")) as String).ifEmpty { "Not Spoofing (stock)" }
            val androidId = (Config.get("android_device_id", "") as? String)?.takeIf { it.isNotEmpty() }?.let { "Spoofing ($it)" } ?: "Not Spoofing (stock)"

            buildString {
                appendLine("GrindrPlus is active and running\n")
                appendLine("App Information:")
                appendLine("• Version: ${pi.versionName} ($versionCode)")
                appendLine("• Package: ${context.packageName}")
                appendLine("• Android ID: $androidId")
                appendLine("• Location: $coords\n")
                appendLine("Module Information:")
                appendLine("• GrindrPlus: ${BuildConfig.VERSION_NAME}")
                appendLine("• Bridge Status: ${if (GrindrPlus.bridgeClient.isConnected()) "Connected" else "Disconnected"}\n")
                appendLine("Device Information:")
                appendLine("• Device: ${Build.MANUFACTURER} ${Build.MODEL}")
                appendLine("• Android: ${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})")
            }
        } catch (e: Exception) {
            "GrindrPlus is active.\n\nError getting details: ${e.message}"
        }
    }

    private fun showGrindrPlusInfoDialog(context: Context) {
        val message: String = getGrindrPlusInfo(context)
        val coords: String = (Config.get("forced_coordinates", Config.get("current_location", "")) as String).ifEmpty { "Not Spoofing (stock)" }

        AlertDialog.Builder(context)
            .setTitle("GrindrPlus")
            .setMessage(message)
            .setIcon(android.R.drawable.ic_dialog_info)
            .setPositiveButton("OK", null)
            .setNeutralButton("Filters") { _, _ -> showAdvancedFiltersDialog(context) }
            .setNegativeButton("Copy Coords") { _, _ ->
                copyToClipboard("Coordinates", coords)
                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Copied coordinates")
            }
            .show()
    }

    @SuppressLint("SetTextI18n")
    private fun showAdvancedFiltersDialog(context: Context) {
        val mainLayout = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(40, 20, 40, 20)
        }

        fun createDialogButton(text: String, onClick: () -> Unit): Button {
            return Button(context).apply {
                this.text = text
                setOnClickListener { onClick() }
            }
        }

        fun showSubDialog(title: String, builder: (LinearLayout) -> Unit) {
            val subLayout = LinearLayout(context).apply {
                orientation = LinearLayout.VERTICAL
                setPadding(40, 20, 40, 20)
            }
            builder(subLayout)
            AlertDialog.Builder(context)
                .setTitle(title)
                .setView(subLayout)
                .setPositiveButton("Close", null)
                .show()
        }

        mainLayout.addView(createDialogButton("General Filters") {
            showSubDialog("General Filters") { layout ->
                layout.addView(Switch(context).apply {
                    text = "Favorites Only"
                    isChecked = Config.get("filter_favorites_only", false) as Boolean
                    setOnCheckedChangeListener { _, isChecked -> Config.put("filter_favorites_only", isChecked) }
                })
                layout.addView(Switch(context).apply {
                    text = "Has Social Networks"
                    isChecked = Config.get("filter_has_social_networks", false) as Boolean
                    setOnCheckedChangeListener { _, isChecked -> Config.put("filter_has_social_networks", isChecked) }
                })
            }
        })

        mainLayout.addView(createDialogButton("Distance Filter") {
            showSubDialog("Distance Filter") { layout ->
                val distanceInput = EditText(context).apply {
                    hint = "Max distance in meters (0 to disable)"
                    setText((Config.get("filter_max_distance", 0) as Int).toString())
                    inputType = InputType.TYPE_CLASS_NUMBER
                }
                layout.addView(distanceInput)
                layout.addView(Button(context).apply {
                    text = "Apply"
                    setOnClickListener {
                        val distance = distanceInput.text.toString().toIntOrNull() ?: 0
                        Config.put("filter_max_distance", distance)
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Max distance set.")
                    }
                })
            }
        })

        mainLayout.addView(createDialogButton("Text Filters (About Me & Tags)") {
            showSubDialog("Text Filters") { layout ->
                val aboutInput = EditText(context).apply {
                    hint = "Text in 'About Me'"
                    setText(Config.get("filter_about_text", "") as String)
                }
                val aboutModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include); addView(exclude)
                    check(if (Config.get("filter_about_mode", "include") == "include") include.id else exclude.id)
                }

                val tagsInput = EditText(context).apply {
                    hint = "Tags (comma-separated)"
                    setText(Config.get("filter_tags", "") as String)
                }
                val tagsModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include (Any)"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include); addView(exclude)
                    check(if (Config.get("filter_tags_mode", "include") == "include") include.id else exclude.id)
                }

                val applyButton = Button(context).apply { text = "Apply" }
                applyButton.setOnClickListener {
                    Config.put("filter_about_text", aboutInput.text.toString())
                    Config.put("filter_about_mode", if (aboutModeGroup.checkedRadioButtonId == aboutModeGroup.getChildAt(0).id) "include" else "exclude")
                    Config.put("filter_tags", tagsInput.text.toString())
                    Config.put("filter_tags_mode", if (tagsModeGroup.checkedRadioButtonId == tagsModeGroup.getChildAt(0).id) "include" else "exclude")
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Text filters applied.")
                }

                layout.addView(TextView(context).apply { text = "About Me Filter"; setTypeface(null, android.graphics.Typeface.BOLD) })
                layout.addView(aboutInput)
                layout.addView(aboutModeGroup)
                layout.addView(TextView(context).apply { text = "Tags Filter"; setTypeface(null, android.graphics.Typeface.BOLD); setPadding(0, 16, 0, 0) })
                layout.addView(tagsInput)
                layout.addView(tagsModeGroup)
                layout.addView(applyButton)
            }
        })

        mainLayout.addView(createDialogButton("Attribute Filters (Age, etc.)") {
            showSubDialog("Attribute Filters") { layout ->
                layout.addView(TextView(context).apply { text = "Age Filter"; setTypeface(null, android.graphics.Typeface.BOLD) })
                val ageMinInput = EditText(context).apply {
                    hint = "Min Age"
                    setText((Config.get("filter_age_min", 0) as Int).toString())
                    inputType = InputType.TYPE_CLASS_NUMBER
                }
                layout.addView(ageMinInput)
                val ageMaxInput = EditText(context).apply {
                    hint = "Max Age"
                    setText((Config.get("filter_age_max", 0) as Int).toString())
                    inputType = InputType.TYPE_CLASS_NUMBER
                }
                layout.addView(ageMaxInput)
                val includeNoAgeSwitch = Switch(context).apply {
                    text = "Include profiles with no age"
                    isChecked = Config.get("filter_age_include_no_age", true) as Boolean
                }
                layout.addView(includeNoAgeSwitch)

                // Add spacing
                layout.addView(TextView(context).apply {
                    height = 30
                })

                // Ethnicity Spinner
                layout.addView(TextView(context).apply {
                    text = "Ethnicity"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                    setPadding(0, 8, 0, 8)
                })
                val ethnicitySpinner = Spinner(context)
                val ethnicityOptions = arrayOf("Any", "Asian", "Black", "Latino", "Middle Eastern", "Mixed", "Native American", "South Asian", "White", "Other")
                val ethnicityAdapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, ethnicityOptions).apply {
                    setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                }
                ethnicitySpinner.adapter = ethnicityAdapter
                val savedEthnicity = Config.get("filter_ethnicity", "0") as String
                val ethnicityInt = savedEthnicity.toIntOrNull() ?: 0
                if (ethnicityInt in ethnicityOptions.indices) {
                    ethnicitySpinner.setSelection(ethnicityInt)
                }
                layout.addView(ethnicitySpinner)
                val ethnicityModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include); addView(exclude)
                    check(if (Config.get("filter_ethnicity_mode", "include") == "include") include.id else exclude.id)
                }
                layout.addView(ethnicityModeGroup)

                // Gender Spinner
                layout.addView(TextView(context).apply {
                    text = "Gender"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                    setPadding(0, 16, 0, 8)
                })
                val genderSpinner = Spinner(context)
                val genderOptions = arrayOf("Any", "Man", "Trans", "Non-binary", "Cis Woman", "Trans Woman", "Cis Man", "Trans Man")
                val genderAdapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, genderOptions).apply {
                    setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                }
                genderSpinner.adapter = genderAdapter
                val savedGender = Config.get("filter_gender", 0) as Int
                if (savedGender in genderOptions.indices) {
                    genderSpinner.setSelection(savedGender)
                }
                layout.addView(genderSpinner)

                // Tribe Spinner
                layout.addView(TextView(context).apply {
                    text = "Tribe"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                    setPadding(0, 16, 0, 8)
                })
                val tribeSpinner = Spinner(context)
                val tribeOptions = arrayOf("Any", "Bear", "Clean-Cut", "Daddy", "Discreet", "Geek", "Jock", "Leather", "Military", "Otter", "Poz", "Rugged", "Sober", "Trans", "Twink")
                val tribeAdapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, tribeOptions).apply {
                    setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                }
                tribeSpinner.adapter = tribeAdapter
                val savedTribe = Config.get("filter_tribe", 0) as Int
                if (savedTribe in tribeOptions.indices) {
                    tribeSpinner.setSelection(savedTribe)
                }
                layout.addView(tribeSpinner)

                val applyButton = Button(context).apply { text = "Apply Filters"; layoutParams = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT).apply { topMargin = 32 } }
                applyButton.setOnClickListener {
                    Config.put("filter_age_min", ageMinInput.text.toString().toIntOrNull() ?: 0)
                    Config.put("filter_age_max", ageMaxInput.text.toString().toIntOrNull() ?: 0)
                    Config.put("filter_age_include_no_age", includeNoAgeSwitch.isChecked)
                    Config.put("filter_ethnicity", ethnicitySpinner.selectedItemPosition.toString())
                    Config.put("filter_ethnicity_mode", if (ethnicityModeGroup.checkedRadioButtonId == ethnicityModeGroup.getChildAt(0).id) "include" else "exclude")
                    Config.put("filter_gender", genderSpinner.selectedItemPosition)
                    Config.put("filter_tribe", tribeSpinner.selectedItemPosition)
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Attribute filters applied.")
                }
                layout.addView(applyButton)
            }
        })

        val toggleLayout = LinearLayout(context).apply {
            orientation = LinearLayout.HORIZONTAL
            gravity = android.view.Gravity.CENTER_VERTICAL
            setPadding(0, 20, 0, 10)
        }
        val statusText = TextView(context).apply {
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
        }
        val masterSwitch = Switch(context).apply {
            isChecked = Config.get("custom_filtering_enabled", false) as Boolean
            statusText.text = if (isChecked) "Filtering is ON" else "Filtering is OFF"
            setOnCheckedChangeListener { _, isChecked ->
                Config.put("custom_filtering_enabled", isChecked)
                statusText.text = if (isChecked) "Filtering is ON" else "Filtering is OFF"
            }
        }
        toggleLayout.addView(statusText)
        toggleLayout.addView(masterSwitch)
        mainLayout.addView(toggleLayout)

        AlertDialog.Builder(context)
            .setTitle("Advanced Cascade Filters")
            .setView(mainLayout)
            .setPositiveButton("Close", null)
            .setNegativeButton("Reset All") { _, _ ->
                Config.put("custom_filtering_enabled", false)
                Config.put("filter_max_distance", 0)
                Config.put("filter_favorites_only", false)
                Config.put("filter_has_social_networks", false)
                Config.put("filter_about_text", "")
                Config.put("filter_about_mode", "include")
                Config.put("filter_tags", "")
                Config.put("filter_tags_mode", "include")
                Config.put("filter_age_min", 0)
                Config.put("filter_age_max", 0)
                Config.put("filter_age_include_no_age", true)
                Config.put("filter_ethnicity", "0")
                Config.put("filter_ethnicity_mode", "include")
                Config.put("filter_gender", 0)
                Config.put("filter_tribe", 0)
                GrindrPlus.showToast(Toast.LENGTH_SHORT, "All filters have been reset.")
            }
            .show()
    }
}


    @SuppressLint("SetTextI18n")
    private fun showAdvancedFiltersDialog(context: Context) {
        val mainLayout = LinearLayout(context).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(40, 20, 40, 20)
        }

        fun createDialogButton(text: String, onClick: () -> Unit): Button {
            return Button(context).apply {
                this.text = text
                setOnClickListener { onClick() }
            }
        }

        fun showSubDialog(title: String, builder: (LinearLayout) -> Unit) {
            val subLayout = LinearLayout(context).apply {
                orientation = LinearLayout.VERTICAL
                setPadding(40, 20, 40, 20)
            }
            builder(subLayout)
            AlertDialog.Builder(context)
                .setTitle(title)
                .setView(subLayout)
                .setPositiveButton("Close", null)
                .show()
        }

        mainLayout.addView(createDialogButton("General Filters") {
            showSubDialog("General Filters") { layout ->
                layout.addView(Switch(context).apply {
                    text = "Favorites Only"
                    isChecked = Config.get("filter_favorites_only", false) as Boolean
                    setOnCheckedChangeListener { _, isChecked -> Config.put("filter_favorites_only", isChecked) }
                })
                layout.addView(Switch(context).apply {
                    text = "Has Social Networks"
                    isChecked = Config.get("filter_has_social_networks", false) as Boolean
                    setOnCheckedChangeListener { _, isChecked -> Config.put("filter_has_social_networks", isChecked) }
                })
            }
        })

        mainLayout.addView(createDialogButton("Distance Filter") {
            showSubDialog("Distance Filter") { layout ->
                val distanceInput = EditText(context).apply {
                    hint = "Max distance in meters (0 to disable)"
                    setText((Config.get("filter_max_distance", 0) as Int).toString())
                    inputType = InputType.TYPE_CLASS_NUMBER
                }
                layout.addView(distanceInput)
                layout.addView(Button(context).apply {
                    text = "Apply"
                    setOnClickListener {
                        val distance = distanceInput.text.toString().toIntOrNull() ?: 0
                        Config.put("filter_max_distance", distance)
                        GrindrPlus.showToast(Toast.LENGTH_SHORT, "Max distance set.")
                    }
                })
            }
        })

        mainLayout.addView(createDialogButton("Text Filters (About Me & Tags)") {
            showSubDialog("Text Filters") { layout ->
                // About Me
                val aboutInput = EditText(context).apply {
                    hint = "Text in 'About Me' (e.g., travel)"
                    setText(Config.get("filter_about_text", "") as String)
                }
                val aboutModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include)
                    addView(exclude)
                    check(if (Config.get("filter_about_mode", "include") == "include") include.id else exclude.id)
                }

                // Tags
                val tagsInput = EditText(context).apply {
                    hint = "Tags (comma-separated, e.g., bear,otter)"
                    setText(Config.get("filter_tags", "") as String)
                }
                val tagsModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include (Any)"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include)
                    addView(exclude)
                    check(if (Config.get("filter_tags_mode", "include") == "include") include.id else exclude.id)
                }

                val applyButton = Button(context).apply { text = "Apply" }
                applyButton.setOnClickListener {
                    Config.put("filter_about_text", aboutInput.text.toString())
                    Config.put("filter_about_mode", if (aboutModeGroup.checkedRadioButtonId == aboutModeGroup.getChildAt(0).id) "include" else "exclude")
                    Config.put("filter_tags", tagsInput.text.toString())
                    Config.put("filter_tags_mode", if (tagsModeGroup.checkedRadioButtonId == tagsModeGroup.getChildAt(0).id) "include" else "exclude")
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Text filters applied.")
                }

                layout.addView(TextView(context).apply { text = "About Me Filter"; setTypeface(null, android.graphics.Typeface.BOLD) })
                layout.addView(aboutInput)
                layout.addView(aboutModeGroup)
                layout.addView(TextView(context).apply { text = "Tags Filter"; setTypeface(null, android.graphics.Typeface.BOLD); setPadding(0, 16, 0, 0) })
                layout.addView(tagsInput)
                layout.addView(tagsModeGroup)
                layout.addView(applyButton)
            }
        })

        mainLayout.addView(createDialogButton("Text Filters (About Me & Tags)") {
            showSubDialog("Text Filters") { layout ->
                // About Me
                val aboutInput = EditText(context).apply {
                    hint = "Text in 'About Me' (e.g., travel)"
                    setText(Config.get("filter_about_text", "") as String)
                }
                val aboutModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include)
                    addView(exclude)
                    check(if (Config.get("filter_about_mode", "include") == "include") include.id else exclude.id)
                }

                // Tags
                val tagsInput = EditText(context).apply {
                    hint = "Tags (comma-separated, e.g., bear,otter)"
                    setText(Config.get("filter_tags", "") as String)
                }
                val tagsModeGroup = RadioGroup(context).apply {
                    orientation = RadioGroup.HORIZONTAL
                    val include = RadioButton(context).apply { text = "Include (Any)"; id = View.generateViewId() }
                    val exclude = RadioButton(context).apply { text = "Exclude"; id = View.generateViewId() }
                    addView(include)
                    addView(exclude)
                    check(if (Config.get("filter_tags_mode", "include") == "include") include.id else exclude.id)
                }

                val applyButton = Button(context).apply { text = "Apply" }
                applyButton.setOnClickListener {
                    Config.put("filter_about_text", aboutInput.text.toString())
                    Config.put("filter_about_mode", if (aboutModeGroup.checkedRadioButtonId == aboutModeGroup.getChildAt(0).id) "include" else "exclude")
                    Config.put("filter_tags", tagsInput.text.toString())
                    Config.put("filter_tags_mode", if (tagsModeGroup.checkedRadioButtonId == tagsModeGroup.getChildAt(0).id) "include" else "exclude")
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Text filters applied.")
                }

                layout.addView(TextView(context).apply { text = "About Me Filter"; setTypeface(null, android.graphics.Typeface.BOLD) })
                layout.addView(aboutInput)
                layout.addView(aboutModeGroup)
                layout.addView(TextView(context).apply { text = "Tags Filter"; setTypeface(null, android.graphics.Typeface.BOLD); setPadding(0, 16, 0, 0) })
                layout.addView(tagsInput)
                layout.addView(tagsModeGroup)
                layout.addView(applyButton)
            }
        })

        mainLayout.addView(createDialogButton("Attribute Filters (Age, etc.)") {
            showSubDialog("Attribute Filters") { layout ->
                // Age Section
                layout.addView(TextView(context).apply {
                    text = "Age Filter"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                })
                val ageMinInput = EditText(context).apply {
                    hint = "Min Age (e.g., 25)"
                    setText((Config.get("filter_age_min", 0) as Int).toString())
                    inputType = InputType.TYPE_CLASS_NUMBER
                }
                layout.addView(ageMinInput)
                val ageMaxInput = EditText(context).apply {
                    hint = "Max Age (e.g., 35)"
                    setText((Config.get("filter_age_max", 0) as Int).toString())
                    inputType = InputType.TYPE_CLASS_NUMBER
                }
                layout.addView(ageMaxInput)
                val includeNoAgeSwitch = Switch(context).apply {
                    text = "Include profiles with no age"
                    isChecked = Config.get("filter_age_include_no_age", true) as Boolean
                }
                layout.addView(includeNoAgeSwitch)
                // Add spacing
                layout.addView(TextView(context).apply {
                    height = 30
                })

                // Ethnicity Spinner
                val ethnicityLabel = TextView(context).apply {
                    text = "Ethnicity"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                    setPadding(0, 0, 0, 8)
                }
                layout.addView(ethnicityLabel)

                val ethnicitySpinner = Spinner(context)
                val ethnicityOptions = arrayOf(
                    "Any Ethnicity", "African", "Asian", "Caucasian", "Hispanic/Latino",
                    "Middle Eastern", "Mixed Race", "Native American", "Pacific Islander", "Other"
                )
                val ethnicityAdapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, ethnicityOptions)
                ethnicityAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                ethnicitySpinner.adapter = ethnicityAdapter

                // Set saved ethnicity if exists
                val savedEthnicity = Config.get("filter_ethnicity", "Any Ethnicity") as String
                val ethnicityPosition = ethnicityOptions.indexOfFirst { it == savedEthnicity }
                if (ethnicityPosition != -1) ethnicitySpinner.setSelection(ethnicityPosition)

                layout.addView(ethnicitySpinner)

                // Add spacing
                layout.addView(TextView(context).apply {
                    height = 20
                })

                // Gender Spinner
                val genderLabel = TextView(context).apply {
                    text = "Gender"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                    setPadding(0, 0, 0, 8)
                }
                layout.addView(genderLabel)

                val genderSpinner = Spinner(context)
                val genderOptions = arrayOf(
                    "Any Gender", "Male", "Female", "Non-binary", "Genderqueer",
                    "Genderfluid", "Agender", "Bigender", "Two-spirit", "Trans Man",
                    "Trans Woman", "Cis Man", "Cis Woman", "Other"
                )
                val genderAdapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, genderOptions)
                genderAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                genderSpinner.adapter = genderAdapter

                // Set saved gender if exists
                val savedGender = Config.get("filter_gender", "Any Gender") as String
                val genderPosition = genderOptions.indexOfFirst { it == savedGender }
                if (genderPosition != -1) genderSpinner.setSelection(genderPosition)

                layout.addView(genderSpinner)

                // Add spacing
                layout.addView(TextView(context).apply {
                    height = 20
                })

                // Tribe Spinner
                val tribeLabel = TextView(context).apply {
                    text = "Tribe"
                    setTypeface(null, android.graphics.Typeface.BOLD)
                    setPadding(0, 0, 0, 8)
                }
                layout.addView(tribeLabel)

                val tribeSpinner = Spinner(context)
                val tribeOptions = arrayOf(
                    "Any Tribe", "Bear", "Otter", "Trans", "Sober", "Twink", "College",
                    "Jock", "Leather", "Daddy", "Discreet", "Poz", "Negative", "Undetectable",
                    "Geek", "Military", "Rugby", "Gym Rat", "Student", "Professional"
                )
                val tribeAdapter = ArrayAdapter(context, android.R.layout.simple_spinner_item, tribeOptions)
                tribeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                tribeSpinner.adapter = tribeAdapter

                // Set saved tribe if exists
                val savedTribe = Config.get("filter_tribe", "Any Tribe") as String
                val tribePosition = tribeOptions.indexOfFirst { it == savedTribe }
                if (tribePosition != -1) tribeSpinner.setSelection(tribePosition)

                layout.addView(tribeSpinner)

                // Add spacing before apply button
                layout.addView(TextView(context).apply {
                    height = 30
                })

                val applyButton = Button(context).apply { text = "Apply Filters" }
                applyButton.setOnClickListener {
                    // Save age filters
                    Config.put("filter_age_min", ageMinInput.text.toString().toIntOrNull() ?: 0)
                    Config.put("filter_age_max", ageMaxInput.text.toString().toIntOrNull() ?: 0)
                    Config.put("filter_age_include_no_age", includeNoAgeSwitch.isChecked)

                    // Save spinner values
                    Config.put("filter_ethnicity", ethnicitySpinner.selectedItem.toString())
                    Config.put("filter_gender", genderSpinner.selectedItem.toString())
                    Config.put("filter_tribe", tribeSpinner.selectedItem.toString())

                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Attribute filters applied.")
                }

                layout.addView(applyButton)
            }
        })

        val toggleLayout = LinearLayout(context).apply {
            orientation = LinearLayout.HORIZONTAL
            gravity = android.view.Gravity.CENTER_VERTICAL
            setPadding(0, 20, 0, 10)
        }
        val statusText = TextView(context).apply {
            layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
        }
        val masterSwitch = Switch(context).apply {
            isChecked = Config.get("custom_filtering_enabled", false) as Boolean
            statusText.text = if (isChecked) "Filtering is ON" else "Filtering is OFF"
            setOnCheckedChangeListener { _, isChecked ->
                Config.put("custom_filtering_enabled", isChecked)
                statusText.text = if (isChecked) "Filtering is ON" else "Filtering is OFF"
            }
        }
        toggleLayout.addView(statusText)
        toggleLayout.addView(masterSwitch)
        mainLayout.addView(toggleLayout)

        AlertDialog.Builder(context)
            .setTitle("Advanced Cascade Filters")
            .setView(mainLayout)
            .setPositiveButton("Close", null)
            .setNegativeButton("Reset All") { _, _ ->
                Config.put("custom_filtering_enabled", false)
                Config.put("filter_max_distance", 0)
                Config.put("filter_favorites_only", false)
                Config.put("filter_has_social_networks", false)
                Config.put("filter_about_text", "")
                Config.put("filter_about_mode", "include")
                Config.put("filter_tags", "")
                Config.put("filter_tags_mode", "include")
                Config.put("filter_age_min", 0)
                Config.put("filter_age_max", 0)
                Config.put("filter_age_include_no_age", true)
                // Reset spinner configs as well
                GrindrPlus.showToast(Toast.LENGTH_SHORT, "All filters have been reset.")
            }
            .show()
    }

// Ethnicity, Gender, Tribe (Spinners for selection)
/*
private fun showGrindrPlusDialog(context: Context) {
    GrindrPlus.currentActivity?.runOnUiThread {
        try {
            val packageManager = context.packageManager
            val packageInfo = packageManager.getPackageInfo(context.packageName, 0)

            val appVersionName = packageInfo.versionName
            val appVersionCode = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.longVersionCode
            } else {
                @Suppress("DEPRECATION")
                packageInfo.versionCode.toLong()
            }

            val packageName = context.packageName
            val deviceModel = "${Build.MANUFACTURER} ${Build.MODEL}"
            val androidVersion = "${Build.VERSION.RELEASE} (API ${Build.VERSION.SDK_INT})"
            val moduleVersion = try {
                BuildConfig.VERSION_NAME
            } catch (e: Exception) {
                "Unknown"
            }

            val bridgeStatus = if (GrindrPlus.bridgeClient.isConnected()) {
                "Connected"
            } else {
                "Disconnected"
            }

            val currentLocationCoords =
                (Config.get("forced_coordinates", Config.get("current_location", "")) as String)
                    .let { coords -> if (coords.isNotEmpty()) coords else "Not Spoofing (stock)" }

            val currentLocationName = if (currentLocationCoords != "Not Spoofing (stock)") {
                val parts = currentLocationCoords.split(",")
                if (parts.size == 2) {
                    val lat = parts[0].trim().toDoubleOrNull()
                    val lon = parts[1].trim().toDoubleOrNull()
                    if (lat != null && lon != null) {
                        runBlocking {
                            val locations =
                                GrindrPlus.database.teleportLocationDao().getLocations()
                            locations.find {
                                abs(it.latitude - lat) < 1e-6 && abs(it.longitude - lon) < 1e-6
                            }?.name ?: "Unnamed Location"
                        }
                    } else {
                        "Invalid Coordinates"
                    }
                } else {
                    "Invalid Coordinates"
                }
            } else {
                "Not Spoofing"
            }


            val androidDeviceIdStatus = (Config.get("android_device_id", "") as String)
                .let { id -> if (id.isNotEmpty()) "Spoofing ($id)" else "Not Spoofing (stock)" }

            val message = buildString {
                appendLine("GrindrPlus is active and running")
                appendLine()
                appendLine("App Information:")
                appendLine("• Version: $appVersionName ($appVersionCode)")
                appendLine("• Package: $packageName")
                appendLine("• Android ID: $androidDeviceIdStatus")
                appendLine("• Current Location Coords: $currentLocationCoords")
                appendLine("• Current Location Name: $currentLocationName")
                appendLine()
                appendLine("Module Information:")
                appendLine("• GrindrPlus: $moduleVersion")
                appendLine("• Bridge Status: $bridgeStatus")
                appendLine()
                appendLine("Device Information:")
                appendLine("• Device: $deviceModel")
                appendLine("• Android: $androidVersion")
                appendLine()
                appendLine("Long press this tab to show this dialog")
                appendLine("Long press the Interests tab for profile views")
            }


            AlertDialog.Builder(context)
                .setTitle("GrindrPlus")
                .setMessage(message)
                .setNegativeButton("Copy") { _, _ ->
                    val coords = if (currentLocationCoords == "Not Spoofing (stock)") {
                        try {
                            val locationManager =
                                context.getSystemService(Context.LOCATION_SERVICE) as LocationManager
                            val providers = listOf(
                                LocationManager.GPS_PROVIDER,
                                LocationManager.NETWORK_PROVIDER
                            )
                            var location: Location? = null
                            for (provider in providers) {
                                if (locationManager.isProviderEnabled(provider)) {
                                    location = locationManager.getLastKnownLocation(provider)
                                    if (location != null) break
                                }
                            }
                            if (location != null) "${location.latitude}, ${location.longitude}" else "Unable to get location"
                        } catch (e: Exception) {
                            "Unable to get location: ${e.message}"
                        }
                    } else {
                        currentLocationCoords
                    }
                    copyToClipboard("Coordinates", coords)
                    GrindrPlus.showToast(Toast.LENGTH_SHORT, "Copied coordinates")
                }

                .setNeutralButton("MORE") { _, _ ->
                    showMoreDialog(context)
                }
                .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                .setIcon(android.R.drawable.ic_dialog_info)
                .show()

        } catch (e: Exception) {
            AlertDialog.Builder(context)
                .setTitle("GrindrPlus")
                .setMessage("GrindrPlus is active and running\n\nError retrieving details: ${e.message}")
                .setPositiveButton("OK") { dialog, _ -> dialog.dismiss() }
                .show()
        }
    }
}
*/



//    private fun showMoreDialog(context: Context) {
//        val layout = LinearLayout(context).apply {
//            orientation = LinearLayout.VERTICAL
//            setPadding(32, 32, 32, 32)
//        }
//
//        val onlineCheck = CheckBox(context).apply {
//            text = "Online Now"
//            isChecked = Config.get("filter_online", false) as Boolean
//        }
//        layout.addView(onlineCheck)
//
//        val hasPhotoCheck = CheckBox(context).apply {
//            text = "Has Photo"
//            isChecked = Config.get("filter_has_photo", false) as Boolean
//        }
//        layout.addView(hasPhotoCheck)
//
//        val minAgeEdit = EditText(context).apply {
//            hint = "Min Age"
//            inputType = android.text.InputType.TYPE_CLASS_NUMBER
//            setText(Config.get("filter_min_age", "") as String)
//        }
//        layout.addView(minAgeEdit)
//
//        val maxAgeEdit = EditText(context).apply {
//            hint = "Max Age"
//            inputType = android.text.InputType.TYPE_CLASS_NUMBER
//            setText(Config.get("filter_max_age", "") as String)
//        }
//        layout.addView(maxAgeEdit)
//
//        AlertDialog.Builder(context)
//            .setTitle("Advanced Filters")
//            .setView(layout)
//            .setPositiveButton("Apply") { _, _ ->
//                Config.put("filter_online", onlineCheck.isChecked)
//                Config.put("filter_has_photo", hasPhotoCheck.isChecked)
//                Config.put("filter_min_age", minAgeEdit.text.toString())
//                Config.put("filter_max_age", maxAgeEdit.text.toString())
//                GrindrPlus.showToast(Toast.LENGTH_SHORT, "Filters applied")
//            }
//            .setNegativeButton("Cancel", null)
//            .show()
//    }
//}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\TimberLogging.kt --- 
package com.grindrplus.hooks

import android.annotation.SuppressLint
import android.util.Log
import com.grindrplus.BuildConfig
import com.grindrplus.core.Logger
import com.grindrplus.core.loge
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers

@SuppressLint("LogNotTimber")
class TimberLogging :
    Hook("Timber Logging", "Forces Timber to log messages even if no tree is planted") {
    override fun init() {
        if (!BuildConfig.DEBUG) {
            return
        }

        try {
            val forestClass = findClass("timber.log.Timber\$Forest")
            val logMethods = arrayOf("v", "d", "i", "w", "e", "wtf")

            for (method in logMethods) {
                forestClass.hook(method, HookStage.BEFORE) { param ->
                    if (param.args().isNotEmpty() && param.args()[0] is String) {
                        val priority =
                            when (method) {
                                "v" -> Log.VERBOSE
                                "d" -> Log.DEBUG
                                "i" -> Log.INFO
                                "w" -> Log.WARN
                                "e" -> Log.ERROR
                                "wtf" -> Log.ASSERT
                                else -> Log.INFO
                            }

                        val message = param.args()[0] as String
                        val tag =
                            XposedHelpers.getObjectField(param.thisObject(), "explicitTag")
                                ?.toString() ?: "Timber"

                        when (priority) {
                            Log.VERBOSE -> Log.v(tag, message)
                            Log.DEBUG -> Log.d(tag, message)
                            Log.INFO -> Log.i(tag, message)
                            Log.WARN -> Log.w(tag, message)
                            Log.ERROR -> Log.e(tag, message)
                            Log.ASSERT -> Log.e(tag, message)
                        }
                    }
                }

                forestClass.hook(method, HookStage.BEFORE) { param ->
                    if (
                        param.args().size >= 2 &&
                        param.args()[0] is Throwable &&
                        param.args()[1] is String
                    ) {
                        val priority =
                            when (method) {
                                "v" -> Log.VERBOSE
                                "d" -> Log.DEBUG
                                "i" -> Log.INFO
                                "w" -> Log.WARN
                                "e" -> Log.ERROR
                                "wtf" -> Log.ASSERT
                                else -> Log.INFO
                            }

                        val throwable = param.args()[0] as Throwable
                        val message = param.args()[1] as String
                        val tag =
                            XposedHelpers.getObjectField(param.thisObject(), "explicitTag")
                                ?.toString() ?: "Timber"

                        val fullMessage = "$tag: $message - Exception: ${throwable.message}"

                        when (priority) {
                            Log.VERBOSE -> Log.v(tag, fullMessage)
                            Log.DEBUG -> Log.d(tag, fullMessage)
                            Log.INFO -> Log.i(tag, fullMessage)
                            Log.WARN -> Log.w(tag, fullMessage)
                            Log.ERROR -> Log.e(tag, fullMessage)
                            Log.ASSERT -> Log.e(tag, fullMessage)
                        }
                    }
                }

                forestClass.hook(method, HookStage.BEFORE) { param ->
                    if (param.args().size == 1 && param.args()[0] is Throwable) {
                        val priority =
                            when (method) {
                                "v" -> Log.VERBOSE
                                "d" -> Log.DEBUG
                                "i" -> Log.INFO
                                "w" -> Log.WARN
                                "e" -> Log.ERROR
                                "wtf" -> Log.ASSERT
                                else -> Log.INFO
                            }

                        val throwable = param.args()[0] as Throwable
                        val tag =
                            XposedHelpers.getObjectField(param.thisObject(), "explicitTag")
                                ?.toString() ?: "Timber"

                        val fullMessage = "$tag: Exception: ${throwable.message}"

                        when (priority) {
                            Log.VERBOSE -> Log.v(tag, fullMessage)
                            Log.DEBUG -> Log.d(tag, fullMessage)
                            Log.INFO -> Log.i(tag, fullMessage)
                            Log.WARN -> Log.w(tag, fullMessage)
                            Log.ERROR -> Log.e(tag, fullMessage)
                            Log.ASSERT -> Log.e(tag, fullMessage)
                        }
                    }
                }
            }

            findClass("timber.log.Timber\$Tree").hook("log", HookStage.BEFORE) { param ->
                if (param.args().size >= 4) {
                    val priority = param.args()[0] as Int
                    val tag = param.args()[1] as? String ?: "Unknown"
                    val message = param.args()[2] as? String ?: "null"
                    val throwable = param.args()[3] as? Throwable

                    val fullMsg =
                        if (throwable != null) {
                            "$message - Exception: ${throwable.message}"
                        } else {
                            message
                        }

                    when (priority) {
                        Log.VERBOSE -> Log.v(tag, fullMsg)
                        Log.DEBUG -> Log.d(tag, fullMsg)
                        Log.INFO -> Log.i(tag, fullMsg)
                        Log.WARN -> Log.w(tag, fullMsg)
                        Log.ERROR -> Log.e(tag, fullMsg)
                        Log.ASSERT -> Log.e(tag, fullMsg)
                    }
                }
            }
        } catch (e: Exception) {
            loge("Failed to hook Timber: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\UnlimitedAlbums.kt --- 
package com.grindrplus.hooks


import android.content.Intent
import android.view.View
import android.widget.Toast
import androidx.room.withTransaction
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.core.logw
import com.grindrplus.persistence.mappers.asAlbumBriefToAlbumEntity
import com.grindrplus.persistence.mappers.asAlbumToAlbumEntity
import com.grindrplus.persistence.mappers.toAlbumContentEntity
import com.grindrplus.persistence.mappers.toGrindrAlbum
import com.grindrplus.persistence.mappers.toGrindrAlbumBrief
import com.grindrplus.persistence.mappers.toGrindrAlbumContent
import com.grindrplus.persistence.mappers.toGrindrAlbumWithoutContent
import com.grindrplus.persistence.model.AlbumContentEntity
import com.grindrplus.persistence.model.AlbumEntity
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.MediaUtils
import com.grindrplus.utils.RetrofitUtils
import com.grindrplus.utils.RetrofitUtils.createSuccess
import com.grindrplus.utils.RetrofitUtils.getSuccessValue
import com.grindrplus.utils.RetrofitUtils.isFail
import com.grindrplus.utils.RetrofitUtils.isGET
import com.grindrplus.utils.RetrofitUtils.isPUT
import com.grindrplus.utils.RetrofitUtils.isSuccess
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import com.grindrplus.utils.withSuspendResult
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField
import de.robv.android.xposed.XposedHelpers.setObjectField
import java.io.Closeable
import java.io.IOException
import kotlinx.coroutines.runBlocking
import org.json.JSONObject

class UnlimitedAlbums : Hook("Unlimited albums", "Allow to be able to view unlimited albums") {
    private val albumsService = "T4.a" // search for 'v1/albums/red-dot'
    private val albumModel = "com.grindrapp.android.model.Album"
    private val filteredSpankBankAlbumContent =
        "com.grindrapp.android.albums.spankbank.domain.model.FilteredSpankBankAlbumContent"
    private val spankBankAlbumModel =
        "com.grindrapp.android.albums.spankbank.domain.model.SpankBankAlbum"
    private val spankBankAlbumContentModel =
        "com.grindrapp.android.albums.spankbank.domain.model.SpankBankAlbumContent"
    private val httpExceptionResponse = "com.grindrapp.android.network.http.HttpExceptionResponse"
    private val sharedAlbumsBrief = "com.grindrapp.android.model.albums.SharedAlbumsBrief"
    private val albumsList = "com.grindrapp.android.model.AlbumsList"

    private val albumThumbView = "com.grindrapp.android.view.albums.AlbumThumbView"
    private val albumCruiseActivity = "com.grindrapp.android.ui.albums.AlbumCruiseActivity"

    override fun init() {
        // Bypass album paywall by overwriting the click listener on album thumbnails
        try {
            findClass(albumThumbView).hookConstructor(HookStage.AFTER) { param ->
                val thumbView = param.thisObject() as View
                val albumDataField = thumbView.javaClass.declaredFields.find {
                    it.type.name.contains("AlbumBrief")
                } ?: return@hookConstructor

                albumDataField.isAccessible = true
                val albumBrief = albumDataField.get(thumbView) ?: return@hookConstructor

                val albumId = getObjectField(albumBrief, "albumId") as Long
                val profileId = getObjectField(albumBrief, "profileId") as String

                thumbView.setOnClickListener {
                    try {
                        val context = it.context
                        val intent = Intent(context, findClass(albumCruiseActivity))
                        intent.putExtra("album_id", albumId)
                        intent.putExtra("profile_id", profileId)
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        context.startActivity(intent)
                    } catch (e: Exception) {
                        loge("Failed to launch AlbumCruiseActivity: ${e.message}")
                    }
                }
            }
        } catch (e: Exception) {
            loge("Failed to hook AlbumThumbView: ${e.message}")
        }

        // Hook API calls to save album data and provide offline access
        val albumsServiceClass = findClass(albumsService)
        RetrofitUtils.hookService(
            albumsServiceClass,
        ) { originalHandler, proxy, method, args ->
            val result = originalHandler.invoke(proxy, method, args)
            try {
                when {
                    method.isGET("v2/albums/{albumId}") -> handleGetAlbum(args, result)
                    method.isGET("v1/albums") -> handleGetAlbums(args, result)
                    method.isGET("v2/albums/shares") -> handleGetAlbumsShares(args, result)
                    method.isGET("v2/albums/shares/{profileId}") ->
                        handleGetAlbumsSharesProfileId(args, result)
                    method.isGET("v3/albums/{albumId}/view") ->
                        handleGetAlbumsViewAlbumId(args, result)
                    method.isPUT("v1/albums/{albumId}/shares/remove") ->
                        handleRemoveAlbumShares(args, result)
                    else -> result
                }
            } catch (e: Exception) {
                loge("Error handling album request: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }

        // Generic hooks to make various album-related objects always appear viewable
        findClass(albumModel).hookConstructor(HookStage.AFTER) { param ->
            try {
                setObjectField(param.thisObject(), "albumViewable", true)
                setObjectField(param.thisObject(), "viewableUntil", Long.MAX_VALUE)
            } catch (e: Exception) {
                loge("Error making album viewable: ${e.message}")
            }
        }
        findClass(spankBankAlbumModel).hookConstructor(HookStage.AFTER) { param ->
            try {
                setObjectField(param.thisObject(), "albumViewable", true)
                setObjectField(param.thisObject(), "expiresAt", Long.MAX_VALUE)
            } catch (e: Exception) {
                loge("Error making spank bank album viewable: ${e.message}")
            }
        }
        listOf(spankBankAlbumContentModel, filteredSpankBankAlbumContent).forEach { clazz ->
            findClass(clazz).hookConstructor(HookStage.AFTER) { param ->
                try {
                    setObjectField(param.thisObject(), "albumViewable", true)
                } catch (e: Exception) {
                    loge("Error making spank bank content viewable: ${e.message}")
                }
            }
        }
        findClass(albumModel).hook("isValid", HookStage.BEFORE) { param -> param.setResult(true) }
    }

    private suspend fun archiveAlbumData(album: AlbumEntity, contents: List<AlbumContentEntity>) {
        GrindrPlus.database.withTransaction {
            GrindrPlus.database.albumDao().upsertAlbum(album)
            GrindrPlus.database.albumDao().upsertAlbumContents(contents)
        }
        logi("Archiving ${contents.size} media items for album '${album.albumName}'")
        for (content in contents) {
            val url = content.url ?: continue
            MediaUtils.saveMediaToPublicDirectory(
                url = url,
                albumName = album.albumName ?: "album_${album.id}",
                profileId = album.profileId.toString(),
                contentId = content.id.toString(),
                contentType = content.contentType ?: ""
            )
        }
    }

    private fun handleRemoveAlbumShares(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { _, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logi("Removing album shares for ID: $albumId")
            if (result.isFail()) {
                try {
                    runBlocking {
                        val dao = GrindrPlus.database.albumDao()
                        if (dao.getAlbum(albumId) != null) {
                            dao.deleteAlbum(albumId)
                            createSuccess(albumId)
                        } else {
                            result
                        }
                    }
                } catch (e: Exception) {
                    loge("Failed to delete album $albumId: ${e.message}")
                    result
                }
            } else {
                result
            }
        }

    private fun handleGetAlbumsViewAlbumId(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { _, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            if (!result.isSuccess()) {
                runBlocking {
                    if (GrindrPlus.database.albumDao().albumExists(albumId)) {
                        logd("Album $albumId is viewable via database, returning success")
                        createSuccess(true)
                    } else {
                        result
                    }
                }
            } else {
                result
            }
        }

    private fun handleGetAlbum(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { _, initialResult ->
            val albumId = args[0] as? Long ?: return@withSuspendResult initialResult

            if (initialResult.isSuccess()) {
                logd("v2/albums/$albumId succeeded. Archiving result.")
                val grindrAlbum = initialResult.getSuccessValue()
                runBlocking {
                    val albumEntity = grindrAlbum.asAlbumToAlbumEntity()
                    val contentList = (getObjectField(grindrAlbum, "content") as? List<Any> ?: emptyList())
                        .map { it.toAlbumContentEntity(albumId) }
                    archiveAlbumData(albumEntity, contentList)
                }
                return@withSuspendResult initialResult
            }

            logw("v2/albums/$albumId failed. Trying v1 fallback and then database.")

            try {
                GrindrPlus.httpClient
                    .sendRequest(url = "https://grindr.mobi/v1/albums/$albumId", method = "GET")
                    .use { response ->
                        val responseBody = response.body?.string()
                        if (response.isSuccessful && !responseBody.isNullOrEmpty()) {
                            logi("v1/albums/$albumId fallback SUCCEEDED. Parsing and archiving.")
                            val json = JSONObject(responseBody)
                            val albumEntity = jsonToAlbumEntity(albumId, json)
                            val contentEntities = jsonToAlbumContentEntities(albumId, json)

                            runBlocking { archiveAlbumData(albumEntity, contentEntities) }

                            val grindrAlbumObject = albumEntity.toGrindrAlbum(contentEntities)
                            return@withSuspendResult createSuccess(grindrAlbumObject)
                        }
                    }
            } catch (e: Exception) {
                loge("v1/albums/$albumId fallback failed: ${e.message}")
            }

            logd("All network fallbacks failed for album $albumId. Checking local database.")
            return@withSuspendResult fetchAlbumFromDatabase(albumId, initialResult)
        }

    private fun jsonToAlbumEntity(albumId: Long, json: JSONObject): AlbumEntity {
        return AlbumEntity(
            id = albumId,
            albumName = json.optString("albumName", "Unknown Album"),
            createdAt = json.optString("createdAt", System.currentTimeMillis().toString()),
            profileId = json.optLong("profileId", 0L),
            updatedAt = json.optString("updatedAt", System.currentTimeMillis().toString())
        )
    }

    private fun jsonToAlbumContentEntities(albumId: Long, json: JSONObject): List<AlbumContentEntity> {
        val contentList = mutableListOf<AlbumContentEntity>()
        json.optJSONArray("content")?.let { contentArray ->
            for (i in 0 until contentArray.length()) {
                val contentJson = contentArray.getJSONObject(i)
                contentList.add(AlbumContentEntity(
                    id = contentJson.optLong("contentId"),
                    albumId = albumId,
                    contentType = contentJson.optString("contentType"),
                    coverUrl = contentJson.optString("coverUrl"),
                    thumbUrl = contentJson.optString("thumbUrl"),
                    url = contentJson.optString("url")
                ))
            }
        }
        return contentList
    }

    private fun fetchAlbumFromDatabase(albumId: Long, originalResult: Any): Any {
        return try {
            runBlocking {
                val dao = GrindrPlus.database.albumDao()
                val album = dao.getAlbum(albumId)
                if (album != null) {
                    val content = dao.getAlbumContent(albumId)
                    val albumObject = album.toGrindrAlbum(content)
                    createSuccess(albumObject)
                } else {
                    logw("Album $albumId not found in database")
                    originalResult
                }
            }
        } catch (e: Exception) {
            loge("Failed to load album $albumId from database: ${e.message}")
            originalResult
        }
    }

    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbums(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { _, result ->
            if (result.isSuccess()) {
                try {
                    val albums = getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                    if (albums != null) {
                        runBlocking {
                            albums.forEach { album ->
                                try {
                                    val albumEntity = album.asAlbumToAlbumEntity()
                                    val contentList = (getObjectField(album, "content") as? List<Any> ?: emptyList())
                                        .map { it.toAlbumContentEntity(albumEntity.id) }
                                    archiveAlbumData(albumEntity, contentList)
                                } catch (e: Exception) {
                                    loge("Error saving album: ${e.message}")
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error processing albums: ${e.message}")
                }
            }

            try {
                val albums = runBlocking {
                    GrindrPlus.database.albumDao().getAlbums().mapNotNull {
                        try {
                            val dbContent = GrindrPlus.database.albumDao().getAlbumContent(it.id)
                            it.toGrindrAlbum(dbContent)
                        } catch (e: Exception) {
                            null
                        }
                    }
                }
                val newValue = findClass(albumsList).getConstructor(List::class.java).newInstance(albums)
                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating albums list from database: ${e.message}")
                result
            }
        }

    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbumsShares(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { _, result ->
            if (result.isSuccess()) {
                try {
                    runBlocking {
                        val albumBriefs = getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                        albumBriefs?.forEach { albumBrief ->
                            try {
                                val albumEntity = albumBrief.asAlbumBriefToAlbumEntity()
                                val content = getObjectField(albumBrief, "content")
                                val contentList = if (content != null) listOf(content.toAlbumContentEntity(albumEntity.id)) else emptyList()
                                archiveAlbumData(albumEntity, contentList)
                            } catch (e: Exception) {
                                loge("Error processing album brief: ${e.message}")
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error saving album briefs: ${e.message}")
                }
            }
            try {
                val albumBriefs = runBlocking {
                    GrindrPlus.database.albumDao().getAlbums().mapNotNull {
                        try {
                            val dbContent = GrindrPlus.database.albumDao().getAlbumContent(it.id)
                            if (dbContent.isNotEmpty()) it.toGrindrAlbumBrief(dbContent.first()) else null
                        } catch (e: Exception) {
                            null
                        }
                    }
                }
                val newValue = findClass(sharedAlbumsBrief).getConstructor(List::class.java).newInstance(albumBriefs)
                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating shared albums brief from database: ${e.message}")
                result
            }
        }

    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbumsSharesProfileId(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { _, result ->
            val profileId = args[0] as? Long ?: return@withSuspendResult result
            logd("Fetching shared albums for profile ID: $profileId")

            if (result.isSuccess()) {
                try {
                    val albumBriefs = getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                    if (!albumBriefs.isNullOrEmpty()) {
                        logd("Received ${albumBriefs.size} album(s) from network. Checking for locked albums...")
                        runBlocking {
                            for (albumBrief in albumBriefs) {
                                val isViewable = getObjectField(albumBrief, "albumViewable") as? Boolean ?: false
                                val currentAlbumId = getObjectField(albumBrief, "albumId") as Long

                                val albumEntity = albumBrief.asAlbumBriefToAlbumEntity()
                                val content = getObjectField(albumBrief, "content")
                                val contentList = if (content != null) listOf(content.toAlbumContentEntity(albumEntity.id)) else emptyList()

                                if (isViewable) {
                                    archiveAlbumData(albumEntity, contentList)
                                } else {
                                    logi("Found locked album $currentAlbumId. Attempting v1 fallback unlock.")
                                    try {
                                        GrindrPlus.httpClient.sendRequest(
                                            url = "https://grindr.mobi/v1/albums/$currentAlbumId", method = "GET"
                                        ).use { v1Response ->
                                            val v1Body = v1Response.body?.string()
                                            if (v1Response.isSuccessful && !v1Body.isNullOrEmpty()) {
                                                logi("v1 fallback for $currentAlbumId SUCCEEDED. Archiving.")
                                                val json = JSONObject(v1Body)
                                                val unlockedAlbumEntity = jsonToAlbumEntity(currentAlbumId, json)
                                                val unlockedContentEntities = jsonToAlbumContentEntities(currentAlbumId, json)
                                                archiveAlbumData(unlockedAlbumEntity, unlockedContentEntities)
                                            }
                                        }
                                    } catch (e: Exception) {
                                        loge("Exception during v1 fallback for $currentAlbumId: ${e.message}")
                                    }
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error during proactive album unlocking: ${e.message}")
                }
            }

            try {
                val albumBriefsFromDb = runBlocking {
                    GrindrPlus.database.albumDao().getAlbums(profileId).mapNotNull {
                        try {
                            val dbContent = GrindrPlus.database.albumDao().getAlbumContent(it.id)
                            if (dbContent.isNotEmpty()) it.toGrindrAlbumBrief(dbContent.first()) else null
                        } catch (e: Exception) {
                            null
                        }
                    }
                }
                val newValue = findClass(sharedAlbumsBrief).getConstructor(List::class.java).newInstance(albumBriefsFromDb)
                return@withSuspendResult createSuccess(newValue)
            } catch (e: Exception) {
                loge("FATAL: Error creating final shared albums brief from database: ${e.message}")
                return@withSuspendResult result
            }
        }

    private inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {
        var closed = false
        try {
            return block(this)
        } catch (e: Exception) {
            closed = true
            try {
                this?.close()
            } catch (closeException: IOException) {
                e.addSuppressed(closeException)
            }
            throw e
        } finally {
            if (!closed) {
                this?.close()
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\UnlimitedProfiles.kt --- 
package com.grindrplus.hooks

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Utils.openProfile
import com.grindrplus.core.Logger
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.callStaticMethod
import de.robv.android.xposed.XposedHelpers.getObjectField
import de.robv.android.xposed.XposedHelpers.setObjectField
import java.lang.reflect.Proxy

class UnlimitedProfiles : Hook(
    "Unlimited profiles",
    "Allow unlimited profiles"
) {
    private val function2 = "kotlin.jvm.functions.Function2"
    private val onProfileClicked = "com.grindrapp.android.ui.browse.h\$a" // search for 'com.grindrapp.android.ui.browse.ServerDrivenCascadeViewModel$onProfileClicked$1'
    //changed from E
    private val profileWithPhoto = "com.grindrapp.android.persistence.pojo.ProfileWithPhoto"
    private val serverDrivenCascadeCachedState =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCacheState"
    private val serverDrivenCascadeCachedProfile =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCachedProfile"
    private val profileTagCascadeFragment = "com.grindrapp.android.ui.tagsearch.ProfileTagCascadeFragment"

    override fun init() {
        findClass(serverDrivenCascadeCachedState)
            .hook("getItems", HookStage.AFTER) { param ->
                val items = (param.getResult() as List<*>).filter {
                    it?.javaClass?.name == serverDrivenCascadeCachedProfile
                }

                param.setResult(items)
            }

        findClass(profileTagCascadeFragment)
            .hook("R", HookStage.BEFORE) { param ->
                param.setResult(true)
            }

        findClass(serverDrivenCascadeCachedProfile)
            .hook("getUpsellType", HookStage.BEFORE) { param ->
                param.setResult(null)
            }
        findClass(serverDrivenCascadeCachedProfile) // Also force isBlockable to true for paywalled profiles
            .hook("isBlockable", HookStage.BEFORE) { param ->
                param.setResult(true)
            }

        val profileClass = findClass("com.grindrapp.android.persistence.model.Profile")
        val profileWithPhotoClass = findClass(profileWithPhoto)
        val function2Class = findClass(function2)
        val flowKtClass = findClass("kotlinx.coroutines.flow.FlowKt")
        val profileRepoClass = findClass("com.grindrapp.android.persistence.repository.ProfileRepo")

        profileRepoClass.hook("getProfilesWithPhotosFlow", HookStage.AFTER) { param ->
            val requestedProfileIds = param.arg<List<String>>(0)
            if (requestedProfileIds.isEmpty()) return@hook

            val originalFlow = param.getResult()
            val profileWithPhotoConstructor = profileWithPhotoClass
                .getConstructor(profileClass, List::class.java)
            val profileConstructor = profileClass.getConstructor()

            val proxy = Proxy.newProxyInstance(
                GrindrPlus.classLoader,
                arrayOf(function2Class)
            ) { _, _, args ->
                @Suppress("UNCHECKED_CAST")
                val profilesWithPhoto = args[0] as List<Any>

                if (requestedProfileIds.size > profilesWithPhoto.size) {
                    val profileIds = ArrayList<String>(profilesWithPhoto.size)

                    for (profileWithPhoto in profilesWithPhoto) {
                        val profile = callMethod(profileWithPhoto, "getProfile")
                        profileIds.add(callMethod(profile, "getProfileId") as String)
                    }

                    val profileIdSet = profileIds.toHashSet()

                    val missingProfiles = ArrayList<Any>()
                    for (profileId in requestedProfileIds) {
                        if (profileId !in profileIdSet) {
                            val profile = profileConstructor.newInstance()
                            callMethod(profile, "setProfileId", profileId)
                            callMethod(profile, "setRemoteUpdatedTime", 0L)
                            callMethod(profile, "setLocalUpdatedTime", 0L)

                            missingProfiles.add(
                                profileWithPhotoConstructor.newInstance(profile, emptyList<Any>())
                            )
                        }
                    }

                    if (missingProfiles.isNotEmpty()) {
                        val result = ArrayList<Any>(profilesWithPhoto.size + missingProfiles.size)
                        result.addAll(profilesWithPhoto)
                        result.addAll(missingProfiles)
                        return@newProxyInstance result
                    }
                }

                profilesWithPhoto
            }

            val transformedFlow = callStaticMethod(flowKtClass, "mapLatest", originalFlow, proxy)
            param.setResult(transformedFlow)
        }

        // FIXED: Only hook swipe gestures, not all profile interactions
        // This was breaking ProfileDetails.kt click handlers
        findClass(onProfileClicked).hook("invokeSuspend", HookStage.BEFORE) { param ->
            try {
                // Find the field that holds the profile data within the click handler's scope.
                val profileDataField = param.thisObject().javaClass.declaredFields
                    .firstOrNull { it.type.name == serverDrivenCascadeCachedProfile }

                if (profileDataField == null) {
                    loge("Could not find ServerDrivenCascadeCachedProfile field in click handler.")
                    return@hook
                }

                profileDataField.isAccessible = true
                val cachedProfile = profileDataField.get(param.thisObject())

                // Extract the profileId directly from this reliable object.
                // The field name can vary slightly, so we try a few common ones.
                val profileId = getObjectField(cachedProfile, "profileId") as? Long
                    ?: getObjectField(cachedProfile, "profileIdLong") as? Long

                if (profileId != null) {
                    logi("Intercepted click for profile ID $profileId. Opening profile manually.")
                    openProfile(profileId.toString())

                    // This is the most important part: prevent the original, crash-inducing method from running.
                    param.setResult(null)
                } else {
                    loge("Successfully intercepted click, but could not extract profileId from cachedProfile object.")
                }
            } catch (t: Throwable) {
                loge("Error in onProfileClicked interceptor: ${t.message}")
                Logger.writeRaw(t.stackTraceToString())
            }
        }


        // Apply custom filters if enabled
        findClass(serverDrivenCascadeCachedState)
            .hook("getItems", HookStage.AFTER) { param ->
                if (!(Config.get("custom_filtering_enabled", false) as Boolean)) {
                    return@hook
                }

                val items = param.getResult() as? List<*> ?: return@hook
                val filteredItems = applyCustomFilters(items)

                if (filteredItems.size != items.size) {
                    Logger.d("Filtered ${items.size - filteredItems.size} profiles")
                }

                param.setResult(filteredItems)
            }
    }

    private fun safeGetField(obj: Any?, fieldName: String): Any? {
        return try {
            if (obj == null) return null
            val field = obj.javaClass.getDeclaredField(fieldName)
            field.isAccessible = true
            field.get(obj)
        } catch (e: Exception) {
            null
        }
    }

    private fun applyCustomFilters(profiles: List<Any?>): List<Any?> {
        val maxDistance = Config.get("filter_max_distance", 0) as Int
        val favoritesOnly = Config.get("filter_favorites_only", false) as Boolean
        val genderFilter = Config.get("filter_gender", 0) as Int
        val tribeFilter = Config.get("filter_tribe", 0) as Int
        val ethnicityFilter = Config.get("filter_ethnicity", "0") as String
        val ethnicityMode = Config.get("filter_ethnicity_mode", "include") as String
        val requireSocial = Config.get("filter_has_social_networks", false) as Boolean
        val tagsFilter = Config.get("filter_tags", "") as String
        val tagsMode = Config.get("filter_tags_mode", "include") as String
        val ageMin = Config.get("filter_age_min", 0) as Int
        val ageMax = Config.get("filter_age_max", 0) as Int
        val includeNoAge = Config.get("filter_age_include_no_age", true) as Boolean
        val aboutText = Config.get("filter_about_text", "") as String
        val aboutMode = Config.get("filter_about_mode", "include") as String

        val targetTags = if (tagsFilter.isNotEmpty()) {
            tagsFilter.split(",").map { it.trim().lowercase() }.filter { it.isNotEmpty() }.toSet()
        } else {
            emptySet()
        }

        return profiles.filter { profileItem ->
            if (profileItem == null) return@filter false

            try {
                val profileId = safeGetField(profileItem, "profileIdLong")?.toString() ?: "unknown"

                // Filter 1: Maximum Distance
                if (maxDistance > 0) {
                    val distanceMeters = (safeGetField(profileItem, "distanceMeters") as? Double)?.toInt()
                    if (distanceMeters != null && distanceMeters > maxDistance) {
                        return@filter false
                    }
                }

                // Filter 2: Favorites Only
                if (favoritesOnly) {
                    val isFavorite = safeGetField(profileItem, "isFavorite") as? Boolean
                    if (isFavorite != true) {
                        return@filter false
                    }
                }

                // Filter 3: Gender
                if (genderFilter > 0) {
                    @Suppress("UNCHECKED_CAST")
                    val genders = safeGetField(profileItem, "genders") as? List<Int>
                    val hasMatchingGender = genders?.contains(genderFilter) == true
                    if (!hasMatchingGender) {
                        return@filter false
                    }
                }

                // Filter 4: Tribe
                if (tribeFilter > 0) {
                    @Suppress("UNCHECKED_CAST")
                    val tribes = safeGetField(profileItem, "tribes") as? List<Int>
                    val hasMatchingTribe = tribes?.contains(tribeFilter) == true
                    if (!hasMatchingTribe) {
                        return@filter false
                    }
                }

                // Filter 5: Ethnicity
                if (ethnicityFilter != "0") {
                    val targetEthnicities = ethnicityFilter.split(",")
                        .mapNotNull { it.trim().toIntOrNull() }
                        .toSet()

                    if (targetEthnicities.isNotEmpty()) {
                        val profileEthnicity = safeGetField(profileItem, "ethnicity") as? Int
                        val matches = profileEthnicity != null && profileEthnicity in targetEthnicities

                        when (ethnicityMode) {
                            "include" -> if (!matches) return@filter false
                            "exclude" -> if (matches) return@filter false
                        }
                    }
                }

                // Filter 6: Social Networks
                if (requireSocial) {
                    @Suppress("UNCHECKED_CAST")
                    val socialNetworks = safeGetField(profileItem, "socialNetworks") as? List<*>
                    if (socialNetworks.isNullOrEmpty()) {
                        return@filter false
                    }
                }

                // Filter 7: About Me Text
                if (aboutText.isNotEmpty()) {
                    val aboutMe = safeGetField(profileItem, "aboutMe") as? String ?: ""
                    val containsText = aboutMe.contains(aboutText, ignoreCase = true)

                    when (aboutMode) {
                        "include" -> if (!containsText) return@filter false
                        "exclude" -> if (containsText) return@filter false
                    }
                }

                // Filter 8: Tags
                if (targetTags.isNotEmpty()) {
                    @Suppress("UNCHECKED_CAST")
                    val profileTags = safeGetField(profileItem, "tags") as? List<String>
                    val profileTagSet = profileTags?.map { it.lowercase() }?.toSet() ?: emptySet()

                    val hasMatchingTag = targetTags.any { targetTag ->
                        profileTagSet.any { profileTag -> profileTag.contains(targetTag) }
                    }

                    when (tagsMode) {
                        "include" -> if (!hasMatchingTag) return@filter false
                        "exclude" -> if (hasMatchingTag) return@filter false
                    }
                }

                // Filter 9: Age
                if (ageMin > 0 || ageMax > 0) {
                    val profileAge = safeGetField(profileItem, "age") as? Int

                    if (profileAge == null) {
                        if (!includeNoAge) {
                            return@filter false
                        }
                    } else {
                        val ageInRange = when {
                            ageMin == ageMax -> profileAge == ageMin
                            else -> profileAge in ageMin..ageMax
                        }

                        if (!ageInRange) {
                            return@filter false
                        }
                    }
                }

                true

            } catch (e: Exception) {
                Logger.e("Error filtering profile: ${e.message}")
                true
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\ViewedMe.kt --- 
package com.grindrplus.hooks

import com.grindrplus.core.Logger
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod
import java.util.concurrent.ConcurrentHashMap

class ViewedMe : Hook(
    "Viewed Me Enhancer",
    "Uncap views, reveal hidden profiles via cache, and capture eyeball data"
) {
    private val profileClass = "com.grindrapp.android.persistence.model.Profile"

    // Global cache to map MediaHashes to ProfileIDs
    companion object {
        val idCache = ConcurrentHashMap<String, String>()
    }

    override fun init() {

        // -------------------------------------------------------------------------
        // 1. CACHE BUILDER & INJECTOR
        // -------------------------------------------------------------------------

        // When the app sets a Profile ID, we check if we already have a Hash for this object
        // and update our cache.
        findClass(profileClass).hook("setProfileId", HookStage.AFTER) { param ->
            val profile = param.thisObject()
            val id = param.arg<Any>(0)?.toString() ?: return@hook

            // Try to get the hash from the object
            val hash = callMethod(profile, "getProfileImageMediaHash") as? String
            if (!hash.isNullOrEmpty()) {
                idCache[hash] = id
            }
        }

        // When the app sets a Media Hash (this happens during JSON parsing of Viewed Me list),
        // we do two things:
        // A. If we already know the ID (from this object), update the cache.
        // B. If the ID is MISSING (which happens in Viewed Me Previews), try to find it in cache and INJECT IT.
        findClass(profileClass).hook("setProfileImageMediaHash", HookStage.AFTER) { param ->
            val profile = param.thisObject()
            val hash = param.arg<String>(0) ?: return@hook

            val currentId = try {
                callMethod(profile, "getProfileId") as? String
            } catch (e: Exception) { null }

            if (currentId != null) {
                // A. Normal case: We have both. Update cache.
                idCache[hash] = currentId
            } else {
                // B. Hidden case (Viewed Me Preview): We have hash, but no ID.
                val cachedId = idCache[hash]
                if (cachedId != null) {
                    Logger.i("ViewedMe: Resolved hidden profile! Hash: ${hash.take(8)}... -> ID: $cachedId")

                    // INJECT THE ID!
                    // This tricks the Profile object into thinking it has the ID,
                    // allowing the UI (and your tracker) to treat it as a full profile.
                    callMethod(profile, "setProfileId", cachedId)
                }
            }
        }

        // -------------------------------------------------------------------------
        // 2. UNCAP DISPLAY LIMITS
        // -------------------------------------------------------------------------

        try {
            // The JSON has "viewedCount": { "maxDisplayCount": 3 }
            // We intercept this setter and force it to 99999.
            findClass(profileClass).hook("setViewedCountMax", HookStage.BEFORE) { param ->
                // param.args() returns the arguments array. We modify the first argument.
                param.args()[0] = 99999
            }
        } catch (e: Throwable) {
            Logger.e("Could not hook setViewedCountMax directly: ${e.message}")
        }

        // -------------------------------------------------------------------------
        // 3. LOGGING FOR DEBUG
        // -------------------------------------------------------------------------
        findClass(profileClass).hook("setLastViewed", HookStage.AFTER) { param ->
            val profile = param.thisObject()
            val time = param.arg<Long>(0) // Safe cast using helper

            if (time > 0) {
                val id = callMethod(profile, "getProfileId")
                val hash = callMethod(profile, "getProfileImageMediaHash")

                if (id != null) {
                    Logger.i("ViewedMe Entry: ID=$id Hash=${hash?.toString()?.take(8)}")
                } else {
                    Logger.w("ViewedMe Hidden Entry: Hash=${hash?.toString()?.take(8)} (Not in cache yet)")
                }
            }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\WebSocketAlive.kt --- 
package com.grindrplus.hooks

import android.app.Activity
import android.os.Handler
import android.os.Looper
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookAdapter
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod

class WebSocketAlive : Hook(
    "Background WebSocket Keep Alive",
    "Prevents WebSocket disconnections when app goes to background. Causes battery drain, use with caution."
) {
    private val safeDkLifecycleManager = "com.safedk.android.internal.b"
    private val webSocketClientImpl = "com.grindrapp.android.network.websocket.WebSocketClientImpl"
    private val webSocketFactory = "Aa.p"

    override fun init() {
        hookSafeDkBackgroundDetection()
        hookWebSocketLifecycle()
        hookWebSocketFactory()
    }

    private fun hookSafeDkBackgroundDetection() {
        try {
            findClass(safeDkLifecycleManager).hook("isInBackground", HookStage.BEFORE) { param ->
                logd("Spoofing SafeDK background detection")
                param.setResult(false)
            }

            findClass(safeDkLifecycleManager).hook("a", HookStage.BEFORE) { param ->
                if (param.args().isNotEmpty()) {
                    val isBackground = param.arg<Boolean>(0)
                    if (isBackground) {
                        logd("Preventing SafeDK from setting background state")
                        param.setResult(null)
                    }
                }
            }

            findClass(safeDkLifecycleManager).hook("b", HookStage.BEFORE) { param ->
                logd("Preventing SafeDK background identification")
                param.setResult(null)
            }

            findClass(safeDkLifecycleManager).hook("onActivityStopped", HookStage.BEFORE) { param ->
                logd("Intercepting SafeDK onActivityStopped")
                handleActivityStopped(param as HookAdapter<Any>)
                param.setResult(null)
            }

            findClass(safeDkLifecycleManager).hook("registerBackgroundForegroundListener", HookStage.AFTER) { param ->
                val listener = param.arg<Any>(0)
                try {
                    callMethod(listener, "h")
                } catch (e: Exception) {
                    // that's fine, we just want to ensure the listener is registered
                }
            }
        } catch (e: Exception) {
            loge("Failed to hook SafeDK background detection: $e")
        }
    }

    private fun hookWebSocketLifecycle() {
        try {
            findClass(webSocketClientImpl).hook("disconnect", HookStage.BEFORE) { param ->
                if (isBackgroundTriggeredDisconnect()) {
                    logd("Preventing background-triggered WebSocket disconnect")
                    param.setResult(null)
                }
            }

            findClass(webSocketClientImpl).hook("d", HookStage.BEFORE) { param ->
                val code = param.arg<Int>(0)
                val reason = param.arg<String>(1)

                if (isBackgroundRelatedDisconnect(code, reason)) {
                    logd("Blocking background-related WebSocket disconnect: $reason")
                    param.setResult(null)
                }
            }

            findClass(webSocketClientImpl).hook("onClosed", HookStage.AFTER) { param ->
                val code = param.arg<Int>(1)
                val reason = param.arg<String>(2)

                if (shouldAutoReconnect(code, reason)) {
                    logd("Scheduling WebSocket auto-reconnect")
                    scheduleReconnection(param.thisObject(), 2000)
                }
            }

            findClass(webSocketClientImpl).hook("onFailure", HookStage.AFTER) { param ->
                val throwable = param.arg<Throwable>(1)
                val message = throwable.message?.lowercase() ?: ""

                if (isNetworkRelatedFailure(message)) {
                    logd("Scheduling WebSocket auto-reconnect after network failure")
                    scheduleReconnection(param.thisObject(), 5000)
                }
            }

            logi("Successfully hooked WebSocket lifecycle methods")

        } catch (e: Exception) {
            loge("Failed to hook WebSocket lifecycle: $e")
        }
    }

    private fun hookWebSocketFactory() {
        try {
            findClass(webSocketFactory).hook("a", HookStage.AFTER) { param ->
                val webSocketUrl = param.arg<String>(0)
                logd("WebSocket connection created to: $webSocketUrl")
            }
        } catch (e: Exception) {
            loge("Failed to hook WebSocket factory: $e")
        }
    }

    private fun handleActivityStopped(param: HookAdapter<Any>) {
        try {
            val thisObject = param.thisObject()
            val activity = param.arg<Activity>(0)

            val isBackgroundBefore = callMethod(thisObject, "isInBackground") as Boolean

            val backgroundField = thisObject.javaClass.getDeclaredField("g")
            backgroundField.isAccessible = true
            val isBackgroundAfter = backgroundField.getBoolean(thisObject)

            if (!isBackgroundBefore && isBackgroundAfter) {
                logd("Reverting background state change from SafeDK")
                backgroundField.setBoolean(thisObject, false)
            }

        } catch (e: Exception) {
            loge("Error in SafeDK onActivityStopped hook: $e")
        }
    }

    private fun isBackgroundTriggeredDisconnect(): Boolean {
        val stackTrace = Thread.currentThread().stackTrace
        return stackTrace.any {
            it.methodName.contains("background", ignoreCase = true) ||
                    it.methodName.contains("pause", ignoreCase = true) ||
                    it.className.contains("lifecycle", ignoreCase = true) ||
                    it.className.contains("safedk", ignoreCase = true)
        }
    }

    private fun isBackgroundRelatedDisconnect(code: Int, reason: String): Boolean {
        return reason.contains("background", ignoreCase = true) ||
                reason.contains("inactive", ignoreCase = true) ||
                reason.contains("idle", ignoreCase = true) ||
                code == 1001
    }

    private fun shouldAutoReconnect(code: Int, reason: String): Boolean {
        return code == 1001 ||
                reason.contains("background", ignoreCase = true) ||
                reason.contains("inactive", ignoreCase = true)
    }

    private fun isNetworkRelatedFailure(message: String): Boolean {
        return message.contains("network") ||
                message.contains("timeout") ||
                message.contains("connection reset") ||
                message.contains("socket closed")
    }

    private fun scheduleReconnection(webSocketClient: Any, delayMs: Long) {
        Handler(Looper.getMainLooper()).postDelayed({
            try {
                val urlField = webSocketClient.javaClass.getDeclaredField("c")
                urlField.isAccessible = true
                val authToken = urlField.get(webSocketClient) as? String

                if (authToken != null) {
                    callMethod(webSocketClient, "b", authToken)
                    logi("WebSocket reconnection initiated")
                } else {
                    logd("Cannot reconnect WebSocket - no auth token found")
                }
            } catch (e: Exception) {
                loge("Failed to auto-reconnect WebSocket: $e")
            }
        }, delayMs)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\xUnlimitedAlbums.kt --- 
/*
package com.grindrplus.hooks

import android.widget.Toast
import androidx.room.withTransaction
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.core.logd
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.core.logw
import com.grindrplus.persistence.mappers.asAlbumBriefToAlbumEntity
import com.grindrplus.persistence.mappers.asAlbumToAlbumEntity
import com.grindrplus.persistence.mappers.toAlbumContentEntity
import com.grindrplus.persistence.mappers.toGrindrAlbum
import com.grindrplus.persistence.mappers.toGrindrAlbumBrief
import com.grindrplus.persistence.mappers.toGrindrAlbumContent
import com.grindrplus.persistence.mappers.toGrindrAlbumWithoutContent
import com.grindrplus.persistence.model.AlbumContentEntity
import com.grindrplus.persistence.model.AlbumEntity
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.RetrofitUtils
import com.grindrplus.utils.RetrofitUtils.createSuccess
import com.grindrplus.utils.RetrofitUtils.getSuccessValue
import com.grindrplus.utils.RetrofitUtils.isFail
import com.grindrplus.utils.RetrofitUtils.isGET
import com.grindrplus.utils.RetrofitUtils.isPUT
import com.grindrplus.utils.RetrofitUtils.isSuccess
import com.grindrplus.utils.hook
import com.grindrplus.utils.hookConstructor
import com.grindrplus.utils.withSuspendResult
import de.robv.android.xposed.XposedHelpers.getObjectField
import de.robv.android.xposed.XposedHelpers.setObjectField
import java.io.Closeable
import java.io.IOException
import kotlinx.coroutines.runBlocking
import org.json.JSONObject

class UnlimitedAlbums : Hook("Unlimited albums", "Allow to be able to view unlimited albums") {
    //private val albumsService = "y5.a" // search for 'v1/albums/red-dot'
    private val albumsService = "T4.a" // search for 'v1/albums/red-dot'
    private val albumModel = "com.grindrapp.android.model.Album"
    private val filteredSpankBankAlbumContent =
        "com.grindrapp.android.albums.spankbank.domain.model.FilteredSpankBankAlbumContent"
    private val spankBankAlbumModel =
        "com.grindrapp.android.albums.spankbank.domain.model.SpankBankAlbum"
    private val spankBankAlbumContentModel =
        "com.grindrapp.android.albums.spankbank.domain.model.SpankBankAlbumContent"
    private val httpExceptionResponse = "com.grindrapp.android.network.http.HttpExceptionResponse"
    private val sharedAlbumsBrief = "com.grindrapp.android.model.albums.SharedAlbumsBrief"
    private val albumsList = "com.grindrapp.android.model.AlbumsList"

    override fun init() {
        val albumsServiceClass = findClass(albumsService)

        RetrofitUtils.hookService(
            albumsServiceClass,
        ) { originalHandler, proxy, method, args ->
            val result = originalHandler.invoke(proxy, method, args)
            try {
                when {
                    method.isGET("v2/albums/{albumId}") -> handleGetAlbum(args, result)
                    method.isGET("v1/albums") -> handleGetAlbums(args, result)
                    method.isGET("v2/albums/shares") -> handleGetAlbumsShares(args, result)
                    method.isGET("v2/albums/shares/{profileId}") ->
                        handleGetAlbumsSharesProfileId(args, result)
                    method.isGET("v3/albums/{albumId}/view") ->
                        handleGetAlbumsViewAlbumId(args, result)
                    method.isPUT("v1/albums/{albumId}/shares/remove") ->
                        handleRemoveAlbumShares(args, result)
                    else -> result
                }
            } catch (e: Exception) {
                loge("Error handling album request: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }

        findClass(albumModel).hookConstructor(HookStage.AFTER) { param ->
            try {
                setObjectField(param.thisObject(), "albumViewable", true)
                setObjectField(param.thisObject(), "viewableUntil", Long.MAX_VALUE)
            } catch (e: Exception) {
                loge("Error making album viewable: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        findClass(spankBankAlbumModel).hookConstructor(HookStage.AFTER) { param ->
            try {
                setObjectField(param.thisObject(), "albumViewable", true)
                setObjectField(param.thisObject(), "expiresAt", Long.MAX_VALUE)
            } catch (e: Exception) {
                loge("Error making album viewable: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
            }
        }

        listOf(spankBankAlbumContentModel, filteredSpankBankAlbumContent).forEach { clazz ->
            findClass(clazz).hookConstructor(HookStage.AFTER) { param ->
                try {
                    setObjectField(param.thisObject(), "albumViewable", true)
                } catch (e: Exception) {
                    loge("Error making album viewable: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        }

        findClass(albumModel).hook("isValid", HookStage.BEFORE) { param -> param.setResult(true) }

    }

    @Suppress("UNCHECKED_CAST")
    private suspend fun saveAlbum(grindrAlbum: Any) {
        try {
            val dao = GrindrPlus.database.albumDao()

            val dbAlbum = grindrAlbum.asAlbumToAlbumEntity()
            dao.upsertAlbum(dbAlbum)

            val grindrAlbumContent = getObjectField(grindrAlbum, "content") as? List<Any> ?: return
            grindrAlbumContent.forEach {
                try {
                    val dbAlbumContent = it.toAlbumContentEntity(dbAlbum.id)
                    dao.upsertAlbumContent(dbAlbumContent)
                } catch (e: Exception) {
                    loge("Failed to convert album content: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        } catch (e: Exception) {
            loge("Failed to save album: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }

    private suspend fun saveAlbumContent(albumId: Long, contentEntities: List<AlbumContentEntity>) {
        try {
            val dao = GrindrPlus.database.albumDao()

            val albumExists = dao.albumExists(albumId)

            if (albumExists) {
                contentEntities.forEach { content -> dao.upsertAlbumContent(content) }
            } else {
                logw("Album $albumId doesn't exist, creating placeholder")
                val currentTime = System.currentTimeMillis().toString()
                val placeholderAlbum =
                    AlbumEntity(
                        id = albumId,
                        albumName = "Unknown Album",
                        createdAt = currentTime,
                        profileId = 0L,
                        updatedAt = currentTime
                    )
                dao.upsertAlbum(placeholderAlbum)

                contentEntities.forEach { content -> dao.upsertAlbumContent(content) }
            }
        } catch (e: Exception) {
            loge("Failed to save album content: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }

    private fun handleRemoveAlbumShares(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logi("Removing album shares for ID: $albumId")

            if (result.isFail()) {
                try {
                    runBlocking {
                        GrindrPlus.database.withTransaction {
                            val dao = GrindrPlus.database.albumDao()
                            val albumToDelete = dao.getAlbum(albumId)

                            if (albumToDelete != null) {
                                dao.deleteAlbum(albumId)
                                createSuccess(albumId)
                            } else {
                                logd("Album with ID $albumId not found in the database")
                                result
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Failed to delete album $albumId: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                    result
                }
            } else {
                result
            }
        }

    private fun handleGetAlbumsViewAlbumId(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logd("Checking if album $albumId is viewable")

            if (!result.isSuccess()) {
                logw("Album $albumId is not viewable, checking database")
                runBlocking {
                    val dao = GrindrPlus.database.albumDao()
                    val album = dao.getAlbum(albumId)
                    if (album != null) {
                        logd("Album $albumId is viewable, returning success")
                        createSuccess(true)
                    } else {
                        logd("Album $albumId is not viewable, returning failure")
                        result
                    }
                }
            }

            result
        }

    private fun handleGetAlbum(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            val albumId = args[0] as? Long ?: return@withSuspendResult result
            logd("Fetching album with ID: $albumId")

            try {
                GrindrPlus.httpClient
                    .sendRequest(url = "https://grindr.mobi/v1/albums/$albumId", method = "GET")
                    .use { response ->
                        val responseBody = response.body?.string()
                        if (!responseBody.isNullOrEmpty()) {
                            logd("Got ${responseBody.length} bytes for album $albumId")
                            val modifiedResult = parseAlbumContent(albumId, responseBody, result)
                            return@withSuspendResult modifiedResult
                        } else {
                            loge("Empty response body for album $albumId")
                            val modifiedResult = fetchAlbumFromDatabase(albumId, result)
                            return@withSuspendResult modifiedResult
                        }
                    }
            } catch (e: Exception) {
                loge("Failed to fetch album $albumId: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                GrindrPlus.showToast(Toast.LENGTH_LONG, "Failed to load album")
                val modifiedResult = fetchAlbumFromDatabase(albumId, result)
                return@withSuspendResult modifiedResult
            }
        }

    private fun fetchAlbumFromDatabase(albumId: Long, originalResult: Any): Any {
        try {
            loge("Fetching album with ID: $albumId from database")
            return runBlocking {
                val dao = GrindrPlus.database.albumDao()
                val album = dao.getAlbum(albumId)
                if (album != null) {
                    val content = dao.getAlbumContent(albumId)
                    var albumObject = getObjectField(originalResult, "a")

                    if (
                        albumObject != null && albumObject.javaClass.name == httpExceptionResponse
                    ) {
                        logw(
                            "Album object is HttpExceptionResponse, creating new Album from entity"
                        )
                        albumObject = album.toGrindrAlbumWithoutContent()
                    }

                    if (albumObject != null) {
                        setObjectField(albumObject, "albumId", albumId)
                        setObjectField(
                            albumObject,
                            "content",
                            content.map { it.toGrindrAlbumContent() }
                        )
                        setObjectField(albumObject, "albumViewable", true)
                        setObjectField(albumObject, "viewableUntil", Long.MAX_VALUE)
                        createSuccess(albumObject)
                    } else {
                        loge("Album is null, cannot set content")
                        originalResult
                    }
                } else {
                    logw("Album $albumId not found in database")
                    originalResult
                }
            }
        } catch (e: Exception) {
            loge("Failed to load album $albumId from database: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            return originalResult
        }
    }

    private fun parseAlbumContent(albumId: Long, responseBody: String, originalResult: Any): Any {
        try {
            logd("Parsing album content for ID: $albumId")
            val jsonResponse = JSONObject(responseBody)
            jsonResponse.optJSONArray("content")?.let { contentArray ->
                logd("Content array found for album ID: $albumId")
                val albumContentEntities = mutableListOf<AlbumContentEntity>()

                for (i in 0 until contentArray.length()) {
                    try {
                        val contentJson = contentArray.getJSONObject(i)
                        val albumContentEntity =
                            AlbumContentEntity(
                                id = contentJson.optLong("contentId"),
                                albumId = albumId,
                                contentType = contentJson.optString("contentType"),
                                coverUrl = contentJson.optString("coverUrl"),
                                thumbUrl = contentJson.optString("thumbUrl"),
                                url = contentJson.optString("url")
                            )
                        albumContentEntities.add(albumContentEntity)
                    } catch (e: Exception) {
                        loge("Error parsing content item: ${e.message}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }

                if (albumContentEntities.isNotEmpty()) {
                    logd("Saving album content for ID: $albumId")
                    try {
                        runBlocking { saveAlbumContent(albumId, albumContentEntities) }
                    } catch (e: Exception) {
                        loge("Failed to save album content: ${e.message}")
                        Logger.writeRaw(e.stackTraceToString())
                    }
                }

                try {
                    val grindrAlbumContentList =
                        albumContentEntities.map { it.toGrindrAlbumContent() }
                    val albumObject = getObjectField(originalResult, "a")
                    if (albumObject != null) {
                        logd("Setting album content for ID: $albumId")
                        setObjectField(albumObject, "content", grindrAlbumContentList)
                        return originalResult
                    } else {
                        loge("Album object not found in result for album ID: $albumId")
                    }
                } catch (e: Exception) {
                    loge("Error setting album content: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
                ?: run {
                    loge("Failed to parse content array for album ID: $albumId")
                    return fetchAlbumFromDatabase(albumId, originalResult)
                }
        } catch (e: Exception) {
            loge("Error parsing album content: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
            return fetchAlbumFromDatabase(albumId, originalResult)
        }

        return originalResult
    }

    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbums(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            if (result.isSuccess()) {
                try {
                    val albums = getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                    if (albums != null) {
                        runBlocking {
                            GrindrPlus.database.withTransaction {
                                albums.forEach { album ->
                                    try {
                                        saveAlbum(album)
                                    } catch (e: Exception) {
                                        loge("Error saving album: ${e.message}")
                                        Logger.writeRaw(e.stackTraceToString())
                                    }
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error processing albums: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }

            try {
                val albums = runBlocking {
                    GrindrPlus.database.withTransaction {
                        val dao = GrindrPlus.database.albumDao()
                        val dbAlbums = dao.getAlbums()
                        dbAlbums.mapNotNull {
                            try {
                                val dbContent = dao.getAlbumContent(it.id)
                                it.toGrindrAlbum(dbContent)
                            } catch (e: Exception) {
                                loge("Error converting album ${it.id}: ${e.message}")
                                Logger.writeRaw(e.stackTraceToString())
                                null
                            }
                        }
                    }
                }

                val newValue =
                    findClass(albumsList)
                        .getConstructor(List::class.java)
                        .newInstance(albums)

                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating albums list: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }

    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbumsShares(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            logd("Fetching shared albums")
            if (result.isSuccess()) {
                try {
                    runBlocking {
                        GrindrPlus.database.withTransaction {
                            val dao = GrindrPlus.database.albumDao()
                            val albumBriefs =
                                getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                            albumBriefs?.forEach { albumBrief ->
                                try {
                                    val albumEntity = albumBrief.asAlbumBriefToAlbumEntity()
                                    dao.upsertAlbum(albumEntity)

                                    val grindrAlbumContent = getObjectField(albumBrief, "content")
                                    if (grindrAlbumContent != null) {
                                        val dbAlbumContent =
                                            grindrAlbumContent.toAlbumContentEntity(albumEntity.id)
                                        dao.upsertAlbumContent(dbAlbumContent)
                                    }
                                } catch (e: Exception) {
                                    loge("Error processing album brief: ${e.message}")
                                    Logger.writeRaw(e.stackTraceToString())
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error saving album briefs: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }

            try {
                val albumBriefs = runBlocking {
                    GrindrPlus.database.withTransaction {
                        val dao = GrindrPlus.database.albumDao()
                        val dbAlbums = dao.getAlbums()
                        dbAlbums.mapNotNull {
                            try {
                                val dbContent = dao.getAlbumContent(it.id)
                                if (dbContent.isNotEmpty()) {
                                    it.toGrindrAlbumBrief(dbContent.first())
                                } else {
                                    logw("Album ${it.id} has no content")
                                    null
                                }
                            } catch (e: Exception) {
                                loge("Error converting album ${it.id} to brief: ${e.message}")
                                Logger.writeRaw(e.stackTraceToString())
                                null
                            }
                        }
                    }
                }

                val newValue =
                    findClass(sharedAlbumsBrief)
                        .getConstructor(List::class.java)
                        .newInstance(albumBriefs)

                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating shared albums brief: ${e.message}")
                Logger.writeRaw(e.stackTraceToString())
                result
            }
        }

    @Suppress("UNCHECKED_CAST")
    private fun handleGetAlbumsSharesProfileId(args: Array<Any?>, result: Any) =
        withSuspendResult(args, result) { args, result ->
            logd("Fetching shared albums for profile ID")
            val profileId = args[0] as? Long ?: return@withSuspendResult result

            if (result.isSuccess()) {
                try {
                    runBlocking {
                        GrindrPlus.database.withTransaction {
                            val dao = GrindrPlus.database.albumDao()
                            val albumBriefs =
                                getObjectField(result.getSuccessValue(), "albums") as? List<Any>
                            albumBriefs?.forEach { albumBrief ->
                                try {
                                    val albumEntity = albumBrief.asAlbumBriefToAlbumEntity()
                                    dao.upsertAlbum(albumEntity)

                                    val grindrAlbumContent = getObjectField(albumBrief, "content")
                                    if (grindrAlbumContent != null) {
                                        val dbAlbumContent =
                                            grindrAlbumContent.toAlbumContentEntity(albumEntity.id)
                                        dao.upsertAlbumContent(dbAlbumContent)
                                    }
                                } catch (e: Exception) {
                                    loge("Error processing album brief: ${e.message}")
                                    Logger.writeRaw(e.stackTraceToString())
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    loge("Error saving album briefs: ${e.message}")
                    Logger.writeRaw(e.stackTraceToString())
                }
            }

            try {
                val albumBriefs = runBlocking {
                    GrindrPlus.database.withTransaction {
                        val dao = GrindrPlus.database.albumDao()
                        val dbAlbums = dao.getAlbums(profileId)
                        dbAlbums.mapNotNull {
                            try {
                                val dbContent = dao.getAlbumContent(it.id)
                                if (dbContent.isNotEmpty()) {
                                    it.toGrindrAlbumBrief(dbContent.first())
                                } else {
                                    logw("Album ${it.id} has no content")
                                    null
                                }
                            } catch (e: Exception) {
                                loge("Error converting album ${it.id} to brief: ${e.message}")
                                Logger.writeRaw(e.stackTraceToString())
                                null
                            }
                        }
                    }
                }

                val newValue =
                    findClass(sharedAlbumsBrief)
                        .getConstructor(List::class.java)
                        .newInstance(albumBriefs)

                createSuccess(newValue)
            } catch (e: Exception) {
                loge("Error creating shared albums brief: ${e.message}")
                result
            }
        }

    private inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {
        var closed = false
        try {
            return block(this)
        } catch (e: Exception) {
            closed = true
            try {
                this?.close()
            } catch (closeException: IOException) {
                e.addSuppressed(closeException)
            }
            throw e
        } finally {
            if (!closed) {
                this?.close()
            }
        }
    }
}
*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\hooks\xUnlimitedProfiles.kt --- 
/*
package com.grindrplus.hooks

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Utils.openProfile
import com.grindrplus.core.Logger
import com.grindrplus.core.loge
import com.grindrplus.utils.Hook
import com.grindrplus.utils.HookStage
import com.grindrplus.utils.hook
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.callStaticMethod
import de.robv.android.xposed.XposedHelpers.getObjectField
import java.lang.reflect.Proxy

class UnlimitedProfiles : Hook(
    "Unlimited profiles",
    "Allow unlimited profiles"
) {
    private val function2 = "kotlin.jvm.functions.Function2"
    private val onProfileClicked = "com.grindrapp.android.ui.browse.w" // search for 'com.grindrapp.android.ui.browse.ServerDrivenCascadeViewModel$onProfileClicked$1'
    private val profileWithPhoto = "com.grindrapp.android.persistence.pojo.ProfileWithPhoto"
    private val serverDrivenCascadeCachedState =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCacheState"
    private val serverDrivenCascadeCachedProfile =
        "com.grindrapp.android.persistence.model.serverdrivencascade.ServerDrivenCascadeCachedProfile"
    private val profileTagCascadeFragment = "com.grindrapp.android.ui.tagsearch.ProfileTagCascadeFragment"

    override fun init() {
        findClass(serverDrivenCascadeCachedState)
            .hook("getItems", HookStage.AFTER) { param ->
                val items = (param.getResult() as List<*>).filter {
                    it?.javaClass?.name == serverDrivenCascadeCachedProfile
                }

                param.setResult(items)
            }

        findClass(profileTagCascadeFragment) // search for 'new StringBuilder("cascadeClickEvent/position=");'
            .hook("R", HookStage.BEFORE) { param ->
                param.setResult(true)
            }

        findClass(serverDrivenCascadeCachedProfile)
            .hook("getUpsellType", HookStage.BEFORE) { param ->
                param.setResult(null)
            }

        val profileClass = findClass("com.grindrapp.android.persistence.model.Profile")
        val profileWithPhotoClass = findClass(profileWithPhoto)
        val function2Class = findClass(function2)
        val flowKtClass = findClass("kotlinx.coroutines.flow.FlowKt")
        val profileRepoClass = findClass("com.grindrapp.android.persistence.repository.ProfileRepo")

        profileRepoClass.hook("getProfilesWithPhotosFlow", HookStage.AFTER) { param ->
            val requestedProfileIds = param.arg<List<String>>(0)
            if (requestedProfileIds.isEmpty()) return@hook

            val originalFlow = param.getResult()
            val profileWithPhotoConstructor = profileWithPhotoClass
                .getConstructor(profileClass, List::class.java)
            val profileConstructor = profileClass.getConstructor()

            val proxy = Proxy.newProxyInstance(
                GrindrPlus.classLoader,
                arrayOf(function2Class)
            ) { _, _, args ->
                @Suppress("UNCHECKED_CAST")
                val profilesWithPhoto = args[0] as List<Any>

                if (requestedProfileIds.size > profilesWithPhoto.size) {
                    val profileIds = ArrayList<String>(profilesWithPhoto.size)

                    for (profileWithPhoto in profilesWithPhoto) {
                        val profile = callMethod(profileWithPhoto, "getProfile")
                        profileIds.add(callMethod(profile, "getProfileId") as String)
                    }

                    val profileIdSet = profileIds.toHashSet()

                    val missingProfiles = ArrayList<Any>()
                    for (profileId in requestedProfileIds) {
                        if (profileId !in profileIdSet) {
                            val profile = profileConstructor.newInstance()
                            callMethod(profile, "setProfileId", profileId)
                            callMethod(profile, "setRemoteUpdatedTime", 1L)
                            callMethod(profile, "setLocalUpdatedTime", 0L)
                            missingProfiles.add(
                                profileWithPhotoConstructor.newInstance(profile, emptyList<Any>())
                            )
                        }
                    }

                    if (missingProfiles.isNotEmpty()) {
                        val result = ArrayList<Any>(profilesWithPhoto.size + missingProfiles.size)
                        result.addAll(profilesWithPhoto)
                        result.addAll(missingProfiles)
                        return@newProxyInstance result
                    }
                }

                profilesWithPhoto
            }

            val transformedFlow = callStaticMethod(flowKtClass, "mapLatest", originalFlow, proxy)
            param.setResult(transformedFlow)
        }

        findClass(onProfileClicked).hook("invokeSuspend", HookStage.BEFORE) { param ->
            if (Config.get("disable_profile_swipe", false) as Boolean) {
                getObjectField(param.thisObject(), param.thisObject().javaClass.declaredFields
                    .firstOrNull { it.type.name.contains("ServerDrivenCascadeCachedProfile") }?.name
                )?.let { cachedProfile ->
                    runCatching { getObjectField(cachedProfile, "profileIdLong").toString() }
                        .onSuccess { profileId ->
                            openProfile(profileId)
                            param.setResult(null)
                        }
                        .onFailure { loge("Profile ID not found in cached profile") }
                }
            }
        }
    }
}*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\GPDatabase.kt --- 
package com.grindrplus.persistence

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.sqlite.db.SupportSQLiteDatabase
import com.grindrplus.persistence.converters.DateConverter
import com.grindrplus.persistence.dao.AlbumDao
import com.grindrplus.persistence.dao.ProfilePhotoDao
import com.grindrplus.persistence.dao.SavedPhraseDao
import com.grindrplus.persistence.dao.TeleportLocationDao
import com.grindrplus.persistence.model.AlbumContentEntity
import com.grindrplus.persistence.model.AlbumEntity
import com.grindrplus.persistence.model.SavedPhraseEntity
import com.grindrplus.persistence.model.TeleportLocationEntity
import android.database.sqlite.SQLiteDatabase
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import com.grindrplus.persistence.dao.LogDao
import com.grindrplus.persistence.dao.ProfileDao
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import com.grindrplus.persistence.dao.ProfileViewDao // <-- NEW IMPORT
import com.grindrplus.persistence.model.LogEntity
import com.grindrplus.persistence.model.ProfileEntity
import com.grindrplus.persistence.model.ProfilePhotoEntity
import com.grindrplus.persistence.model.ProfileViewEntity // <-- NEW IMPORT

@Database(
    entities = [
        AlbumEntity::class,
        AlbumContentEntity::class,
        TeleportLocationEntity::class,
        SavedPhraseEntity::class,
        ProfileViewEntity::class,
        ProfilePhotoEntity::class,
        ProfileEntity::class,
        LogEntity::class
    ],
    version = 7, // <-- INCREMENTED VERSION
    exportSchema = false
)

@TypeConverters(DateConverter::class)
abstract class GPDatabase : RoomDatabase() {
    abstract fun albumDao(): AlbumDao
    abstract fun teleportLocationDao(): TeleportLocationDao
    abstract fun savedPhraseDao(): SavedPhraseDao

    abstract fun profileViewDao(): ProfileViewDao

    abstract fun profileDao(): ProfileDao

    abstract fun profilePhotoDao(): ProfilePhotoDao

    abstract fun logDao(): LogDao

    object DatabaseManager {
        private val readyLatch = java.util.concurrent.CountDownLatch(1)

        fun markReady() {
            readyLatch.countDown()
        }

        fun executeWhenReady(block: () -> Unit) {
            // Spawn a new thread to wait, so we don't block the calling thread (e.g., UI thread)
            Thread {
                try {
                    readyLatch.await(5, java.util.concurrent.TimeUnit.SECONDS) // Wait up to 5 seconds
                    block()
                } catch (e: InterruptedException) {
                    Thread.currentThread().interrupt()
                    Logger.e("DatabaseManager was interrupted while waiting.", LogSource.DB)
                }
            }.start()
        }
    }

    companion object {
        private const val DATABASE_NAME = "grindrplus.db"

        fun create(context: Context): GPDatabase {
            return Room.databaseBuilder(context, GPDatabase::class.java, DATABASE_NAME)
                .fallbackToDestructiveMigration(false)
                .setJournalMode(JournalMode.WRITE_AHEAD_LOGGING)
                .build()
        }

        @Volatile
        private var INSTANCE: GPDatabase? = null

        fun getInstance(context: Context): GPDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    GPDatabase::class.java,
                    DATABASE_NAME
                )
                    .fallbackToDestructiveMigration(false)
                    .setJournalMode(JournalMode.WRITE_AHEAD_LOGGING)
                    .build()

                INSTANCE = instance
                DatabaseManager.markReady()
                instance
            }
        }

        suspend fun prePopulate(context: Context) {
            val dao = getInstance(context).teleportLocationDao()
            prepopulateLocations(dao)
        }

        private class PrepopulateCallback(private val context: Context) : RoomDatabase.Callback() {
            override fun onCreate(db: SupportSQLiteDatabase) {
                super.onCreate(db)
                // This logic is now handled manually via the prePopulate() function
            }

        }

        private suspend fun prepopulateLocations(dao: TeleportLocationDao) {
            val customLocationsJson =
                com.grindrplus.core.Config.get("prepopulation_locations", "") as String
            val locationsToPrepopulate = mutableListOf<TeleportLocationEntity>()

            if (customLocationsJson.isNotEmpty()) {
                try {
                    val jsonArray = org.json.JSONArray(customLocationsJson)
                    for (i in 0 until jsonArray.length()) {
                        val jsonObj = jsonArray.getJSONObject(i)
                        val name = jsonObj.optString("name")
                        val latStr = jsonObj.optString("lat")
                        val lonStr = jsonObj.optString("lon")
                        if (name.isNotBlank() && latStr.isNotBlank() && lonStr.isNotBlank()) {
                            val lat = latStr.toDoubleOrNull()
                            val lon = lonStr.toDoubleOrNull()
                            if (lat != null && lon != null) {
                                locationsToPrepopulate.add(TeleportLocationEntity(name, lat, lon))
                            }
                        }
                    }
                } catch (e: org.json.JSONException) {
                    // Invalid JSON, fall back to default
                    locationsToPrepopulate.clear()
                }
            }

            if (locationsToPrepopulate.isEmpty()) {
                locationsToPrepopulate.addAll(
                    listOf(
                        TeleportLocationEntity("SaranJai", 13.7387, 100.5544),
                        TeleportLocationEntity("VT5D", 12.9030, 100.8671),
                        TeleportLocationEntity("ICONSIAM", 13.7270, 100.5101),
                        TeleportLocationEntity("ThongLo", 13.7243, 100.5784),
                        TeleportLocationEntity("Sydney", -33.8688, 151.2093)
                    )
                )
            }

            locationsToPrepopulate.forEach { dao.addLocation(it) }
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\converters\DateConverter.kt --- 
package com.grindrplus.persistence.converters

import androidx.room.TypeConverter
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.TimeZone

class DateConverter {
    companion object {
        private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US).apply {
            timeZone = TimeZone.getTimeZone("UTC")
        }
    }

    @TypeConverter
    fun fromTimestamp(value: String?): Date? {
        return value?.let {
            try {
                dateFormat.parse(it)
            } catch (e: Exception) {
                null
            }
        }
    }

    @TypeConverter
    fun dateToTimestamp(date: Date?): String? {
        return date?.let { dateFormat.format(it) }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\AlbumDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Transaction
import androidx.room.Upsert
import com.grindrplus.persistence.model.AlbumContentEntity
import com.grindrplus.persistence.model.AlbumEntity

@Dao
interface AlbumDao {

    /**
     * Gets all albums from the database
     * @return List of all albums
     */
    @Query("SELECT * FROM AlbumEntity ORDER BY updatedAt DESC")
    suspend fun getAlbums(): List<AlbumEntity>

    /**
     * Gets all albums for a specific profile
     * @param profileId The profile ID to filter by
     * @return List of albums belonging to the specified profile
     */
    @Query("SELECT * FROM AlbumEntity WHERE profileId = :profileId ORDER BY updatedAt DESC")
    suspend fun getAlbums(profileId: Long): List<AlbumEntity>

    /**
     * Gets a single album by ID
     * @param id The album ID
     * @return The album entity or null if not found
     */
    @Query("SELECT * FROM AlbumEntity WHERE id = :id")
    suspend fun getAlbum(id: Long): AlbumEntity?

    /**
     * Upserts (insert or update) an album
     * @param album The album entity to upsert
     */
    @Upsert
    suspend fun upsertAlbum(album: AlbumEntity)

    /**
     * Batch upsert for multiple albums
     * @param albums The list of album entities to upsert
     */
    @Upsert
    suspend fun upsertAlbums(albums: List<AlbumEntity>)

    /**
     * Inserts an album from album brief information, ignoring conflicts
     * @param albumEntity The album entity to insert
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertAlbumFromAlbumBrief(albumEntity: AlbumEntity)

    /**
     * Gets all album content for a specific album
     * @param albumId The album ID
     * @return List of album content entities
     */
    @Query("SELECT * FROM AlbumContentEntity WHERE albumId = :albumId")
    suspend fun getAlbumContent(albumId: Long): List<AlbumContentEntity>

    /**
     * Upserts an album content entity
     * @param dbAlbumContent The album content entity to upsert
     */
    @Upsert
    suspend fun upsertAlbumContent(dbAlbumContent: AlbumContentEntity)

    /**
     * Batch upsert for multiple album content entities
     * @param contents The list of album content entities to upsert
     */
    @Upsert
    suspend fun upsertAlbumContents(contents: List<AlbumContentEntity>)

    /**
     * Deletes an album and its contents
     * @param id The album ID to delete
     */
    @Query("DELETE FROM AlbumEntity WHERE id = :id")
    suspend fun deleteAlbum(id: Long)

    /**
     * Checks if an album exists
     * @param id The album ID to check
     * @return True if the album exists, false otherwise
     */
    @Query("SELECT EXISTS(SELECT 1 FROM AlbumEntity WHERE id = :id)")
    suspend fun albumExists(id: Long): Boolean

    /**
     * Deletes all albums and their content for a profile
     * @param profileId The profile ID
     */
    @Query("DELETE FROM AlbumEntity WHERE profileId = :profileId")
    suspend fun deleteProfileAlbums(profileId: Long)

    /**
     * Complete transaction to save an album and its content in one atomic operation
     * @param album The album entity
     * @param contents The list of album content entities
     */
    @Transaction
    suspend fun saveAlbumWithContent(album: AlbumEntity, contents: List<AlbumContentEntity>) {
        upsertAlbum(album)
        upsertAlbumContents(contents)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\LogDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.grindrplus.persistence.model.LogEntity

@Dao
interface LogDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(log: LogEntity)

    @Query("SELECT * FROM logs WHERE log_type = :type ORDER BY timestamp DESC LIMIT :limit")
    suspend fun getLogsByType(type: String, limit: Int = 100): List<LogEntity>

    @Query("DELETE FROM logs WHERE log_type = :type")
    suspend fun clearLogsByType(type: String)

    @Query("DELETE FROM logs")
    suspend fun clearAllLogs()

    @Query("SELECT COUNT(*) FROM logs WHERE log_type = :type")
    suspend fun getCountByType(type: String): Int
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\ProfileDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Query
import androidx.room.Upsert
import com.grindrplus.persistence.model.ProfileEntity

@Dao
interface ProfileDao {
    @Upsert
    suspend fun upsertProfile(profile: ProfileEntity)

    @Query("SELECT * FROM profiles WHERE profileId = :profileId")
    suspend fun getProfileById(profileId: String): ProfileEntity?
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\ProfilePhotoDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.grindrplus.persistence.model.ProfilePhotoEntity

@Dao
interface ProfilePhotoDao {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertAll(photos: List<ProfilePhotoEntity>)

    @Query("SELECT profileId FROM ProfilePhotoEntity WHERE mediaHash = :mediaHash LIMIT 1")
    suspend fun getProfileIdByMediaHash(mediaHash: String): String?
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\ProfileViewDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Upsert
import com.grindrplus.persistence.model.ProfileViewEntity

@Dao
interface ProfileViewDao {
    @Upsert
    suspend fun upsert(view: ProfileViewEntity)

    @Query("SELECT * FROM profile_views ORDER BY viewedAt DESC LIMIT :count")
    suspend fun getMostRecentViews(count: Int = 100): List<ProfileViewEntity>

    @Query("DELETE FROM profile_views WHERE viewedAt < :timestampLimit")
    suspend fun deleteOlderThan(timestampLimit: Long)

    @Query("SELECT * FROM profile_views WHERE profileId = :profileId")
    suspend fun getView(profileId: String): ProfileViewEntity?

    @Query("DELETE FROM profile_views")
    suspend fun clearAll()

    @Query("SELECT COUNT(*) FROM profile_views")
    suspend fun getCount(): Int

    @Query("SELECT * FROM profile_views WHERE profileId LIKE 'unresolved_%'")
    suspend fun getUnresolvedViews(): List<ProfileViewEntity>

    @androidx.room.Delete
    suspend fun delete(view: ProfileViewEntity)
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\SavedPhraseDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Upsert
import com.grindrplus.persistence.model.SavedPhraseEntity

@Dao
interface SavedPhraseDao {
    /**
     * Get all saved phrases
     * @return A list of saved phrases, ordered by frequency and timestamp
     */
    @Query("SELECT * FROM SavedPhraseEntity ORDER BY frequency DESC, timestamp DESC")
    suspend fun getPhraseList(): List<SavedPhraseEntity>

    /**
     * Get a phrase by ID
     * @param phraseId The ID of the phrase
     */
    @Query("SELECT * FROM SavedPhraseEntity WHERE phraseId = :phraseId")
    suspend fun getPhrase(phraseId: Long): SavedPhraseEntity?

    /**
     * Add a new phrase
     * @param phrase The phrase entity to add
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun addPhrase(phrase: SavedPhraseEntity): Long

    /**
     * Update an existing phrase
     * @param phrase The phrase entity to update
     */
    @Upsert
    suspend fun upsertPhrase(phrase: SavedPhraseEntity)

    /**
     * Delete a phrase
     * @param phraseId The ID of the phrase to delete
     */
    @Query("DELETE FROM SavedPhraseEntity WHERE phraseId = :phraseId")
    suspend fun deletePhrase(phraseId: Long): Int

    /**
     * Get the highest phrase ID
     * @return The highest phrase ID or null if no phrases exist
     */
    @Query("SELECT MAX(phraseId) FROM SavedPhraseEntity")
    suspend fun getCurrentPhraseIndex(): Long?
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\dao\TeleportLocationDao.kt --- 
package com.grindrplus.persistence.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Upsert
import com.grindrplus.persistence.model.TeleportLocationEntity
import timber.log.Timber

@Dao
interface TeleportLocationDao {
    /**
     * Get all teleport locations
     * @return A list of teleport locations
     */
    @Query("SELECT * FROM TeleportLocationEntity")

    suspend fun getLocations(): List<TeleportLocationEntity>

    /**
     * Get a location by name
     * @param name The name of the location
     * @return The location entity or null if not found
     */
    @Query("SELECT * FROM TeleportLocationEntity WHERE name = :name")
    suspend fun getLocation(name: String): TeleportLocationEntity?

    /**
     * Add a new location
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun addLocation(location: TeleportLocationEntity): Long

    /**
     * Update an existing location
     */
    @Upsert
    suspend fun upsertLocation(location: TeleportLocationEntity)

    /**
     * Delete a location
     */
    @Query("DELETE FROM TeleportLocationEntity WHERE name = :name")
    suspend fun deleteLocation(name: String): Int
}

 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\mappers\AlbumMapper.kt --- 
package com.grindrplus.persistence.mappers

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Logger
import com.grindrplus.persistence.model.AlbumContentEntity
import com.grindrplus.persistence.model.AlbumEntity
import de.robv.android.xposed.XposedHelpers.getObjectField
import org.json.JSONObject
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.lang.Long.parseLong

private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US)

private const val ALBUM_CLASS = "com.grindrapp.android.model.Album"
private const val ALBUM_BRIEF_CLASS = "com.grindrapp.android.model.albums.AlbumBrief"
private const val ALBUM_CONTENT_CLASS = "com.grindrapp.android.model.AlbumContent"

fun Any.asAlbumToAlbumEntity(): AlbumEntity {
    return try {
        val id = getObjectField(this, "albumId") as Long
        val name = getObjectField(this, "albumName") as String?
        val profileId = getObjectField(this, "profileId") as Long
        val createdAt = getObjectField(this, "createdAt") as String
        val updatedAt = getObjectField(this, "updatedAt") as String

        AlbumEntity(
            id = id,
            albumName = name,
            createdAt = createdAt,
            profileId = profileId,
            updatedAt = updatedAt
        )
    } catch (e: Throwable) {
        Logger.e("Error converting Album to AlbumEntity: ${e.message}")
        val currentTime = dateFormat.format(Date())
        AlbumEntity(
            id = System.currentTimeMillis(),
            albumName = "Unknown Album",
            createdAt = currentTime,
            profileId = 0L,
            updatedAt = currentTime
        )
    }
}

fun Any.asAlbumBriefToAlbumEntity(): AlbumEntity {
    return try {
        val id = getObjectField(this, "albumId") as Long
        val profileIdObj = getObjectField(this, "profileId")

        val profileId = when (profileIdObj) {
            is String -> parseLong(profileIdObj)
            is Long -> profileIdObj
            else -> 0L
        }

        val name = try { getObjectField(this, "albumName") as String? } catch (_: Throwable) { null }
        val createdAt = try { getObjectField(this, "createdAt") as String } catch (_: Throwable) { "" }
        val updatedAt = try { getObjectField(this, "updatedAt") as String } catch (_: Throwable) { "" }

        AlbumEntity(
            id = id,
            albumName = name,
            createdAt = createdAt,
            profileId = profileId,
            updatedAt = updatedAt
        )
    } catch (e: Throwable) {
        Logger.e("Error converting AlbumBrief to AlbumEntity: ${e.message}")
        val currentTime = dateFormat.format(Date())
        AlbumEntity(
            id = System.currentTimeMillis(),
            albumName = "Unknown Album",
            createdAt = currentTime,
            profileId = 0L,
            updatedAt = currentTime
        )
    }
}

fun Any.toAlbumContentEntity(albumId: Long): AlbumContentEntity {
    return try {
        val id = getObjectField(this, "contentId") as Long
        val contentType = getObjectField(this, "contentType") as String?
        val coverUrl = getObjectField(this, "coverUrl") as String?
        val thumbUrl = getObjectField(this, "thumbUrl") as String?
        val url = getObjectField(this, "url") as String?

        AlbumContentEntity(
            id = id,
            albumId = albumId,
            contentType = contentType,
            coverUrl = coverUrl,
            thumbUrl = thumbUrl,
            url = url
        )
    } catch (e: Throwable) {
        Logger.e("Error converting AlbumContent to AlbumContentEntity: ${e.message}")
        AlbumContentEntity(
            id = System.currentTimeMillis() + albumId,
            albumId = albumId,
            contentType = "unknown",
            coverUrl = null,
            thumbUrl = null,
            url = null
        )
    }
}

fun JSONObject.asAlbumToAlbumEntity(): AlbumEntity {
    return AlbumEntity(
        id = this.optLong("albumId"),
        albumName = this.optString("albumName"),
        createdAt = this.optString("createdAt"),
        profileId = this.optLong("profileId"),
        updatedAt = this.optString("updatedAt")
    )
}

fun JSONObject.toAlbumContentEntities(): List<AlbumContentEntity> {
    val albumId = this.optLong("albumId")
    val contentList = mutableListOf<AlbumContentEntity>()
    this.optJSONArray("content")?.let { contentArray ->
        for (i in 0 until contentArray.length()) {
            val contentJson = contentArray.getJSONObject(i)
            contentList.add(AlbumContentEntity(
                id = contentJson.optLong("contentId"),
                albumId = albumId,
                contentType = contentJson.optString("contentType"),
                coverUrl = contentJson.optString("coverUrl"),
                thumbUrl = contentJson.optString("thumbUrl"),
                url = contentJson.optString("url")
            ))
        }
    }
    return contentList
}

fun AlbumEntity.toGrindrAlbum(dbContent: List<AlbumContentEntity>): Any {
    try {
        val albumConstructor = GrindrPlus.loadClass(ALBUM_CLASS).constructors.first()
        return albumConstructor.newInstance(
            id, // albumId
            profileId, // profileId
            0, // sharedCount
            dbContent.map { it.toGrindrAlbumContent() }, // content
            false, // isSelected
            false, // isPromoAlbum
            null, // promoAlbumName
            null, // promoAlbumProfileImage
            null, // promoAlbumData
            false, // hasUnseenContent
            true, // albumViewable
            true, // isShareable
            Long.MAX_VALUE, // viewableUntil
            albumName, // albumName
            0, // albumNumber
            0, // totalAlbumsShared
            null, // contentCount
            createdAt, // createdAt
            updatedAt, // updatedAt
            emptyList<Any>() // sharedWithProfileIds
        )
    } catch (e: Throwable) {
        Logger.e("Error creating Album instance: ${e.message}")
        Logger.writeRaw(e.stackTraceToString())

        try {
            val albumClass = GrindrPlus.loadClass(ALBUM_CLASS)
            val constructors = albumClass.constructors
            Logger.d("Available constructors for Album: ${constructors.size}")
            constructors.forEachIndexed { index, constructor ->
                Logger.d("Constructor $index: ${constructor.parameterTypes.joinToString()}")
            }
        } catch (e2: Throwable) {
            Logger.e("Failed to inspect Album constructors: ${e2.message}")
        }

        throw e
    }
}

fun AlbumEntity.toGrindrAlbumBrief(dbContent: AlbumContentEntity): Any {
    try {
        val albumBriefConstructor = GrindrPlus.loadClass(ALBUM_BRIEF_CLASS).constructors.first()
        return albumBriefConstructor.newInstance(
            id, // albumId
            profileId.toString(), // profileId
            dbContent.toGrindrAlbumContent(), // content
            false, // hasUnseenContent
            true, // albumViewable
            0, // albumNumber
            0, // totalAlbumsShared
            null // contentCount
        )
    } catch (e: Throwable) {
        Logger.e("Error creating AlbumBrief instance: ${e.message}")

        try {
            val albumBriefClass = GrindrPlus.loadClass(ALBUM_BRIEF_CLASS)
            val constructors = albumBriefClass.constructors
            Logger.d("Available constructors for AlbumBrief: ${constructors.size}")
            constructors.forEachIndexed { index, constructor ->
                Logger.d("Constructor $index: ${constructor.parameterTypes.joinToString()}")
            }
        } catch (e2: Throwable) {
            Logger.e("Failed to inspect AlbumBrief constructors: ${e2.message}")
        }

        throw e
    }
}

fun AlbumContentEntity.toGrindrAlbumContent(): Any {
    try {
        val albumContentConstructor = GrindrPlus.loadClass(ALBUM_CONTENT_CLASS).constructors.first()
        return albumContentConstructor.newInstance(
            id, // contentId
            contentType, // contentType
            url, // url
            false, // isProcessing
            thumbUrl, // thumbUrl
            coverUrl, // coverUrl
            -1 // remainingViews
        )
    } catch (e: Throwable) {
        Logger.e("Error creating AlbumContent instance: ${e.message}")

        try {
            val albumContentClass = GrindrPlus.loadClass(ALBUM_CONTENT_CLASS)
            val constructors = albumContentClass.constructors
            Logger.d("Available constructors for AlbumContent: ${constructors.size}")
            constructors.forEachIndexed { index, constructor ->
                Logger.d("Constructor $index: ${constructor.parameterTypes.joinToString()}")
            }
        } catch (e2: Throwable) {
            Logger.e("Failed to inspect AlbumContent constructors: ${e2.message}")
        }

        throw e
    }
}

fun AlbumEntity.toGrindrAlbumWithoutContent(): Any {
    try {
        val albumConstructor = GrindrPlus.loadClass(ALBUM_CLASS).constructors.first()
        return albumConstructor.newInstance(
            id, // albumId
            profileId, // profileId
            0, // sharedCount
            emptyList<Any>(), // content
            false, // isSelected
            false, // isPromoAlbum
            null, // promoAlbumName
            null, // promoAlbumProfileImage
            null, // promoAlbumData
            false, // hasUnseenContent
            true, // albumViewable
            true, // isShareable
            Long.MAX_VALUE, // viewableUntil
            albumName, // albumName
            0, // albumNumber
            0, // totalAlbumsShared
            null, // contentCount
            createdAt, // createdAt
            updatedAt, // updatedAt
            emptyList<Any>() // sharedWithProfileIds
        )
    } catch (e: Throwable) {
        Logger.e("Error creating Album instance without content: ${e.message}")
        Logger.writeRaw(e.stackTraceToString())
        throw e
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\AlbumContentEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    foreignKeys = [
        ForeignKey(
            entity = AlbumEntity::class,
            parentColumns = ["id"],
            childColumns = ["albumId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("albumId")]
)
data class AlbumContentEntity(
    @PrimaryKey val id: Long,
    val albumId: Long,
    val contentType: String?,
    val coverUrl: String?,
    val thumbUrl: String?,
    val url: String?
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\AlbumEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(indices = [Index("profileId")])
data class AlbumEntity(
    @PrimaryKey val id: Long,
    val albumName: String?,
    val createdAt: String,
    val profileId: Long,
    val updatedAt: String,
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\LogEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "logs")
data class LogEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val timestamp: Long,
    val log_type: String, // "http", "credentials", "wss_auth"
    val url: String? = null,
    val method: String? = null,
    val request_headers: String? = null,
    val request_body: String? = null,
    val response_code: Int? = null,
    val response_headers: String? = null,
    val response_body: String? = null,
    val profile_id: String? = null,
    val auth_token: String? = null,
    val xmpp_token: String? = null,
    val device_info: String? = null,
    val user_agent: String? = null
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\ProfileEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "profiles")
data class ProfileEntity(
    @PrimaryKey
    val profileId: String,
    val displayName: String,
    val lastSeen: Long
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\ProfilePhotoEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity

@Entity(primaryKeys = ["profileId", "mediaHash"])
data class ProfilePhotoEntity(
    val profileId: String,
    val mediaHash: String
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\ProfileViewEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "profile_views")
data class ProfileViewEntity(
    @PrimaryKey
    val profileId: String,
    val viewedAt: Long,
    val displayName: String? = null,
    val distance: Double? = null,
    val mediaHash: String? = null,
    val source: String
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\SavedPhraseEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity
data class SavedPhraseEntity(
    @PrimaryKey val phraseId: Long,
    val text: String,
    val frequency: Int,
    val timestamp: Long
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\persistence\model\TeleportLocationEntity.kt --- 
package com.grindrplus.persistence.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity
data class TeleportLocationEntity(
    @PrimaryKey val name: String,
    val latitude: Double,
    val longitude: Double
) 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\tasks\AlwaysOnline.kt --- 
package com.grindrplus.tasks

import com.grindrplus.GrindrPlus
import com.grindrplus.core.CoroutineHelper.callSuspendFunction
import com.grindrplus.core.Logger
import com.grindrplus.core.Utils.coordsToGeoHash
import com.grindrplus.core.loge
import com.grindrplus.core.logi
import com.grindrplus.core.logw
import com.grindrplus.utils.Task
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField

class AlwaysOnline :
    Task(
        id = "Always Online",
        description = "Keeps you online by periodically fetching cascade",
        initialDelayMillis = 30 * 1000,
        intervalMillis = 5 * 60 * 1000
    ) {
    override suspend fun execute() {
        try {
            val serverDrivenCascadeRepoInstance =
                GrindrPlus.instanceManager.getInstance<Any>(GrindrPlus.serverDrivenCascadeRepo)
            val grindrLocationProviderInstance =
                GrindrPlus.instanceManager.getInstance<Any>(GrindrPlus.grindrLocationProvider)

            // Add a safety check to ensure the required instances are available before proceeding.
            if (serverDrivenCascadeRepoInstance == null || grindrLocationProviderInstance == null) {
                logw("Required instances for AlwaysOnline task are not available yet. Skipping this run.")
                return
            }

            val location = getObjectField(grindrLocationProviderInstance, "e")
            val latitude = callMethod(location, "getLatitude") as Double
            val longitude = callMethod(location, "getLongitude") as Double
            val geoHash = coordsToGeoHash(latitude, longitude)
            val methodName = "fetchCascadePage"

            // The '!!' is no longer needed because we already checked for null.
            val method =
                serverDrivenCascadeRepoInstance.javaClass.methods.firstOrNull {
                    it.name == methodName
                } ?: throw IllegalStateException("Unable to find $methodName method")

            val params = arrayOf<Any?>(
                geoHash, null, false, false, false, false, null, null, null,
                null, null, null, null, null, null, null, null, null, null,
                null, null, false, 1, null, null, false, false, false, null, false
            )

            val result = callSuspendFunction { continuation ->
                method.invoke(serverDrivenCascadeRepoInstance, *params, continuation)
            }

            if (result.toString().contains("Success")) {
                logi("AlwaysOnline task executed successfully")
            } else {
                loge("AlwaysOnline task failed: $result")
            }
        } catch (e: Exception) {
            loge("Error in AlwaysOnline task: ${e.message}")
            Logger.writeRaw(e.stackTraceToString())
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\ui\MySettingsViewModel.kt --- 
/*
package com.grindrplus.ui

data class SettingItem(val name: String, val description: String, val isEnabled: Boolean, val type: String) // type: "hook" or "task"

class SettingsViewModel(
    private val hookManager: HookManager,
    private val taskManager: TaskManager
) : ViewModel() {

    private val _settingsList = MutableStateFlow<List<SettingItem>>(emptyList())
    val settingsList: StateFlow<List<SettingItem>> = _settingsList.asStateFlow()

    init {
        loadSettings()
    }

    private fun loadSettings() {
        viewModelScope.launch {
            val hooks = hookManager.hooks.values.map { hook ->
                SettingItem(hook.hookName, hook.hookDesc, Config.isHookEnabled(hook.hookName), "hook")
            }
            val tasks = taskManager.tasks.values.map { task ->
                SettingItem(task.id, task.description, Config.isTaskEnabled(task.id), "task")
            }
            _settingsList.value = (hooks + tasks).sortedBy { it.name }
        }
    }

    fun toggleSetting(item: SettingItem, enabled: Boolean) {
        viewModelScope.launch {
            if (item.type == "hook") {
                Config.setHookEnabled(item.name, enabled)
                hookManager.reloadHooks() // Reload to apply changes
            } else if (item.type == "task") {
                Config.setTaskEnabled(item.name, enabled)
                taskManager.toggleTask(item.name, enabled)
            }
            loadSettings() // Refresh list
        }
    }
}*/
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\ui\Utils.kt --- 
package com.grindrplus.ui

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.drawable.GradientDrawable
import android.widget.Toast
import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Logger
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter

object Utils {
    fun getId(name: String, defType: String, context: Context): Int {
        return context.resources.getIdentifier(name, defType, context.packageName)
    }

    fun createButtonDrawable(color: Int): GradientDrawable {
        return GradientDrawable().apply {
            shape = GradientDrawable.RECTANGLE
            setColor(color)
            cornerRadius = 12f
        }
    }


    fun copyToClipboard(label: String, text: String) {
        val clipboard = GrindrPlus.context.getSystemService(ClipboardManager::class.java)
        clipboard.setPrimaryClip(ClipData.newPlainText(label, text))
        GrindrPlus.showToast(Toast.LENGTH_LONG, "$label copied to clipboard.")
    }


    fun copyTo(label: String, text: String) {
        try {
            GrindrPlus.runOnMainThreadWithCurrentActivity { activity ->
                try {
                    val clipboard =
                        activity.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                    val clip = ClipData.newPlainText(label, text)
                    clipboard.setPrimaryClip(clip)
                    GrindrPlus.showToast(
                        android.widget.Toast.LENGTH_SHORT,
                        "Copied to clipboard"
                    )
                } catch (e: Exception) {
                    GrindrPlus.showToast(
                        android.widget.Toast.LENGTH_LONG,
                        "Copy failed: ${e.message}"
                    )
                }
            }
        } catch (e: Exception) {
            GrindrPlus.showToast(android.widget.Toast.LENGTH_LONG, "Copy failed: ${e.message}")
        }
    }

    fun formatEpochSeconds(epochSec: Long): String {
        val formatter = DateTimeFormatter.ofPattern(
            Config.get(
                "date_format", "yyyy-MM-dd"
            ) as String
        )
        return try {
            val instant = Instant.ofEpochSecond(epochSec)
            val dt = LocalDateTime.ofInstant(instant, ZoneOffset.UTC)
            dt.format(formatter)
        } catch (e: Exception) {
            Logger.e("Error formatting date: $epochSec with format: $formatter")
            Logger.writeRaw(e.stackTraceToString())
            "Unknown"
        }
    }
}
 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\FeatureManager.kt --- 
package com.grindrplus.utils

data class Feature(val name: String, var isEnabled: Boolean)

class FeatureManager {
    private val features = mutableMapOf<String, Feature>()

    fun add(feature: Feature) {
        features[feature.name] = feature
    }

    fun isEnabled(featureName: String): Boolean {
        return features[featureName]?.isEnabled ?: false
    }

    fun isManaged(featureName: String): Boolean {
        return features.containsKey(featureName)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\Hook.kt --- 
package com.grindrplus.utils

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config

abstract class Hook(
    val hookName: String,
    val hookDesc: String = "",
) {
    /**
     * Hook specific initialization.
     */
    open fun init() {}

    /**
     * Hook specific cleanup.
     */
    open fun cleanup() {}

    protected fun isHookEnabled(): Boolean {
        return Config.isHookEnabled(hookName)
    }

    protected fun findClass(name: String): Class<*> {
        return GrindrPlus.loadClass(name)
    }

    protected fun getResource(name: String, type: String): Int {
        return GrindrPlus.context.resources.getIdentifier(
            name, type, GrindrPlus.context.packageName
        )
    }

    protected fun getAttribute(name: String): Int {
        return GrindrPlus.context.resources.getIdentifier(name, "attr"
            , GrindrPlus.context.packageName)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\HookAdapter.kt --- 
package com.grindrplus.utils

import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedBridge
import java.lang.reflect.Member
import java.util.function.Consumer

@Suppress("UNCHECKED_CAST")
class HookAdapter<Clazz>(
    private val methodHookParam: XC_MethodHook.MethodHookParam<*>
) {
    fun thisObject(): Clazz {
        return methodHookParam.thisObject as Clazz
    }

    fun nullableThisObject(): Clazz? {
        return methodHookParam.thisObject as Clazz?
    }

    fun method(): Member {
        return methodHookParam.method
    }

    fun <T : Any> arg(index: Int): T {
        return methodHookParam.args[index] as T
    }

    fun <T : Any> arg(index: Int, clazz: Class<T>): T? {
        val argValue = methodHookParam.args[index]
        return try {
            clazz.cast(argValue)
        } catch (e: ClassCastException) {
            convertToType(argValue, clazz) ?: handlePrimitiveDefaults(clazz)
        }
    }

    fun <T : Any> argNullable(index: Int): T? {
        return methodHookParam.args.getOrNull(index) as T?
    }

    fun setArg(index: Int, value: Any?) {
        if (index < 0 || index >= methodHookParam.args.size) return
        methodHookParam.args[index] = value
    }

    fun args(): Array<Any?> {
        return methodHookParam.args
    }

    fun getResult(): Any? {
        return methodHookParam.result
    }

    fun setResult(result: Any?) {
        methodHookParam.result = result
    }

    fun setThrowable(throwable: Throwable) {
        methodHookParam.throwable = throwable
    }

    fun throwable(): Throwable? {
        return methodHookParam.throwable
    }

    fun invokeOriginal(): Any? {
        return XposedBridge.invokeOriginalMethod(method(), thisObject(), args())
    }

    fun invokeOriginal(args: Array<Any?>): Any? {
        return XposedBridge.invokeOriginalMethod(method(), thisObject(), args)
    }

    fun invokeOriginalSafe(errorCallback: Consumer<Throwable>) {
        invokeOriginalSafe(args(), errorCallback)
    }

    fun invokeOriginalSafe(args: Array<Any?>, errorCallback: Consumer<Throwable>) {
        runCatching {
            setResult(XposedBridge.invokeOriginalMethod(method(), thisObject(), args))
        }.onFailure {
            errorCallback.accept(it)
        }
    }

    private fun invokeMethodSafe(obj: Any, methodName: String): Any? {
        return try {
            obj::class.java.getMethod(methodName).invoke(obj)
        } catch (e: NoSuchMethodException) {
            null
        }
    }

    private fun <T : Any> handlePrimitiveDefaults(clazz: Class<T>): T? {
        return when (clazz) {
            Int::class.java -> 0 as T
            Double::class.java -> 0.0 as T
            Float::class.java -> 0f as T
            Long::class.java -> 0L as T
            Boolean::class.java -> false as T
            else -> null
        }
    }

    fun <T : Any> convertToType(arg: Any, clazz: Class<T>): T? {
        return try {
            when (clazz) {
                String::class.java -> invokeMethodSafe(arg, "toString") as T
                Int::class.java -> invokeMethodSafe(arg, "toInt") as T
                Double::class.java -> invokeMethodSafe(arg, "toDouble") as T
                Float::class.java -> invokeMethodSafe(arg, "toFloat") as T
                Long::class.java -> invokeMethodSafe(arg, "toLong") as T
                Boolean::class.java -> invokeMethodSafe(arg, "toBoolean") as T
                else -> null
            }
        } catch (_: Exception) {
            null
        }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\Hooker.kt --- 
package com.grindrplus.utils

import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedBridge
import java.lang.reflect.Member
import java.lang.reflect.Method

enum class HookStage {
    BEFORE,
    AFTER
}

object Hooker {
    inline fun <T> newMethodHook(
        stage: HookStage,
        crossinline consumer: (HookAdapter<T>) -> Unit,
        crossinline filter: ((HookAdapter<T>) -> Boolean) = { true }
    ): XC_MethodHook {
        return when (stage) {
            HookStage.BEFORE -> object : XC_MethodHook() {
                override fun beforeHookedMethod(param: MethodHookParam<*>) {
                    HookAdapter<T>(param).takeIf(filter)?.also(consumer)
                }
            }
            HookStage.AFTER -> object : XC_MethodHook() {
                override fun afterHookedMethod(param: MethodHookParam<*>) {
                    HookAdapter<T>(param).takeIf(filter)?.also(consumer)
                }
            }
        }
    }

    inline fun <T> hook(
        clazz: Class<T>,
        methodName: String,
        stage: HookStage,
        crossinline filter: (HookAdapter<T>) -> Boolean,
        noinline consumer: (HookAdapter<T>) -> Unit
    ): Set<XC_MethodHook.Unhook> = XposedBridge.hookAllMethods(clazz, methodName, newMethodHook(stage, consumer, filter))

    inline fun <T> hook(
        member: Member,
        stage: HookStage,
        crossinline filter: ((HookAdapter<T>) -> Boolean),
        crossinline consumer: (HookAdapter<T>) -> Unit
    ): XC_MethodHook.Unhook {
        return XposedBridge.hookMethod(member, newMethodHook(stage, consumer, filter))
    }

    fun <T> hook(
        clazz: Class<T>,
        methodName: String,
        stage: HookStage,
        consumer: (HookAdapter<T>) -> Unit
    ): Set<XC_MethodHook.Unhook> = hook(clazz, methodName, stage, { true }, consumer)

    fun <T> hook(
        member: Member,
        stage: HookStage,
        consumer: (HookAdapter<T>) -> Unit
    ): XC_MethodHook.Unhook {
        return hook(member, stage, { true }, consumer)
    }

    fun <T> hookConstructor(
        clazz: Class<T>,
        stage: HookStage,
        consumer: (HookAdapter<T>) -> Unit
    ): Set<XC_MethodHook.Unhook> = XposedBridge.hookAllConstructors(clazz, newMethodHook(stage, consumer))

    fun <T> hookConstructor(
        clazz: Class<T>,
        stage: HookStage,
        filter: ((HookAdapter<T>) -> Boolean),
        consumer: (HookAdapter<T>) -> Unit
    ) {
        XposedBridge.hookAllConstructors(clazz, newMethodHook(stage, consumer, filter))
    }

    inline fun <T> hookObjectMethod(
        clazz: Class<T>,
        instance: Any,
        methodName: String,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ): List<() -> Unit> {
        val unhooks = mutableSetOf<XC_MethodHook.Unhook>()
        hook(clazz, methodName, stage) { param->
            if (param.nullableThisObject().let {
                    if (it == null) unhooks.forEach { u -> u.unhook() }
                    it != instance
                }) return@hook
            hookConsumer(param)
        }.also { unhooks.addAll(it) }
        return unhooks.map {
            { it.unhook() }
        }
    }

    inline fun <T> ephemeralHook(
        clazz: Class<T>,
        methodName: String,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ) {
        val unhooks: MutableSet<XC_MethodHook.Unhook> = HashSet()
        hook(clazz, methodName, stage) { param->
            hookConsumer(param)
            unhooks.forEach{ it.unhook() }
        }.also { unhooks.addAll(it) }
    }

    inline fun <T> ephemeralHookObjectMethod(
        clazz: Class<T>,
        instance: Any,
        methodName: String,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ) {
        val unhooks: MutableSet<XC_MethodHook.Unhook> = HashSet()
        hook(clazz, methodName, stage) { param->
            if (param.nullableThisObject() != instance) return@hook
            unhooks.forEach { it.unhook() }
            hookConsumer(param)
        }.also { unhooks.addAll(it) }
    }

    inline fun <T> ephemeralHookConstructor(
        clazz: Class<T>,
        stage: HookStage,
        crossinline hookConsumer: (HookAdapter<T>) -> Unit
    ) {
        val unhooks: MutableSet<XC_MethodHook.Unhook> = HashSet()
        hookConstructor(clazz, stage) { param->
            hookConsumer(param)
            unhooks.forEach{ it.unhook() }
        }.also { unhooks.addAll(it) }
    }
}

fun <T> Class<T>.hookConstructor(
    stage: HookStage,
    consumer: (HookAdapter<T>) -> Unit
) = Hooker.hookConstructor(this, stage, consumer)

fun <T> Class<T>.hookConstructor(
    stage: HookStage,
    filter: ((HookAdapter<T>) -> Boolean),
    consumer: (HookAdapter<T>) -> Unit
) = Hooker.hookConstructor(this, stage, filter, consumer)

fun <T> Class<T>.hook(
    methodName: String,
    stage: HookStage,
    consumer: (HookAdapter<T>) -> Unit
): Set<XC_MethodHook.Unhook> = Hooker.hook(this, methodName, stage, consumer)

fun <T> Class<T>.hook(
    methodName: String,
    stage: HookStage,
    filter: (HookAdapter<T>) -> Boolean,
    consumer: (HookAdapter<T>) -> Unit
): Set<XC_MethodHook.Unhook> = Hooker.hook(this, methodName, stage, filter, consumer)

fun Member.hook(
    stage: HookStage,
    consumer: (HookAdapter<Any>) -> Unit
): XC_MethodHook.Unhook = Hooker.hook(this, stage, consumer)

fun Member.hook(
    stage: HookStage,
    filter: ((HookAdapter<Any>) -> Boolean),
    consumer: (HookAdapter<Any>) -> Unit
): XC_MethodHook.Unhook = Hooker.hook(this, stage, filter, consumer)

fun Array<Method>.hookAll(stage: HookStage, param: (HookAdapter<Any>) -> Unit) {
    filter { it.declaringClass != Object::class.java }.forEach {
        it.hook(stage, param)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\HookManager.kt --- 
package com.grindrplus.utils

import com.grindrplus.hooks.SaveMediaOnLongPress
import com.grindrplus.hooks.UnlimitedAlbums
import com.grindrplus.core.Config
import com.grindrplus.core.Logger
import com.grindrplus.hooks.AllowScreenshots
import com.grindrplus.hooks.AntiBlock
import com.grindrplus.hooks.AntiDetection
import com.grindrplus.hooks.BanManagement
import com.grindrplus.hooks.CascadeGrid
import com.grindrplus.hooks.ChatIndicators
import com.grindrplus.hooks.ChatTerminal
import com.grindrplus.hooks.DisableAnalytics
import com.grindrplus.hooks.DisableBoosting
import com.grindrplus.hooks.DisableShuffle
import com.grindrplus.hooks.DisableUpdates
import com.grindrplus.hooks.EmptyCalls
import com.grindrplus.hooks.EnableUnlimited
import com.grindrplus.hooks.ExpiringMedia
import com.grindrplus.hooks.Favorites
import com.grindrplus.hooks.FeatureGranting
import com.grindrplus.hooks.LocalSavedPhrases
import com.grindrplus.hooks.LocationSpoofer
import com.grindrplus.hooks.NotificationAlerts
import com.grindrplus.hooks.OnlineIndicator
import com.grindrplus.hooks.ProfileDetails
import com.grindrplus.hooks.ProfileViews
import com.grindrplus.hooks.ProfileViewsTracker
import com.grindrplus.hooks.QuickBlock
import com.grindrplus.hooks.StatusDialog
import com.grindrplus.hooks.TimberLogging
import com.grindrplus.hooks.UnlimitedProfiles
import com.grindrplus.hooks.ViewedMe
import com.grindrplus.hooks.WebSocketAlive
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.runBlocking
import kotlin.reflect.KClass

class HookManager {
    private var hooks = mutableMapOf<KClass<out Hook>, Hook>()

    fun registerHooks(init: Boolean = true) {
        runBlocking(Dispatchers.IO) {
            val hookList = listOf(
                WebSocketAlive(),
                TimberLogging(),
                BanManagement(),
                FeatureGranting(),
                EnableUnlimited(),
                AntiDetection(),
                StatusDialog(),
                AntiBlock(),
                NotificationAlerts(),
                DisableUpdates(),
                DisableBoosting(),
                DisableShuffle(),
                AllowScreenshots(),
                ChatIndicators(),
                ChatTerminal(),
                DisableAnalytics(),
                ExpiringMedia(),
                Favorites(),
                LocalSavedPhrases(),
                LocationSpoofer(),
                OnlineIndicator(),
                UnlimitedProfiles(),
                ProfileDetails(),
                ProfileViews(),
                QuickBlock(),
                EmptyCalls(),
                ProfileViewsTracker(),
                SaveMediaOnLongPress(),
                ViewedMe(),
                (CascadeGrid()) ,
                UnlimitedAlbums()
            )

            hookList.forEach { hook ->
                Config.initHookSettings(
                    hook.hookName, hook.hookDesc, true
                )
            }

            if (!init) return@runBlocking

            hooks = hookList.associateBy { it::class }.toMutableMap()

            hooks.values.forEach { hook ->
                if (Config.isHookEnabled(hook.hookName)) {
                    hook.init()
                    Logger.s("Initialized hook: ${hook.hookName}")
                } else {
                    Logger.i("Hook ${hook.hookName} is disabled.")
                }
            }
        }
    }

    fun reloadHooks() {
        runBlocking(Dispatchers.IO) {
            hooks.values.forEach { hook -> hook.cleanup() }
            hooks.clear()
            registerHooks()
            Logger.s("Reloaded hooks")
        }
    }

    fun init() {
        registerHooks()
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\MediaUtils.kt --- 
package com.grindrplus.utils

import android.util.Base64
import android.widget.ImageView
import android.widget.Toast
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.content.ContentResolver
import android.content.ContentValues
import android.os.Environment
import android.provider.MediaStore
import java.io.OutputStream
import android.webkit.MimeTypeMap
import com.grindrplus.GrindrPlus
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import okhttp3.Call
import okhttp3.Callback
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import timber.log.Timber
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.concurrent.TimeUnit
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

object MediaUtils {
    private val httpClient by lazy {
        OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }

    private val mediaDir: File by lazy {
        File(GrindrPlus.context.filesDir, "saved_media").apply {
            if (!exists()) mkdirs()
        }
    }

    private val imageDir: File by lazy {
        File(mediaDir, "images").apply {
            if (!exists()) mkdirs()
        }
    }

    private val videoDir: File by lazy {
        File(mediaDir, "videos").apply {
            if (!exists()) mkdirs()
        }
    }

    /**
     * Downloads a media file and saves it to a public, user-accessible directory.
     * Creates an organized folder structure within Pictures/ or Movies/.
     */
    fun saveMediaToPublicDirectory(
        url: String,
        albumName: String,
        profileId: String,
        contentId: String,
        contentType: String
    ) {
        GrindrPlus.executeAsync { // Ensure this runs in the background
            val isVideo = contentType.startsWith("video/")
            val fileExtension = if (isVideo) "mp4" else "jpg"
            val directoryType = if (isVideo) Environment.DIRECTORY_MOVIES else Environment.DIRECTORY_PICTURES

            // Sanitize folder names to prevent filesystem errors
            val safeAlbumName = albumName.replace(Regex("[^a-zA-Z0-9.-]"), "_")
            val safeProfileId = profileId.replace(Regex("[^a-zA-Z0-9.-]"), "_")

            val relativePath = "${directoryType}/GrindrPlus/Albums/${safeProfileId} - ${safeAlbumName}"
            val fileName = "$contentId.$fileExtension"

            try {
                val resolver = GrindrPlus.context.contentResolver

                // Check if the file already exists to avoid re-downloading
                val projection = arrayOf(MediaStore.MediaColumns._ID)
                val selection = "${MediaStore.MediaColumns.RELATIVE_PATH} = ? AND ${MediaStore.MediaColumns.DISPLAY_NAME} = ?"
                val selectionArgs = arrayOf("$relativePath/", fileName)
                val queryUri = if (isVideo) MediaStore.Video.Media.EXTERNAL_CONTENT_URI else MediaStore.Images.Media.EXTERNAL_CONTENT_URI

                resolver.query(queryUri, projection, selection, selectionArgs, null)?.use { cursor ->
                    if (cursor.moveToFirst()) {
                        Logger.d("Media file already exists, skipping download: $fileName", LogSource.MODULE)
                        return@executeAsync
                    }
                }

                Logger.d("Downloading album media: $fileName")
                val mediaData = downloadMediaSync(url).getOrThrow()

                val values = ContentValues().apply {
                    put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)
                    put(MediaStore.MediaColumns.MIME_TYPE, if (isVideo) "video/mp4" else "image/jpeg")
                    put(MediaStore.MediaColumns.RELATIVE_PATH, relativePath)
                }

                val uri = resolver.insert(queryUri, values)
                if (uri != null) {
                    resolver.openOutputStream(uri).use { os ->
                        os?.write(mediaData)
                    }
                    Logger.i("Successfully saved album media to gallery: $fileName", LogSource.MODULE)
                } else {
                    throw IOException("Failed to create MediaStore entry.")
                }
            } catch (e: Exception) {
                Logger.e("Failed to save public media for $contentId: ${e.message}", LogSource.MODULE)
            }
        }
    }

    /**
     * Determines media type from URL or content type
     * @param url The media URL
     * @param contentType Optional content type header
     * @return MediaType.IMAGE, MediaType.VIDEO, or MediaType.UNKNOWN
     */
    fun getMediaType(url: String, contentType: String? = null): MediaType {
        if (!contentType.isNullOrBlank()) {
            if (contentType.startsWith("image/")) return MediaType.IMAGE
            if (contentType.startsWith("video/")) return MediaType.VIDEO
        }

        val extension = MimeTypeMap.getFileExtensionFromUrl(url)?.lowercase() ?: ""
        return when {
            extension in imageExtensions -> MediaType.IMAGE
            extension in videoExtensions -> MediaType.VIDEO
            url.contains("image", ignoreCase = true) -> MediaType.IMAGE
            url.contains("video", ignoreCase = true) -> MediaType.VIDEO
            else -> MediaType.UNKNOWN
        }
    }

    /**
     * Converts a ByteArray to a Base64 encoded string
     */
    fun ByteArray.toBase64(): String = Base64.encodeToString(this, Base64.DEFAULT)

    /**
     * Decodes a Base64 string back to ByteArray
     */
    fun String.fromBase64(): ByteArray = Base64.decode(this, Base64.DEFAULT)

    /**
     * Saves a ByteArray to the specified file
     * @return Result containing true on success or an exception on failure
     */
    fun ByteArray.saveToFile(file: File): Result<Boolean> = runCatching {
        FileOutputStream(file).use { it.write(this) }
        Timber.d("Successfully saved Media")
        true
    }

    /**
     * Downloads media from a URL as a ByteArray using coroutines
     * @param url The URL of the media to download
     * @return Result containing the downloaded ByteArray or an exception on failure
     */
    suspend fun downloadMedia(url: String): Result<ByteArray> = runCatching {
        suspendCancellableCoroutine { continuation ->
            val request = Request.Builder()
                .url(url)
                .get()
                .build()

            val call = httpClient.newCall(request)

            continuation.invokeOnCancellation {
                call.cancel()
            }

            call.enqueue(object : Callback {
                override fun onFailure(call: Call, e: IOException) {
                    continuation.resumeWithException(e)
                }

                override fun onResponse(call: Call, response: Response) {
                    try {
                        if (!response.isSuccessful) {
                            continuation.resumeWithException(
                                IOException("Unexpected HTTP response: ${response.code}")
                            )
                            return
                        }

                        response.body?.bytes()?.let {
                            continuation.resume(it)
                        } ?: continuation.resumeWithException(
                            IOException("Empty response body")
                        )
                    } catch (e: Exception) {
                        continuation.resumeWithException(e)
                    } finally {
                        response.close()
                    }
                }
            })
        }
    }

    /**
     * Synchronously downloads media from a URL as a ByteArray
     * @param url The URL of the media to download
     * @return Result containing the downloaded ByteArray or an exception on failure
     */
    fun downloadMediaSync(url: String): Result<ByteArray> = runCatching {
        val request = Request.Builder()
            .url(url)
            .get()
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                throw IOException("Unexpected HTTP response: ${response.code}")
            }

            response.body?.bytes() ?: throw IOException("Empty response body")
        }
    }

    /**
     * Saves media permanently and returns its file URL
     *
     * @param mediaId The ID of the media
     * @param mediaData The media data as ByteArray
     * @param mediaType The type of media (image or video)
     * @param extension Optional file extension (defaults to jpg for images, mp4 for videos)
     * @return Result containing the file URI as a string or an exception on failure
     */
    suspend fun saveMedia(
        mediaId: Long,
        mediaData: ByteArray,
        mediaType: MediaType = MediaType.IMAGE,
        extension: String? = null
    ): Result<String> = withContext(Dispatchers.IO) {
        runCatching {
            val directory = when (mediaType) {
                MediaType.IMAGE -> imageDir
                MediaType.VIDEO -> videoDir
                MediaType.UNKNOWN -> mediaDir
            }

            val fileExtension = extension ?: when (mediaType) {
                MediaType.IMAGE -> "jpg"
                MediaType.VIDEO -> "mp4"
                MediaType.UNKNOWN -> "bin"
            }

            val mediaFile = File(directory, "$mediaId.$fileExtension")

            if (!mediaFile.exists()) {
                mediaData.saveToFile(mediaFile).getOrThrow()
                Logger.d("Saved ${mediaType.name.lowercase()} for mediaId $mediaId to ${mediaFile.absolutePath}")
            }

            Timber.i("${mediaFile.absolutePath}")
            "file://${mediaFile.absolutePath}"

        }.onFailure {
            Logger.e("Error saving ${mediaType.name.lowercase()} file: ${it.message}")
        }
    }

    /**
     * Gets the file URL for a saved media
     *
     * @param mediaId The ID of the media
     * @param mediaType The type of media (image or video)
     * @param extension Optional file extension to check (if null, defaults to jpg for images, mp4 for videos)
     * @return The file URI as a string, or null if the file doesn't exist
     */
    fun getMediaFileUrl(
        mediaId: Long,
        mediaType: MediaType = MediaType.IMAGE,
        extension: String? = null
    ): String? {
        val directory = when (mediaType) {
            MediaType.IMAGE -> imageDir
            MediaType.VIDEO -> videoDir
            MediaType.UNKNOWN -> mediaDir
        }

        if (extension != null) {
            val specificFile = File(directory, "$mediaId.$extension")
            if (specificFile.exists()) {
                return "file://${specificFile.absolutePath}"
            }
            return null
        }

        val defaultExt = when (mediaType) {
            MediaType.IMAGE -> "jpg"
            MediaType.VIDEO -> "mp4"
            MediaType.UNKNOWN -> null
        }

        if (defaultExt != null) {
            val defaultFile = File(directory, "$mediaId.$defaultExt")
            if (defaultFile.exists()) {
                return "file://${defaultFile.absolutePath}"
            }
        }

        if (mediaType == MediaType.UNKNOWN) {
            val extensions = imageExtensions + videoExtensions
            for (ext in extensions) {
                val file = File(directory, "$mediaId.$ext")
                if (file.exists()) {
                    return "file://${file.absolutePath}"
                }
            }
        }

        return null
    }

    /**
     * Checks if media exists for the given ID
     *
     * @param mediaId The ID of the media
     * @param mediaType The type of media to check for
     * @param extension Optional file extension to check (if null, checks default extensions)
     * @return True if the file exists, false otherwise
     */
    fun mediaExists(
        mediaId: Long,
        mediaType: MediaType = MediaType.UNKNOWN,
        extension: String? = null
    ): Boolean {
        val directories = when (mediaType) {
            MediaType.IMAGE -> listOf(imageDir)
            MediaType.VIDEO -> listOf(videoDir)
            MediaType.UNKNOWN -> listOf(imageDir, videoDir, mediaDir)
        }

        if (extension != null) {
            for (dir in directories) {
                if (File(dir, "$mediaId.$extension").exists()) {
                    return true
                }
            }
            return false
        }

        when (mediaType) {
            MediaType.IMAGE -> {
                if (File(imageDir, "$mediaId.jpg").exists()) {
                    return true
                }
            }
            MediaType.VIDEO -> {
                if (File(videoDir, "$mediaId.mp4").exists()) {
                    return true
                }
            }
            MediaType.UNKNOWN -> {
                if (File(imageDir, "$mediaId.jpg").exists() ||
                    File(videoDir, "$mediaId.mp4").exists()) {
                    return true
                }
            }
        }

        if (mediaType == MediaType.UNKNOWN) {
            val extensions = imageExtensions + videoExtensions
            for (dir in directories) {
                for (ext in extensions) {
                    if (File(dir, "$mediaId.$ext").exists()) {
                        return true
                    }
                }
            }
        }

        return false
    }

    /**
     * Gets the list of all saved media IDs of a specific type
     *
     * @param mediaType The type of media to list
     * @return List of media IDs that have been saved
     */
    fun getAllSavedMediaIds(mediaType: MediaType = MediaType.UNKNOWN): List<Long> {
        val directories = when (mediaType) {
            MediaType.IMAGE -> listOf(imageDir)
            MediaType.VIDEO -> listOf(videoDir)
            MediaType.UNKNOWN -> listOf(imageDir, videoDir, mediaDir)
        }

        return directories.flatMap { dir ->
            dir.listFiles()
                ?.filter { it.isFile }
                ?.mapNotNull { file ->
                    file.nameWithoutExtension.toLongOrNull()
                } ?: emptyList()
        }.distinct()
    }

    enum class MediaType {
        IMAGE, VIDEO, UNKNOWN
    }

    // I'm pretty sure Grindr defaults to both JPG and MP4 but let's keep this
    // flexible in case they change it in the future.
    private val imageExtensions = listOf("jpg", "jpeg", "png", "gif", "webp")
    private val videoExtensions = listOf("mp4", "mkv", "mov", "avi", "webm")
}

/**
 * Utility object specifically for expiring photos, which uses the more generic MediaUtils
 * underneath. This allows legacy code to keep working without changes.
 */
object ExpiringPhotoUtils {
    /**
     * Downloads an image from a URL using coroutines
     * @param url The URL of the image to download
     * @return Result containing the downloaded ByteArray or an exception on failure
     */
    suspend fun downloadImage(url: String): Result<ByteArray> =
        MediaUtils.downloadMedia(url)

    /**
     * Saves an image and returns its file URL
     *
     * @param mediaId The ID of the media
     * @param imageData The image data as ByteArray
     * @param extension Optional file extension (defaults to jpg)
     * @return Result containing the file URI as a string or an exception on failure
     */
    suspend fun saveImage(mediaId: Long, imageData: ByteArray, extension: String? = null): Result<String> =
        MediaUtils.saveMedia(mediaId, imageData, MediaUtils.MediaType.IMAGE, extension)

    /**
     * Gets the file URL for a saved image
     *
     * @param mediaId The ID of the media
     * @param extension Optional file extension (defaults to jpg)
     * @return The file URI as a string, or null if the file doesn't exist
     */
    fun getImageFileUrl(mediaId: Long, extension: String? = null): String? =
        MediaUtils.getMediaFileUrl(mediaId, MediaUtils.MediaType.IMAGE, extension)

    /**
     * Checks if an image file exists for the given media ID
     *
     * @param mediaId The ID of the media
     * @param extension Optional file extension (defaults to jpg)
     * @return True if the file exists, false otherwise
     */
    fun imageFileExists(mediaId: Long, extension: String? = null): Boolean =
        MediaUtils.mediaExists(mediaId, MediaUtils.MediaType.IMAGE, extension)

    /**
     * Gets the list of all saved image IDs
     *
     * @return List of media IDs that have been saved
     */
    fun getAllSavedImageIds(): List<Long> =
        MediaUtils.getAllSavedMediaIds(MediaUtils.MediaType.IMAGE)
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\PCHIP.kt --- 
package com.grindrplus.utils

import kotlin.math.abs

/**
 * Fritsch–Carlson PCHIP (Piecewise Cubic Hermite Interpolation)
 * for monotonically increasing functions. By https://github.com/Supersonic
 */
class PCHIP(points: List<Pair<Long, Int>>) {

    private val n = points.size

    private val x = DoubleArray(n)
    private val y = DoubleArray(n)

    private val m = DoubleArray(n)

    init {
        require(n >= 2) { "Need at least two data points." }

        // Sanity check to ensure monotonicity
        for (i in points.indices) {
            x[i] = points[i].first.toDouble()
            y[i] = points[i].second.toDouble()
            if (i > 0) {
                require(x[i] > x[i - 1]) { "x must be strictly ascending" }
                require(y[i] >= y[i - 1]) { "y must be non-decreasing" }
            }
        }
        computeSlopes()
    }

    /**
     * 1) Compute the "interval slopes" delta_i = (y_{i+1} - y_i)/(x_{i+1} - x_i), i=0..n-2
     * 2) Set end slopes m_0 = delta_0, m_{n-1} = delta_{n-2}
     * 3) For each interior i=1..n-2:
     *     - if delta_{i-1} * delta_i <= 0 => m_i = 0
     *     - else => smooth them to ensure monotonicity
     */
    private fun computeSlopes() {
        val h = DoubleArray(n - 1)
        val delta = DoubleArray(n - 1)
        for (i in 0 until n - 1) {
            h[i] = x[i + 1] - x[i]
            require(h[i] > 0) {"Duplicate x-value"}
            delta[i] = (y[i + 1] - y[i]) / h[i]
        }

        m[0] = delta[0]
        m[n - 1] = delta[n - 2]

        for (i in 1 until n - 1) {
            if (delta[i - 1] * delta[i] <= 0.0) {
                m[i] = 0.0
            } else {
                // weighted harmonic mean
                val w1 = 2.0 * h[i] + h[i - 1]
                val w2 = h[i] + 2.0 * h[i - 1]
                m[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i])
            }
        }
    }

    /**
     * Derive the interpolant at time X (in seconds).
     * If X is outside [x[0], x[n-1]] we extrapolate using the last interval or the first.
     */
    fun interpolate(X: Double): Double {
        val i = findInterval(X)

        // transform X -> local t over [0..1]
        val h = x[i + 1] - x[i]
        val t = (X - x[i]) / h

        // hermite basis
        val t2 = t * t
        val t3 = t2 * t

        val h00 = 2.0 * t3 - 3.0 * t2 + 1.0
        val h10 = t3 - 2.0 * t2 + t
        val h01 = -2.0 * t3 + 3.0 * t2
        val h11 = t3 - t2

        return h00 * y[i] +
                h10 * h * m[i] +
                h01 * y[i + 1] +
                h11 * h * m[i + 1]
    }

    /**
     * Given a target Y (ID), find X via bisection search within the relevant interval,
     */
    fun invert(targetY: Double): Double {
        // ensure we have at least two points
        require(n >= 2) { "Need at least two data points for interpolation" }

        // clamp if targetY is outside [y[0], y[n-1]]
        if (targetY <= y[0]) return x[0]

        // use a linear extension for targetY larger than y[n-1]. Clamp to no later than now
        if (targetY >= y[n - 1]) {
            // prevent division by zero or index out of bounds by checking we have at least 2 points
            val extendedX = if (n > 1) {
                val yDiff = y[n-1] - y[n-2]
                val xDiff = x[n-1] - x[n-2]

                if (abs(yDiff) > 1e-10) {
                    val slopeXbyY = xDiff / yDiff
                    val deltaY = targetY - y[n-1]
                    x[n-1] + deltaY * slopeXbyY
                } else {
                    // if Y values are essentially the same, use the last known X value
                    x[n-1]
                }
            } else {
                // fallback to the only point if there's just one point
                x[0]
            }

            // use current system time as the upper bound
            val nowX = System.currentTimeMillis() / 1000.0

            return minOf(extendedX, nowX)
        }

        val i = findIntervalByY(targetY)
        var left = x[i]
        var right = x[i + 1]

        // 30 iterations is enough for the precision we need
        repeat(30) {
            val mid = 0.5 * (left + right)
            val fMid = interpolate(mid)
            if (fMid < targetY) {
                left = mid
            } else {
                right = mid
            }
        }
        return 0.5 * (left + right)
    }

    private fun findInterval(X: Double): Int {
        if (X <= x[0]) return 0
        if (X >= x[n - 1]) return n - 2
        for (i in 0 until n - 1) {
            if (X < x[i + 1]) {
                return i
            }
        }
        return n - 2
    }

    private fun findIntervalByY(targetY: Double): Int {
        for (i in 0 until n - 1) {
            if (targetY <= y[i + 1]) {
                return i
            }
        }
        // fallback
        return n - 2
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\RetrofitUtils.kt --- 
package com.grindrplus.utils

import com.grindrplus.GrindrPlus
import de.robv.android.xposed.XposedHelpers.callMethod
import de.robv.android.xposed.XposedHelpers.getObjectField
import java.lang.reflect.InvocationHandler
import java.lang.reflect.Method
import java.lang.reflect.Proxy

object RetrofitUtils {
    const val FAIL_CLASS_NAME = "ya.a\$a"
    const val SUCCESS_CLASS_NAME = "ya.a\$b"
    const val SUCCESS_VALUE_NAME = "a"
    const val RETROFIT_NAME = "retrofit2.Retrofit"

    fun findPOSTMethod(clazz: Class<*>, value: String): Method? {
        return clazz.declaredMethods.find { method ->
            method.annotations.any {
                it.annotationClass.java.name == "retrofit2.http.POST"
                        && callMethod(it, "value") == value
            }
        }
    }

    fun Method.isPOST(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.POST"
                    && callMethod(it, "value") == value
        }
    }

    fun Method.isDELETE(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.DELETE"
                    && callMethod(it, "value") == value
        }
    }

    fun Method.isGET(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.GET"
                    && callMethod(it, "value") == value
        }
    }

    fun Method.isPUT(value: String): Boolean {
        return this.annotations.any {
            it.annotationClass.java.name == "retrofit2.http.PUT"
                    && callMethod(it, "value") == value
        }
    }

    fun Any.isFail(): Boolean {
        return javaClass.name == FAIL_CLASS_NAME
    }

    fun Any.isSuccess(): Boolean {
        return javaClass.name == SUCCESS_CLASS_NAME
    }

    fun Any.getSuccessValue(): Any {
        return getObjectField(this, SUCCESS_VALUE_NAME)
    }

    fun Any.getFailValue(): Any {
        return getObjectField(this, SUCCESS_VALUE_NAME)
    }

    fun createSuccess(value: Any): Any {
        val successClass = GrindrPlus.loadClass(SUCCESS_CLASS_NAME)
        return successClass.constructors.first().newInstance(value)
    }

    fun createServiceProxy(
        originalService: Any,
        serviceClass: Class<*>,
        blacklist: Array<String> = emptyArray()
    ): Any {
        val invocationHandler = Proxy.getInvocationHandler(originalService)
        val successConstructor =
            GrindrPlus.loadClass(SUCCESS_CLASS_NAME).constructors.firstOrNull()
        return Proxy.newProxyInstance(
            originalService.javaClass.classLoader,
            arrayOf(serviceClass)
        ) { proxy, method, args ->
            if (successConstructor != null && (blacklist.isEmpty() || method.name in blacklist)) {
                successConstructor.newInstance(Unit)
            } else {
                invocationHandler.invoke(proxy, method, args)
            }
        }
    }

    fun hookService(
        serviceClass: Class<*>,
        invoke: (originalHandler: InvocationHandler, proxy: Any, method: Method, args: Array<Any?>) -> Any?
    ) {
        GrindrPlus.loadClass(RETROFIT_NAME)
            .hook("create", HookStage.AFTER) { param ->
                val serviceInstance = param.getResult()
                if (serviceInstance != null && serviceClass.isAssignableFrom(serviceInstance.javaClass)) {
                    val invocationHandler = Proxy.getInvocationHandler(serviceInstance)
                    param.setResult(Proxy.newProxyInstance(
                        serviceInstance.javaClass.classLoader,
                        arrayOf(serviceClass)
                    ) { proxy, method, args ->
                        invoke(invocationHandler, proxy, method, args)
                    })
                }
            }
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\SuspendResultUtils.kt --- 
package com.grindrplus.utils

import de.robv.android.xposed.XC_MethodHook

fun withSuspendResult(args: Array<Any?>, result: Any, onResult: (Array<Any?>, Any) -> Any): Any {
    return if (result.toString() == "COROUTINE_SUSPENDED") {
        var unhook: Set<XC_MethodHook.Unhook>? = null
        unhook = args.last()!!.javaClass.hook("invokeSuspend", HookStage.BEFORE) {
            unhook?.forEach(XC_MethodHook.Unhook::unhook)
            unhook = null
            it.setArg(0, onResult(args, it.arg(0)))
        }
        result
    } else {
        onResult(args, result)
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\Task.kt --- 
package com.grindrplus.utils

import com.grindrplus.GrindrPlus
import com.grindrplus.core.Config
import com.grindrplus.core.Logger
import com.grindrplus.core.LogSource
import kotlinx.coroutines.Job

abstract class Task(
    val id: String,
    val description: String,
    val initialDelayMillis: Long = 30 * 1000, // 30 seconds
    val intervalMillis: Long = 10 * 60 * 1000 // 10 minutes
) {
    private var job: Job? = null

    /**
     * Check if the task is enabled in config
     */
    fun isTaskEnabled(): Boolean {
        return Config.isTaskEnabled(id)
    }

    /**
     * Override this method to implement task-specific logic
     */
    abstract suspend fun execute()

    /**
     * Start the task if it's enabled in config
     */
    fun start() {
        if (!isTaskEnabled()) {
            Logger.i("Task $id is disabled", LogSource.MODULE)
            return
        }

        job = GrindrPlus.taskManager.startPeriodicTask(
            taskId = id,
            initialDelayMillis = initialDelayMillis,
            intervalMillis = intervalMillis,
            action = {
                try {
                    execute()
                    Logger.i("Task $id executed successfully", LogSource.MODULE)
                } catch (e: Exception) {
                    Logger.e("Task $id failed: ${e.message}", LogSource.MODULE)
                    Logger.writeRaw(e.stackTraceToString())
                }
            }
        )

        Logger.i("Task $id started", LogSource.MODULE)
    }

    /**
     * Stop the task
     */
    fun stop() {
        job?.let {
            if (GrindrPlus.taskManager.isTaskRunning(id)) {
                GrindrPlus.taskManager.cancelTask(id)
                Logger.i("Task $id stopped", LogSource.MODULE)
            }
        }
        job = null
    }

    /**
     * Called when task is first registered
     */
    open fun register() {
        Config.initTaskSettings(
            id,
            description,
            false // disabled by default
        )
    }
} 
--- File: D:\ANDROID\PROJECTS_GRINDR\4.5-25.12\ReUse140963\app\src\main\java\com\grindrplus\utils\TaskManager.kt --- 
package com.grindrplus.utils

import com.grindrplus.core.Config
import com.grindrplus.core.LogSource
import com.grindrplus.core.Logger
import com.grindrplus.core.TaskScheduler
import com.grindrplus.tasks.AlwaysOnline
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlin.reflect.KClass

class TaskManager(private val scheduler: TaskScheduler? = null) {
    private val tasks = mutableMapOf<KClass<out Task>, Task>()

    fun registerTasks(startTasks: Boolean = true) {
        runBlocking(Dispatchers.IO) {
            val taskList = listOf(
                AlwaysOnline(),
            )

            taskList.forEach { task ->
                task.register()
            }

            tasks.clear()
            taskList.forEach { task ->
                tasks[task::class] = task

                if (startTasks && task.isTaskEnabled()) {
                    task.start()
                    Logger.i("Started task: ${task.id}", LogSource.MODULE)
                } else if (!startTasks) {
                    Logger.i("Registered task: ${task.id}", LogSource.MODULE)
                } else {
                    Logger.i("Task ${task.id} is disabled", LogSource.MODULE)
                }
            }
        }
    }

    fun reloadTasks() {
        runBlocking(Dispatchers.IO) {
            tasks.values.forEach { task -> task.stop() }
            tasks.clear()
            registerTasks()
            Logger.s("Reloaded tasks", LogSource.MODULE)
        }
    }

    @Suppress("UNCHECKED_CAST")
    fun <T : Task> getTask(taskClass: KClass<T>): T? {
        return tasks[taskClass] as? T
    }

    fun toggleTask(taskId: String, enabled: Boolean) {
        val task = tasks.values.find { it.id == taskId } ?: return

        Config.setTaskEnabled(taskId, enabled)

        if (enabled) {
            task.start()
        } else {
            task.stop()
        }
    }

    fun stopAllTasks() {
        tasks.values.forEach { it.stop() }
    }

    fun startPeriodicTask(
        taskId: String,
        initialDelayMillis: Long,
        intervalMillis: Long,
        action: suspend () -> Unit
    ): Job {
        val scheduler = scheduler ?: error("TaskScheduler is not initialized")

        if (scheduler.isTaskRunning(taskId)) {
            scheduler.cancelTask(taskId)
        }

        return scheduler.periodic(
            name = taskId,
            intervalMs = intervalMillis
        ) {
            if (initialDelayMillis > 0) {
                delay(initialDelayMillis)
            }
            action()
        }
    }

    fun startOnceTask(taskId: String, action: suspend () -> Unit): Job {
        val scheduler = scheduler ?: error("TaskScheduler is not initialized")
        return scheduler.once(taskId, action)
    }

    fun startTaskWithRetry(
        taskId: String,
        retries: Int = 3,
        delayMs: Long = 1000,
        action: suspend () -> Unit
    ): Job {
        val scheduler = scheduler ?: error("TaskScheduler is not initialized")
        return scheduler.withRetry(taskId, retries, delayMs, action)
    }

    fun isTaskRunning(taskId: String): Boolean {
        return scheduler?.isTaskRunning(taskId) ?: false
    }

    fun cancelTask(taskId: String) {
        scheduler?.cancelTask(taskId)
    }
} 
